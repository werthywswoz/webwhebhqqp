! function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).THREE = {})
}(this, (function (e) {
    function t() {}

    function i(e, t) {
        this.x = e || 0, this.y = t || 0
    }

    function n(e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
    }

    function r(e, t, i) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0
    }

    function o() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }

    function s(e, t, n, r, a, l, c, u, h, d) {
        Object.defineProperty(this, "id", {
            value: mo++
        }), this.uuid = ho.generateUUID(), this.name = "", this.image = void 0 !== e ? e : s.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : s.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : 1001, this.wrapT = void 0 !== r ? r : 1001, this.magFilter = void 0 !== a ? a : 1006, this.minFilter = void 0 !== l ? l : 1008, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== c ? c : 1023, this.type = void 0 !== u ? u : 1009, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.center = new i(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new o, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : 3e3, this.version = 0, this.onUpdate = null
    }

    function a(e, t, i, n) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
    }

    function l(e, t, i) {
        this.width = e, this.height = t, this.scissor = new a(0, 0, e, t), this.scissorTest = !1, this.viewport = new a(0, 0, e, t), i = i || {}, this.texture = new s(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
    }

    function c(e, t, i) {
        l.call(this, e, t, i), this.samples = 4
    }

    function u(e, t, i) {
        l.call(this, e, t, i)
    }

    function h(e, t, i, n, r, o, a, l, c, u, h, d) {
        s.call(this, null, o, a, l, c, u, n, r, h, d), this.image = {
            data: e,
            width: t,
            height: i
        }, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== u ? u : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1
    }

    function d(e, t) {
        this.min = void 0 !== e ? e : new r(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new r(-1 / 0, -1 / 0, -1 / 0)
    }

    function p(e, t) {
        this.center = void 0 !== e ? e : new r, this.radius = void 0 !== t ? t : 0
    }

    function f(e, t) {
        this.normal = void 0 !== e ? e : new r(1, 0, 0), this.constant = void 0 !== t ? t : 0
    }

    function m(e, t, i, n, r, o) {
        this.planes = [void 0 !== e ? e : new f, void 0 !== t ? t : new f, void 0 !== i ? i : new f, void 0 !== n ? n : new f, void 0 !== r ? r : new f, void 0 !== o ? o : new f]
    }

    function g() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function v(e) {
        var t, i = {};
        for (t in e)
            for (var n in i[t] = {}, e[t]) {
                var r = e[t][n];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? i[t][n] = r.clone() : Array.isArray(r) ? i[t][n] = r.slice() : i[t][n] = r
            }
        return i
    }

    function y(e) {
        for (var t = {}, i = 0; i < e.length; i++) {
            var n, r = v(e[i]);
            for (n in r) t[n] = r[n]
        }
        return t
    }

    function b(e, t, i) {
        return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i)
    }

    function x() {
        function e(r, o) {
            !1 !== i && (n(r, o), t.requestAnimationFrame(e))
        }
        var t = null,
            i = !1,
            n = null;
        return {
            start: function () {
                !0 !== i && null !== n && (t.requestAnimationFrame(e), i = !0)
            },
            stop: function () {
                i = !1
            },
            setAnimationLoop: function (e) {
                n = e
            },
            setContext: function (e) {
                t = e
            }
        }
    }

    function w(e) {
        var t = new WeakMap;
        return {
            get: function (e) {
                return e.isInterleavedBufferAttribute && (e = e.data), t.get(e)
            },
            remove: function (i) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var n = t.get(i);
                n && (e.deleteBuffer(n.buffer), t.delete(i))
            },
            update: function (i, n) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var r = t.get(i);
                if (void 0 === r) t.set(i, function (t, i) {
                    var n = t.array,
                        r = t.dynamic ? 35048 : 35044,
                        o = e.createBuffer();
                    return e.bindBuffer(i, o), e.bufferData(i, n, r), t.onUploadCallback(), i = 5126, n instanceof Float32Array ? i = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? i = 5123 : n instanceof Int16Array ? i = 5122 : n instanceof Uint32Array ? i = 5125 : n instanceof Int32Array ? i = 5124 : n instanceof Int8Array ? i = 5120 : n instanceof Uint8Array && (i = 5121), {
                        buffer: o,
                        type: i,
                        bytesPerElement: n.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(i, n));
                else if (r.version < i.version) {
                    var o = i,
                        s = o.array,
                        a = o.updateRange;
                    e.bindBuffer(n, r.buffer), !1 === o.dynamic ? e.bufferData(n, s, 35044) : -1 === a.count ? e.bufferSubData(n, 0, s) : 0 === a.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(n, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1), r.version = i.version
                }
            }
        }
    }

    function _(e, t, i, n, o, s) {
        this.a = e, this.b = t, this.c = i, this.normal = n && n.isVector3 ? n : new r, this.vertexNormals = Array.isArray(n) ? n : [], this.color = o && o.isColor ? o : new b, this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = void 0 !== s ? s : 0
    }

    function E(e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = n || E.DefaultOrder
    }

    function M() {
        this.mask = 1
    }

    function S() {
        Object.defineProperty(this, "id", {
            value: wo++
        }), this.uuid = ho.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = S.DefaultUp.clone();
        var e = new r,
            t = new E,
            i = new n,
            s = new r(1, 1, 1);
        t.onChange((function () {
            i.setFromEuler(t, !1)
        })), i.onChange((function () {
            t.setFromQuaternion(i, void 0, !1)
        })), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: s
            },
            modelViewMatrix: {
                value: new g
            },
            normalMatrix: {
                value: new o
            }
        }), this.matrix = new g, this.matrixWorld = new g, this.matrixAutoUpdate = S.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new M, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    function T() {
        Object.defineProperty(this, "id", {
            value: _o += 2
        }), this.uuid = ho.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
    }

    function A(e, t, i) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function C(e, t, i) {
        A.call(this, new Int8Array(e), t, i)
    }

    function L(e, t, i) {
        A.call(this, new Uint8Array(e), t, i)
    }

    function P(e, t, i) {
        A.call(this, new Uint8ClampedArray(e), t, i)
    }

    function I(e, t, i) {
        A.call(this, new Int16Array(e), t, i)
    }

    function O(e, t, i) {
        A.call(this, new Uint16Array(e), t, i)
    }

    function R(e, t, i) {
        A.call(this, new Int32Array(e), t, i)
    }

    function D(e, t, i) {
        A.call(this, new Uint32Array(e), t, i)
    }

    function k(e, t, i) {
        A.call(this, new Float32Array(e), t, i)
    }

    function z(e, t, i) {
        A.call(this, new Float64Array(e), t, i)
    }

    function B() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }

    function N(e) {
        if (0 === e.length) return -1 / 0;
        for (var t = e[0], i = 1, n = e.length; i < n; ++i) e[i] > t && (t = e[i]);
        return t
    }

    function F() {
        Object.defineProperty(this, "id", {
            value: Eo += 2
        }), this.uuid = ho.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }

    function H(e, t, i, n, r, o) {
        T.call(this), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: o
        }, this.fromBufferGeometry(new U(e, t, i, n, r, o)), this.mergeVertices()
    }

    function U(e, t, i, n, o, s) {
        function a(e, t, i, n, o, s, a, m, g, v, y) {
            var b = s / g,
                x = a / v,
                w = s / 2,
                _ = a / 2,
                E = m / 2;
            a = g + 1;
            var M, S, T = v + 1,
                A = s = 0,
                C = new r;
            for (S = 0; S < T; S++) {
                var L = S * x - _;
                for (M = 0; M < a; M++) C[e] = (M * b - w) * n, C[t] = L * o, C[i] = E, u.push(C.x, C.y, C.z), C[e] = 0, C[t] = 0, C[i] = 0 < m ? 1 : -1, h.push(C.x, C.y, C.z), d.push(M / g), d.push(1 - S / v), s += 1
            }
            for (S = 0; S < v; S++)
                for (M = 0; M < g; M++) e = p + M + a * (S + 1), t = p + (M + 1) + a * (S + 1), i = p + (M + 1) + a * S, c.push(p + M + a * S, e, i), c.push(e, t, i), A += 6;
            l.addGroup(f, A, y), f += A, p += s
        }
        F.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: o,
            depthSegments: s
        };
        var l = this;
        e = e || 1, t = t || 1, i = i || 1, n = Math.floor(n) || 1, o = Math.floor(o) || 1, s = Math.floor(s) || 1;
        var c = [],
            u = [],
            h = [],
            d = [],
            p = 0,
            f = 0;
        a("z", "y", "x", -1, -1, i, t, e, s, o, 0), a("z", "y", "x", 1, -1, i, t, -e, s, o, 1), a("x", "z", "y", 1, 1, e, i, t, n, s, 2), a("x", "z", "y", 1, -1, e, i, -t, n, s, 3), a("x", "y", "z", 1, -1, e, t, i, n, o, 4), a("x", "y", "z", -1, -1, e, t, -i, n, o, 5), this.setIndex(c), this.addAttribute("position", new k(u, 3)), this.addAttribute("normal", new k(h, 3)), this.addAttribute("uv", new k(d, 2))
    }

    function j(e, t, i, n) {
        T.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        }, this.fromBufferGeometry(new G(e, t, i, n)), this.mergeVertices()
    }

    function G(e, t, i, n) {
        F.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        };
        var r = (e = e || 1) / 2,
            o = (t = t || 1) / 2,
            s = (i = Math.floor(i) || 1) + 1,
            a = (n = Math.floor(n) || 1) + 1,
            l = e / i,
            c = t / n,
            u = [],
            h = [],
            d = [],
            p = [];
        for (e = 0; e < a; e++) {
            var f = e * c - o;
            for (t = 0; t < s; t++) h.push(t * l - r, -f, 0), d.push(0, 0, 1), p.push(t / i), p.push(1 - e / n)
        }
        for (e = 0; e < n; e++)
            for (t = 0; t < i; t++) r = t + s * (e + 1), o = t + 1 + s * (e + 1), a = t + 1 + s * e, u.push(t + s * e, r, a), u.push(r, o, a);
        this.setIndex(u), this.addAttribute("position", new k(h, 3)), this.addAttribute("normal", new k(d, 3)), this.addAttribute("uv", new k(p, 2))
    }

    function V() {
        Object.defineProperty(this, "id", {
            value: Mo++
        }), this.uuid = ho.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.vertexTangents = this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
    }

    function W(e) {
        V.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
    }

    function q(e, t) {
        this.origin = void 0 !== e ? e : new r, this.direction = void 0 !== t ? t : new r
    }

    function X(e, t, i) {
        this.a = void 0 !== e ? e : new r, this.b = void 0 !== t ? t : new r, this.c = void 0 !== i ? i : new r
    }

    function Y(e) {
        V.call(this), this.type = "MeshBasicMaterial", this.color = new b(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function Z(e, t) {
        S.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new F, this.material = void 0 !== t ? t : new Y({
            color: 16777215 * Math.random()
        }), this.drawMode = 0, this.updateMorphTargets()
    }

    function Q(e, t, i, n) {
        function r(e, i) {
            t.buffers.color.setClear(e.r, e.g, e.b, i, n)
        }
        var o, s, a = new b(0),
            l = 0,
            c = null,
            u = 0;
        return {
            getClearColor: function () {
                return a
            },
            setClearColor: function (e, t) {
                a.set(e), r(a, l = void 0 !== t ? t : 1)
            },
            getClearAlpha: function () {
                return l
            },
            setClearAlpha: function (e) {
                r(a, l = e)
            },
            render: function (t, n, h, d) {
                n = n.background, (h = (h = e.vr).getSession && h.getSession()) && "additive" === h.environmentBlendMode && (n = null), null === n ? (r(a, l), c = null, u = 0) : n && n.isColor && (r(n, 1), d = !0, c = null, u = 0), (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), n && (n.isCubeTexture || n.isWebGLRenderTargetCube) ? (void 0 === s && ((s = new Z(new U(1, 1, 1), new W({
                    type: "BackgroundCubeMaterial",
                    uniforms: v(xo.cube.uniforms),
                    vertexShader: xo.cube.vertexShader,
                    fragmentShader: xo.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"), s.geometry.removeAttribute("uv"), s.onBeforeRender = function (e, t, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld)
                }, Object.defineProperty(s.material, "map", {
                    get: function () {
                        return this.uniforms.tCube.value
                    }
                }), i.update(s)), d = n.isWebGLRenderTargetCube ? n.texture : n, s.material.uniforms.tCube.value = d, s.material.uniforms.tFlip.value = n.isWebGLRenderTargetCube ? 1 : -1, c === n && u === d.version || (s.material.needsUpdate = !0, c = n, u = d.version), t.unshift(s, s.geometry, s.material, 0, 0, null)) : n && n.isTexture && (void 0 === o && ((o = new Z(new G(2, 2), new W({
                    type: "BackgroundMaterial",
                    uniforms: v(xo.background.uniforms),
                    vertexShader: xo.background.vertexShader,
                    fragmentShader: xo.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"), Object.defineProperty(o.material, "map", {
                    get: function () {
                        return this.uniforms.t2D.value
                    }
                }), i.update(o)), o.material.uniforms.t2D.value = n, !0 === n.matrixAutoUpdate && n.updateMatrix(), o.material.uniforms.uvTransform.value.copy(n.matrix), c === n && u === n.version || (o.material.needsUpdate = !0, c = n, u = n.version), t.unshift(o, o.geometry, o.material, 0, 0, null))
            }
        }
    }

    function J(e, t, i, n) {
        var r;
        this.setMode = function (e) {
            r = e
        }, this.render = function (t, n) {
            e.drawArrays(r, t, n), i.update(n, r)
        }, this.renderInstances = function (o, s, a) {
            if (n.isWebGL2) var l = e;
            else if (null === (l = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, s, a, o.maxInstancedCount), i.update(a, r, o.maxInstancedCount)
        }
    }

    function K(e, t, i) {
        function n(t) {
            if ("highp" === t) {
                if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                t = "mediump"
            }
            return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
        }
        var r, o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
            s = void 0 !== i.precision ? i.precision : "highp",
            a = n(s);
        a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a), i = !0 === i.logarithmicDepthBuffer, a = e.getParameter(34930);
        var l = e.getParameter(35660),
            c = e.getParameter(3379),
            u = e.getParameter(34076),
            h = e.getParameter(34921),
            d = e.getParameter(36347),
            p = e.getParameter(36348),
            f = e.getParameter(36349),
            m = 0 < l,
            g = o || !!t.get("OES_texture_float");
        return {
            isWebGL2: o,
            getMaxAnisotropy: function () {
                if (void 0 !== r) return r;
                var i = t.get("EXT_texture_filter_anisotropic");
                return r = null !== i ? e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: n,
            precision: s,
            logarithmicDepthBuffer: i,
            maxTextures: a,
            maxVertexTextures: l,
            maxTextureSize: c,
            maxCubemapSize: u,
            maxAttributes: h,
            maxVertexUniforms: d,
            maxVaryings: p,
            maxFragmentUniforms: f,
            vertexTextures: m,
            floatFragmentTextures: g,
            floatVertexTextures: m && g,
            maxSamples: o ? e.getParameter(36183) : 0
        }
    }

    function $() {
        function e() {
            u.value !== n && (u.value = n, u.needsUpdate = 0 < r), i.numPlanes = r, i.numIntersection = 0
        }

        function t(e, t, n, r) {
            var o = null !== e ? e.length : 0,
                s = null;
            if (0 !== o) {
                if (s = u.value, !0 !== r || null === s)
                    for (r = n + 4 * o, t = t.matrixWorldInverse, c.getNormalMatrix(t), (null === s || s.length < r) && (s = new Float32Array(r)), r = 0; r !== o; ++r, n += 4) l.copy(e[r]).applyMatrix4(t, c), l.normal.toArray(s, n), s[n + 3] = l.constant;
                u.value = s, u.needsUpdate = !0
            }
            return i.numPlanes = o, s
        }
        var i = this,
            n = null,
            r = 0,
            s = !1,
            a = !1,
            l = new f,
            c = new o,
            u = {
                value: null,
                needsUpdate: !1
            };
        this.uniform = u, this.numIntersection = this.numPlanes = 0, this.init = function (e, i, o) {
            var a = 0 !== e.length || i || 0 !== r || s;
            return s = i, n = t(e, o, 0), r = e.length, a
        }, this.beginShadows = function () {
            a = !0, t(null)
        }, this.endShadows = function () {
            a = !1, e()
        }, this.setState = function (i, o, l, c, h, d) {
            if (!s || null === i || 0 === i.length || a && !l) a ? t(null) : e();
            else {
                var p = 4 * (l = a ? 0 : r),
                    f = h.clippingState || null;
                for (u.value = f, f = t(i, c, p, d), i = 0; i !== p; ++i) f[i] = n[i];
                h.clippingState = f, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += l
            }
        }
    }

    function ee(e) {
        var t = {};
        return {
            get: function (i) {
                if (void 0 !== t[i]) return t[i];
                switch (i) {
                    case "WEBGL_depth_texture":
                        var n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        n = e.getExtension(i)
                }
                return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), t[i] = n
            }
        }
    }

    function te(e, t, i) {
        function n(e) {
            var s = e.target;
            for (var a in null !== (e = r[s.id]).index && t.remove(e.index), e.attributes) t.remove(e.attributes[a]);
            s.removeEventListener("dispose", n), delete r[s.id], (a = o[e.id]) && (t.remove(a), delete o[e.id]), i.memory.geometries--
        }
        var r = {},
            o = {};
        return {
            get: function (e, t) {
                var o = r[t.id];
                return o || (t.addEventListener("dispose", n), t.isBufferGeometry ? o = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new F).setFromObject(e)), o = t._bufferGeometry), r[t.id] = o, i.memory.geometries++, o)
            },
            update: function (e) {
                var i = e.index,
                    n = e.attributes;
                for (var r in null !== i && t.update(i, 34963), n) t.update(n[r], 34962);
                for (r in e = e.morphAttributes) {
                    n = 0;
                    for (var o = (i = e[r]).length; n < o; n++) t.update(i[n], 34962)
                }
            },
            getWireframeAttribute: function (e) {
                var i = o[e.id];
                if (i) return i;
                i = [];
                var n = e.index,
                    r = e.attributes;
                if (null !== n) {
                    r = 0;
                    for (var s = (n = n.array).length; r < s; r += 3) {
                        var a = n[r + 0],
                            l = n[r + 1],
                            c = n[r + 2];
                        i.push(a, l, l, c, c, a)
                    }
                } else
                    for (n = r.position.array, r = 0, s = n.length / 3 - 1; r < s; r += 3) a = r + 0, l = r + 1, c = r + 2, i.push(a, l, l, c, c, a);
                return i = new(65535 < N(i) ? D : O)(i, 1), t.update(i, 34963), o[e.id] = i
            }
        }
    }

    function ie(e, t, i, n) {
        var r, o, s;
        this.setMode = function (e) {
            r = e
        }, this.setIndex = function (e) {
            o = e.type, s = e.bytesPerElement
        }, this.render = function (t, n) {
            e.drawElements(r, n, o, t * s), i.update(n, r)
        }, this.renderInstances = function (a, l, c) {
            if (n.isWebGL2) var u = e;
            else if (null === (u = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            u[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, c, o, l * s, a.maxInstancedCount), i.update(c, r, a.maxInstancedCount)
        }
    }

    function ne(e) {
        var t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: t,
            programs: null,
            autoReset: !0,
            reset: function () {
                t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
            },
            update: function (e, i, n) {
                switch (n = n || 1, t.calls++, i) {
                    case 4:
                        t.triangles += e / 3 * n;
                        break;
                    case 5:
                    case 6:
                        t.triangles += n * (e - 2);
                        break;
                    case 1:
                        t.lines += e / 2 * n;
                        break;
                    case 3:
                        t.lines += n * (e - 1);
                        break;
                    case 2:
                        t.lines += n * e;
                        break;
                    case 0:
                        t.points += n * e;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                }
            }
        }
    }

    function re(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }

    function oe(e) {
        var t = {},
            i = new Float32Array(8);
        return {
            update: function (n, r, o, s) {
                var a = n.morphTargetInfluences,
                    l = a.length;
                if (void 0 === (n = t[r.id])) {
                    n = [];
                    for (var c = 0; c < l; c++) n[c] = [c, 0];
                    t[r.id] = n
                }
                var u = o.morphTargets && r.morphAttributes.position;
                for (o = o.morphNormals && r.morphAttributes.normal, c = 0; c < l; c++) {
                    var h = n[c];
                    0 !== h[1] && (u && r.removeAttribute("morphTarget" + c), o && r.removeAttribute("morphNormal" + c))
                }
                for (c = 0; c < l; c++)(h = n[c])[0] = c, h[1] = a[c];
                for (n.sort(re), c = 0; 8 > c; c++)(h = n[c]) && (a = h[0], l = h[1]) ? (u && r.addAttribute("morphTarget" + c, u[a]), o && r.addAttribute("morphNormal" + c, o[a]), i[c] = l) : i[c] = 0;
                s.getUniforms().setValue(e, "morphTargetInfluences", i)
            }
        }
    }

    function se(e, t) {
        var i = {};
        return {
            update: function (n) {
                var r = t.render.frame,
                    o = n.geometry,
                    s = e.get(n, o);
                return i[s.id] !== r && (o.isGeometry && s.updateFromObject(n), e.update(s), i[s.id] = r), s
            },
            dispose: function () {
                i = {}
            }
        }
    }

    function ae(e, t, i, n, r, o, a, l, c, u) {
        e = void 0 !== e ? e : [], s.call(this, e, void 0 !== t ? t : 301, i, n, r, o, void 0 !== a ? a : 1022, l, c, u), this.flipY = !1
    }

    function le(e, t, i, n) {
        s.call(this, null), this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
        }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1
    }

    function ce(e, t, i, n) {
        s.call(this, null), this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
        }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1
    }

    function ue(e, t, i) {
        var n = e[0];
        if (0 >= n || 0 < n) return e;
        var r = t * i,
            o = Lo[r];
        if (void 0 === o && (o = new Float32Array(r), Lo[r] = o), 0 !== t)
            for (n.toArray(o, 0), n = 1, r = 0; n !== t; ++n) r += i, e[n].toArray(o, r);
        return o
    }

    function he(e, t) {
        if (e.length !== t.length) return !1;
        for (var i = 0, n = e.length; i < n; i++)
            if (e[i] !== t[i]) return !1;
        return !0
    }

    function de(e, t) {
        for (var i = 0, n = t.length; i < n; i++) e[i] = t[i]
    }

    function pe(e, t) {
        var i = Po[t];
        void 0 === i && (i = new Int32Array(t), Po[t] = i);
        for (var n = 0; n !== t; ++n) i[n] = e.allocateTextureUnit();
        return i
    }

    function fe(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t)
    }

    function me(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y) : he(i, t) || (e.uniform2fv(this.addr, t), de(i, t))
    }

    function ge(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z) : void 0 !== t.r ? i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b) : he(i, t) || (e.uniform3fv(this.addr, t), de(i, t))
    }

    function ve(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w) : he(i, t) || (e.uniform4fv(this.addr, t), de(i, t))
    }

    function ye(e, t) {
        var i = this.cache,
            n = t.elements;
        void 0 === n ? he(i, t) || (e.uniformMatrix2fv(this.addr, !1, t), de(i, t)) : he(i, n) || (Ro.set(n), e.uniformMatrix2fv(this.addr, !1, Ro), de(i, n))
    }

    function be(e, t) {
        var i = this.cache,
            n = t.elements;
        void 0 === n ? he(i, t) || (e.uniformMatrix3fv(this.addr, !1, t), de(i, t)) : he(i, n) || (Oo.set(n), e.uniformMatrix3fv(this.addr, !1, Oo), de(i, n))
    }

    function xe(e, t) {
        var i = this.cache,
            n = t.elements;
        void 0 === n ? he(i, t) || (e.uniformMatrix4fv(this.addr, !1, t), de(i, t)) : he(i, n) || (Io.set(n), e.uniformMatrix4fv(this.addr, !1, Io), de(i, n))
    }

    function we(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(t || So, r)
    }

    function _e(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(t || To, r)
    }

    function Ee(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(t || Ao, r)
    }

    function Me(e, t, i) {
        var n = this.cache,
            r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(t || Co, r)
    }

    function Se(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t)
    }

    function Te(e, t) {
        var i = this.cache;
        he(i, t) || (e.uniform2iv(this.addr, t), de(i, t))
    }

    function Ae(e, t) {
        var i = this.cache;
        he(i, t) || (e.uniform3iv(this.addr, t), de(i, t))
    }

    function Ce(e, t) {
        var i = this.cache;
        he(i, t) || (e.uniform4iv(this.addr, t), de(i, t))
    }

    function Le(e, t) {
        e.uniform1fv(this.addr, t)
    }

    function Pe(e, t) {
        e.uniform1iv(this.addr, t)
    }

    function Ie(e, t) {
        e.uniform2iv(this.addr, t)
    }

    function Oe(e, t) {
        e.uniform3iv(this.addr, t)
    }

    function Re(e, t) {
        e.uniform4iv(this.addr, t)
    }

    function De(e, t) {
        t = ue(t, this.size, 2), e.uniform2fv(this.addr, t)
    }

    function ke(e, t) {
        t = ue(t, this.size, 3), e.uniform3fv(this.addr, t)
    }

    function ze(e, t) {
        t = ue(t, this.size, 4), e.uniform4fv(this.addr, t)
    }

    function Be(e, t) {
        t = ue(t, this.size, 4), e.uniformMatrix2fv(this.addr, !1, t)
    }

    function Ne(e, t) {
        t = ue(t, this.size, 9), e.uniformMatrix3fv(this.addr, !1, t)
    }

    function Fe(e, t) {
        t = ue(t, this.size, 16), e.uniformMatrix4fv(this.addr, !1, t)
    }

    function He(e, t, i) {
        var n = t.length,
            r = pe(i, n);
        for (e.uniform1iv(this.addr, r), e = 0; e !== n; ++e) i.safeSetTexture2D(t[e] || So, r[e])
    }

    function Ue(e, t, i) {
        var n = t.length,
            r = pe(i, n);
        for (e.uniform1iv(this.addr, r), e = 0; e !== n; ++e) i.safeSetTextureCube(t[e] || Co, r[e])
    }

    function je(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.setValue = function (e) {
            switch (e) {
                case 5126:
                    return fe;
                case 35664:
                    return me;
                case 35665:
                    return ge;
                case 35666:
                    return ve;
                case 35674:
                    return ye;
                case 35675:
                    return be;
                case 35676:
                    return xe;
                case 35678:
                case 36198:
                    return we;
                case 35679:
                    return Ee;
                case 35680:
                    return Me;
                case 36289:
                    return _e;
                case 5124:
                case 35670:
                    return Se;
                case 35667:
                case 35671:
                    return Te;
                case 35668:
                case 35672:
                    return Ae;
                case 35669:
                case 35673:
                    return Ce
            }
        }(t.type)
    }

    function Ge(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = function (e) {
            switch (e) {
                case 5126:
                    return Le;
                case 35664:
                    return De;
                case 35665:
                    return ke;
                case 35666:
                    return ze;
                case 35674:
                    return Be;
                case 35675:
                    return Ne;
                case 35676:
                    return Fe;
                case 35678:
                    return He;
                case 35680:
                    return Ue;
                case 5124:
                case 35670:
                    return Pe;
                case 35667:
                case 35671:
                    return Ie;
                case 35668:
                case 35672:
                    return Oe;
                case 35669:
                case 35673:
                    return Re
            }
        }(t.type)
    }

    function Ve(e) {
        this.id = e, this.seq = [], this.map = {}
    }

    function We(e, t) {
        this.seq = [], this.map = {};
        for (var i = e.getProgramParameter(t, 35718), n = 0; n < i; ++n) {
            var r = e.getActiveUniform(t, n),
                o = e.getUniformLocation(t, r.name),
                s = this,
                a = r.name,
                l = a.length;
            for (Do.lastIndex = 0;;) {
                var c = Do.exec(a),
                    u = Do.lastIndex,
                    h = c[1],
                    d = c[3];
                if ("]" === c[2] && (h |= 0), void 0 === d || "[" === d && u + 2 === l) {
                    a = s, r = void 0 === d ? new je(h, r, o) : new Ge(h, r, o), a.seq.push(r), a.map[r.id] = r;
                    break
                }
                void 0 === (d = s.map[h]) && (d = new Ve(h), h = s, s = d, h.seq.push(s), h.map[s.id] = s), s = d
            }
        }
    }

    function qe(e, t, i, n) {
        var r = e.createShader(t);
        return e.shaderSource(r, i), e.compileShader(r), !0 === n && (!1 === e.getShaderParameter(r, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === t ? "vertex" : "fragment", e.getShaderInfoLog(r), function (e) {
            e = e.split("\n");
            for (var t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
            return e.join("\n")
        }(i))), r
    }

    function Xe(e) {
        switch (e) {
            case 3e3:
                return ["Linear", "( value )"];
            case 3001:
                return ["sRGB", "( value )"];
            case 3002:
                return ["RGBE", "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case 3007:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw Error("unsupported encoding: " + e)
        }
    }

    function Ye(e, t) {
        return "vec4 " + e + "( vec4 value ) { return " + (t = Xe(t))[0] + "ToLinear" + t[1] + "; }"
    }

    function Ze(e, t) {
        return "vec4 " + e + "( vec4 value ) { return LinearTo" + (t = Xe(t))[0] + t[1] + "; }"
    }

    function Qe(e, t) {
        switch (t) {
            case 1:
                t = "Linear";
                break;
            case 2:
                t = "Reinhard";
                break;
            case 3:
                t = "Uncharted2";
                break;
            case 4:
                t = "OptimizedCineon";
                break;
            case 5:
                t = "ACESFilmic";
                break;
            default:
                throw Error("unsupported toneMapping: " + t)
        }
        return "vec3 " + e + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
    }

    function Je(e) {
        return "" !== e
    }

    function Ke(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    }

    function $e(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }

    function et(e) {
        return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, (function (e, t) {
            if (void 0 === (e = go[t])) throw Error("Can not resolve #include <" + t + ">");
            return et(e)
        }))
    }

    function tt(e) {
        return e.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, (function (e, t, i, n) {
            for (e = "", t = parseInt(t); t < parseInt(i); t++) e += n.replace(/\[ i \]/g, "[ " + t + " ]");
            return e
        }))
    }

    function it(e, t, i, n, r, o, s, a) {
        var l = e.context,
            c = n.defines,
            u = r.vertexShader,
            h = r.fragmentShader,
            d = "SHADOWMAP_TYPE_BASIC";
        1 === o.shadowMapType ? d = "SHADOWMAP_TYPE_PCF" : 2 === o.shadowMapType && (d = "SHADOWMAP_TYPE_PCF_SOFT");
        var p = "ENVMAP_TYPE_CUBE",
            f = "ENVMAP_MODE_REFLECTION",
            m = "ENVMAP_BLENDING_MULTIPLY";
        if (o.envMap) {
            switch (n.envMap.mapping) {
                case 301:
                case 302:
                    p = "ENVMAP_TYPE_CUBE";
                    break;
                case 306:
                case 307:
                    p = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case 303:
                case 304:
                    p = "ENVMAP_TYPE_EQUIREC";
                    break;
                case 305:
                    p = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
                case 302:
                case 304:
                    f = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
                case 0:
                    m = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    m = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    m = "ENVMAP_BLENDING_ADD"
            }
        }
        var g, v, y = 0 < e.gammaFactor ? e.gammaFactor : 1,
            b = s.isWebGL2 ? "" : function (e, t, i) {
                return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap && !t.objectSpaceNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Je).join("\n")
            }(n.extensions, o, t),
            x = function (e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    !1 !== n && i.push("#define " + t + " " + n)
                }
                return i.join("\n")
            }(c),
            w = l.createProgram();
        return n.isRawShaderMaterial ? (0 < (c = [x].filter(Je).join("\n")).length && (c += "\n"), 0 < (t = [b, x].filter(Je).join("\n")).length && (t += "\n")) : (c = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, x, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + f : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (s.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Je).join("\n"), t = [b, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, x, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + y, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + f : "", o.envMap ? "#define " + m : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (s.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (s.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== o.toneMapping ? "#define TONE_MAPPING" : "", 0 !== o.toneMapping ? go.tonemapping_pars_fragment : "", 0 !== o.toneMapping ? Qe("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? go.encodings_pars_fragment : "", o.mapEncoding ? Ye("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? Ye("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? Ye("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Ye("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? Ze("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Je).join("\n")), u = $e(u = Ke(u = et(u), o), o), h = $e(h = Ke(h = et(h), o), o), u = tt(u), h = tt(h), s.isWebGL2 && !n.isRawShaderMaterial && (s = !1, d = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && null !== u.match(d) && null !== h.match(d) && (s = !0, u = u.replace(d, ""), h = h.replace(d, "")), c = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + c, t = ["#version 300 es\n\n#define varying in", s ? "" : "out highp vec4 pc_fragColor;", s ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + t), h = t + h, u = qe(l, 35633, c + u, e.debug.checkShaderErrors), h = qe(l, 35632, h, e.debug.checkShaderErrors), l.attachShader(w, u), l.attachShader(w, h), void 0 !== n.index0AttributeName ? l.bindAttribLocation(w, 0, n.index0AttributeName) : !0 === o.morphTargets && l.bindAttribLocation(w, 0, "position"), l.linkProgram(w), e.debug.checkShaderErrors && (e = l.getProgramInfoLog(w).trim(), o = l.getShaderInfoLog(u).trim(), s = l.getShaderInfoLog(h).trim(), p = d = !0, !1 === l.getProgramParameter(w, 35714) ? (d = !1, console.error("THREE.WebGLProgram: shader error: ", l.getError(), "35715", l.getProgramParameter(w, 35715), "gl.getProgramInfoLog", e, o, s)) : "" !== e ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== o && "" !== s || (p = !1), p && (this.diagnostics = {
            runnable: d,
            material: n,
            programLog: e,
            vertexShader: {
                log: o,
                prefix: c
            },
            fragmentShader: {
                log: s,
                prefix: t
            }
        })), l.deleteShader(u), l.deleteShader(h), this.getUniforms = function () {
            return void 0 === g && (g = new We(l, w, a)), g
        }, this.getAttributes = function () {
            if (void 0 === v) {
                for (var e = {}, t = l.getProgramParameter(w, 35721), i = 0; i < t; i++) {
                    var n = l.getActiveAttrib(w, i).name;
                    e[n] = l.getAttribLocation(w, n)
                }
                v = e
            }
            return v
        }, this.destroy = function () {
            l.deleteProgram(w), this.program = void 0
        }, Object.defineProperties(this, {
            uniforms: {
                get: function () {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                }
            },
            attributes: {
                get: function () {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                }
            }
        }), this.name = r.name, this.id = ko++, this.code = i, this.usedTimes = 1, this.program = w, this.vertexShader = u, this.fragmentShader = h, this
    }

    function nt(e, t, i, n) {
        function r(e, t) {
            if (e) e.isTexture ? i = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = e.texture.encoding);
            else var i = 3e3;
            return 3e3 === i && t && (i = 3007), i
        }
        var o = [],
            s = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            a = "precision supportsVertexTextures map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
        this.getParameters = function (t, n, o, a, l, c, u) {
            var h = s[t.type];
            if (u.isSkinnedMesh) {
                var d = u.skeleton.bones;
                if (i.floatVertexTextures) d = 1024;
                else {
                    var p = Math.min(Math.floor((i.maxVertexUniforms - 20) / 4), d.length);
                    p < d.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + d.length + " bones. This GPU supports " + p + "."), d = 0) : d = p
                }
            } else d = 0;
            p = i.precision, null !== t.precision && ((p = i.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", p, "instead."));
            var f = e.getRenderTarget();
            return {
                shaderID: h,
                precision: p,
                supportsVertexTextures: i.vertexTextures,
                outputEncoding: r(f ? f.texture : null, e.gammaOutput),
                map: !!t.map,
                mapEncoding: r(t.map, e.gammaInput),
                matcap: !!t.matcap,
                matcapEncoding: r(t.matcap, e.gammaInput),
                envMap: !!t.envMap,
                envMapMode: t.envMap && t.envMap.mapping,
                envMapEncoding: r(t.envMap, e.gammaInput),
                envMapCubeUV: !!t.envMap && (306 === t.envMap.mapping || 307 === t.envMap.mapping),
                lightMap: !!t.lightMap,
                aoMap: !!t.aoMap,
                emissiveMap: !!t.emissiveMap,
                emissiveMapEncoding: r(t.emissiveMap, e.gammaInput),
                bumpMap: !!t.bumpMap,
                normalMap: !!t.normalMap,
                objectSpaceNormalMap: 1 === t.normalMapType,
                displacementMap: !!t.displacementMap,
                roughnessMap: !!t.roughnessMap,
                metalnessMap: !!t.metalnessMap,
                specularMap: !!t.specularMap,
                alphaMap: !!t.alphaMap,
                gradientMap: !!t.gradientMap,
                combine: t.combine,
                vertexTangents: t.normalMap && t.vertexTangents,
                vertexColors: t.vertexColors,
                fog: !!a,
                useFog: t.fog,
                fogExp: a && a.isFogExp2,
                flatShading: t.flatShading,
                sizeAttenuation: t.sizeAttenuation,
                logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                skinning: t.skinning && 0 < d,
                maxBones: d,
                useVertexTexture: i.floatVertexTextures,
                morphTargets: t.morphTargets,
                morphNormals: t.morphNormals,
                maxMorphTargets: e.maxMorphTargets,
                maxMorphNormals: e.maxMorphNormals,
                numDirLights: n.directional.length,
                numPointLights: n.point.length,
                numSpotLights: n.spot.length,
                numRectAreaLights: n.rectArea.length,
                numHemiLights: n.hemi.length,
                numClippingPlanes: l,
                numClipIntersection: c,
                dithering: t.dithering,
                shadowMapEnabled: e.shadowMap.enabled && u.receiveShadow && 0 < o.length,
                shadowMapType: e.shadowMap.type,
                toneMapping: e.toneMapping,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: t.premultipliedAlpha,
                alphaTest: t.alphaTest,
                doubleSided: 2 === t.side,
                flipSided: 1 === t.side,
                depthPacking: void 0 !== t.depthPacking && t.depthPacking
            }
        }, this.getProgramCode = function (t, i) {
            var n = [];
            if (i.shaderID ? n.push(i.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines)
                for (var r in t.defines) n.push(r), n.push(t.defines[r]);
            for (r = 0; r < a.length; r++) n.push(i[a[r]]);
            return n.push(t.onBeforeCompile.toString()), n.push(e.gammaOutput), n.push(e.gammaFactor), n.join()
        }, this.acquireProgram = function (r, s, a, l) {
            for (var c, u = 0, h = o.length; u < h; u++) {
                var d = o[u];
                if (d.code === l) {
                    ++(c = d).usedTimes;
                    break
                }
            }
            return void 0 === c && (c = new it(e, t, l, r, s, a, i, n), o.push(c)), c
        }, this.releaseProgram = function (e) {
            if (0 == --e.usedTimes) {
                var t = o.indexOf(e);
                o[t] = o[o.length - 1], o.pop(), e.destroy()
            }
        }, this.programs = o
    }

    function rt() {
        var e = new WeakMap;
        return {
            get: function (t) {
                var i = e.get(t);
                return void 0 === i && (i = {}, e.set(t, i)), i
            },
            remove: function (t) {
                e.delete(t)
            },
            update: function (t, i, n) {
                e.get(t)[i] = n
            },
            dispose: function () {
                e = new WeakMap
            }
        }
    }

    function ot(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function st(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function at() {
        function e(e, n, r, s, a, l) {
            var c = t[i];
            return void 0 === c ? (c = {
                id: e.id,
                object: e,
                geometry: n,
                material: r,
                program: r.program || o,
                groupOrder: s,
                renderOrder: e.renderOrder,
                z: a,
                group: l
            }, t[i] = c) : (c.id = e.id, c.object = e, c.geometry = n, c.material = r, c.program = r.program || o, c.groupOrder = s, c.renderOrder = e.renderOrder, c.z = a, c.group = l), i++, c
        }
        var t = [],
            i = 0,
            n = [],
            r = [],
            o = {
                id: -1
            };
        return {
            opaque: n,
            transparent: r,
            init: function () {
                i = 0, n.length = 0, r.length = 0
            },
            push: function (t, i, o, s, a, l) {
                t = e(t, i, o, s, a, l), (!0 === o.transparent ? r : n).push(t)
            },
            unshift: function (t, i, o, s, a, l) {
                t = e(t, i, o, s, a, l), (!0 === o.transparent ? r : n).unshift(t)
            },
            sort: function () {
                1 < n.length && n.sort(ot), 1 < r.length && r.sort(st)
            }
        }
    }

    function lt() {
        function e(i) {
            (i = i.target).removeEventListener("dispose", e), delete t[i.id]
        }
        var t = {};
        return {
            get: function (i, n) {
                var r = t[i.id];
                if (void 0 === r) {
                    var o = new at;
                    t[i.id] = {}, t[i.id][n.id] = o, i.addEventListener("dispose", e)
                } else void 0 === (o = r[n.id]) && (o = new at, r[n.id] = o);
                return o
            },
            dispose: function () {
                t = {}
            }
        }
    }

    function ct() {
        var e = {};
        return {
            get: function (t) {
                if (void 0 !== e[t.id]) return e[t.id];
                switch (t.type) {
                    case "DirectionalLight":
                        var n = {
                            direction: new r,
                            color: new b,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new r,
                            direction: new r,
                            color: new b,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new r,
                            color: new b,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new r,
                            skyColor: new b,
                            groundColor: new b
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new b,
                            position: new r,
                            halfWidth: new r,
                            halfHeight: new r
                        }
                }
                return e[t.id] = n
            }
        }
    }

    function ut() {
        for (var e = new ct, t = {
                id: zo++,
                hash: {
                    stateID: -1,
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    shadowsLength: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            }, i = 0; 9 > i; i++) t.probe.push(new r);
        var n = new r,
            o = new g,
            s = new g;
        return {
            setup: function (i, r, a) {
                for (var l = 0, c = 0, u = 0, h = 0; 9 > h; h++) t.probe[h].set(0, 0, 0);
                var d = 0,
                    p = 0,
                    f = 0,
                    m = 0,
                    g = 0;
                a = a.matrixWorldInverse, h = 0;
                for (var v = i.length; h < v; h++) {
                    var y = i[h],
                        b = y.color,
                        x = y.intensity,
                        w = y.distance,
                        _ = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                    if (y.isAmbientLight) l += b.r * x, c += b.g * x, u += b.b * x;
                    else if (y.isLightProbe)
                        for (_ = 0; 9 > _; _++) t.probe[_].addScaledVector(y.sh.coefficients[_], x);
                    else if (y.isDirectionalLight) {
                        var E = e.get(y);
                        E.color.copy(y.color).multiplyScalar(y.intensity), E.direction.setFromMatrixPosition(y.matrixWorld), n.setFromMatrixPosition(y.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(a), (E.shadow = y.castShadow) && (x = y.shadow, E.shadowBias = x.bias, E.shadowRadius = x.radius, E.shadowMapSize = x.mapSize), t.directionalShadowMap[d] = _, t.directionalShadowMatrix[d] = y.shadow.matrix, t.directional[d] = E, d++
                    } else y.isSpotLight ? ((E = e.get(y)).position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(a), E.color.copy(b).multiplyScalar(x), E.distance = w, E.direction.setFromMatrixPosition(y.matrixWorld), n.setFromMatrixPosition(y.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(a), E.coneCos = Math.cos(y.angle), E.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)), E.decay = y.decay, (E.shadow = y.castShadow) && (x = y.shadow, E.shadowBias = x.bias, E.shadowRadius = x.radius, E.shadowMapSize = x.mapSize), t.spotShadowMap[f] = _, t.spotShadowMatrix[f] = y.shadow.matrix, t.spot[f] = E, f++) : y.isRectAreaLight ? ((E = e.get(y)).color.copy(b).multiplyScalar(x), E.position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(a), s.identity(), o.copy(y.matrixWorld), o.premultiply(a), s.extractRotation(o), E.halfWidth.set(.5 * y.width, 0, 0), E.halfHeight.set(0, .5 * y.height, 0), E.halfWidth.applyMatrix4(s), E.halfHeight.applyMatrix4(s), t.rectArea[m] = E, m++) : y.isPointLight ? ((E = e.get(y)).position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(a), E.color.copy(y.color).multiplyScalar(y.intensity), E.distance = y.distance, E.decay = y.decay, (E.shadow = y.castShadow) && (x = y.shadow, E.shadowBias = x.bias, E.shadowRadius = x.radius, E.shadowMapSize = x.mapSize, E.shadowCameraNear = x.camera.near, E.shadowCameraFar = x.camera.far), t.pointShadowMap[p] = _, t.pointShadowMatrix[p] = y.shadow.matrix, t.point[p] = E, p++) : y.isHemisphereLight && ((E = e.get(y)).direction.setFromMatrixPosition(y.matrixWorld), E.direction.transformDirection(a), E.direction.normalize(), E.skyColor.copy(y.color).multiplyScalar(x), E.groundColor.copy(y.groundColor).multiplyScalar(x), t.hemi[g] = E, g++)
                }
                t.ambient[0] = l, t.ambient[1] = c, t.ambient[2] = u, t.directional.length = d, t.spot.length = f, t.rectArea.length = m, t.point.length = p, t.hemi.length = g, t.hash.stateID = t.id, t.hash.directionalLength = d, t.hash.pointLength = p, t.hash.spotLength = f, t.hash.rectAreaLength = m, t.hash.hemiLength = g, t.hash.shadowsLength = r.length
            },
            state: t
        }
    }

    function ht() {
        var e = new ut,
            t = [],
            i = [];
        return {
            init: function () {
                t.length = 0, i.length = 0
            },
            state: {
                lightsArray: t,
                shadowsArray: i,
                lights: e
            },
            setupLights: function (n) {
                e.setup(t, i, n)
            },
            pushLight: function (e) {
                t.push(e)
            },
            pushShadow: function (e) {
                i.push(e)
            }
        }
    }

    function dt() {
        function e(i) {
            (i = i.target).removeEventListener("dispose", e), delete t[i.id]
        }
        var t = {};
        return {
            get: function (i, n) {
                if (void 0 === t[i.id]) {
                    var r = new ht;
                    t[i.id] = {}, t[i.id][n.id] = r, i.addEventListener("dispose", e)
                } else void 0 === t[i.id][n.id] ? (r = new ht, t[i.id][n.id] = r) : r = t[i.id][n.id];
                return r
            },
            dispose: function () {
                t = {}
            }
        }
    }

    function pt(e) {
        V.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(e)
    }

    function ft(e) {
        V.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new r, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(e)
    }

    function mt(e, t, n) {
        function o(t, i, n, r, o, s) {
            var a = t.geometry,
                l = v,
                c = t.customDepthMaterial;
            return n && (l = y, c = t.customDistanceMaterial), c ? l = c : (c = !1, i.morphTargets && (a && a.isBufferGeometry ? c = a.morphAttributes && a.morphAttributes.position && 0 < a.morphAttributes.position.length : a && a.isGeometry && (c = a.morphTargets && 0 < a.morphTargets.length)), t.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t), a = 0, c && (a |= 1), (t = t.isSkinnedMesh && i.skinning) && (a |= 2), l = l[a]), e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (a = l.uuid, c = i.uuid, void 0 === (t = b[a]) && (t = {}, b[a] = t), void 0 === (a = t[c]) && (a = l.clone(), t[c] = a), l = a), l.visible = i.visible, l.wireframe = i.wireframe, l.side = null != i.shadowSide ? i.shadowSide : x[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, n && l.isMeshDistanceMaterial && (l.referencePosition.copy(r), l.nearDistance = o, l.farDistance = s), l
        }

        function s(i, n, r, a) {
            if (!1 !== i.visible) {
                if (i.layers.test(n.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || c.intersectsObject(i))) {
                    i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
                    var l = t.update(i),
                        u = i.material;
                    if (Array.isArray(u))
                        for (var h = l.groups, d = 0, p = h.length; d < p; d++) {
                            var m = h[d],
                                g = u[m.materialIndex];
                            g && g.visible && (g = o(i, g, a, f, r.near, r.far), e.renderBufferDirect(r, null, l, g, i, m))
                        } else u.visible && (g = o(i, u, a, f, r.near, r.far), e.renderBufferDirect(r, null, l, g, i, null))
                }
                for (l = 0, u = (i = i.children).length; l < u; l++) s(i[l], n, r, a)
            }
        }
        var c = new m,
            u = new g,
            h = new i,
            d = new i(n, n),
            p = new r,
            f = new r,
            v = Array(4),
            y = Array(4),
            b = {},
            x = {
                0: 1,
                1: 0,
                2: 2
            },
            w = [new r(1, 0, 0), new r(-1, 0, 0), new r(0, 0, 1), new r(0, 0, -1), new r(0, 1, 0), new r(0, -1, 0)],
            _ = [new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 0, 1), new r(0, 0, -1)],
            E = [new a, new a, new a, new a, new a, new a];
        for (n = 0; 4 !== n; ++n) {
            var M = 0 != (1 & n),
                S = 0 != (2 & n),
                T = new pt({
                    depthPacking: 3201,
                    morphTargets: M,
                    skinning: S
                });
            v[n] = T, M = new ft({
                morphTargets: M,
                skinning: S
            }), y[n] = M
        }
        var A = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (t, i, n) {
            if (!1 !== A.enabled && (!1 !== A.autoUpdate || !1 !== A.needsUpdate) && 0 !== t.length) {
                var r = e.getRenderTarget(),
                    o = e.getActiveCubeFace(),
                    a = e.getActiveMipMapLevel(),
                    m = e.state;
                m.setBlending(0), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(!0), m.setScissorTest(!1);
                for (var g, v = 0, y = t.length; v < y; v++) {
                    var b = t[v];
                    g = b.shadow;
                    var x = b && b.isPointLight;
                    if (void 0 === g) console.warn("THREE.WebGLShadowMap:", b, "has no shadow.");
                    else {
                        var M = g.camera;
                        if (h.copy(g.mapSize), h.min(d), x) {
                            var S = h.x,
                                T = h.y;
                            E[0].set(2 * S, T, S, T), E[1].set(0, T, S, T), E[2].set(3 * S, T, S, T), E[3].set(S, T, S, T), E[4].set(3 * S, 0, S, T), E[5].set(S, 0, S, T), h.x *= 4, h.y *= 2
                        }
                        for (null === g.map && (g.map = new l(h.x, h.y, {
                                minFilter: 1003,
                                magFilter: 1003,
                                format: 1023
                            }), g.map.texture.name = b.name + ".shadowMap", M.updateProjectionMatrix()), g.isSpotLightShadow && g.update(b), S = g.map, T = g.matrix, f.setFromMatrixPosition(b.matrixWorld), M.position.copy(f), x ? (g = 6, T.makeTranslation(-f.x, -f.y, -f.z)) : (g = 1, p.setFromMatrixPosition(b.target.matrixWorld), M.lookAt(p), M.updateMatrixWorld(), T.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), T.multiply(M.projectionMatrix), T.multiply(M.matrixWorldInverse)), e.setRenderTarget(S), e.clear(), b = 0; b < g; b++) x && (p.copy(M.position), p.add(w[b]), M.up.copy(_[b]), M.lookAt(p), M.updateMatrixWorld(), m.viewport(E[b])), u.multiplyMatrices(M.projectionMatrix, M.matrixWorldInverse), c.setFromMatrix(u), s(i, n, M, x)
                    }
                }
                A.needsUpdate = !1, e.setRenderTarget(r, o, a)
            }
        }
    }

    function gt(e, t, i, n) {
        function r(t, i, n) {
            var r = new Uint8Array(4),
                o = e.createTexture();
            for (e.bindTexture(t, o), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728), t = 0; t < n; t++) e.texImage2D(i + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return o
        }

        function o(i, r) {
            y[i] = 1, 0 === b[i] && (e.enableVertexAttribArray(i), b[i] = 1), x[i] !== r && ((n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), x[i] = r)
        }

        function s(t) {
            !0 !== w[t] && (e.enable(t), w[t] = !0)
        }

        function l(t) {
            !1 !== w[t] && (e.disable(t), w[t] = !1)
        }

        function c(t, n, r, o, a, c, u, h) {
            if (0 === t) M && (l(3042), M = !1);
            else if (M || (s(3042), M = !0), 5 !== t) {
                if (t !== S || h !== O) {
                    if (100 === T && 100 === L || (e.blendEquation(32774), L = T = 100), h) switch (t) {
                        case 1:
                            e.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(1, 1);
                            break;
                        case 3:
                            e.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            e.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    } else switch (t) {
                        case 1:
                            e.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(770, 1);
                            break;
                        case 3:
                            e.blendFunc(0, 769);
                            break;
                        case 4:
                            e.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    }
                    I = P = C = A = null, S = t, O = h
                }
            } else a = a || n, c = c || r, u = u || o, n === T && a === L || (e.blendEquationSeparate(i.convert(n), i.convert(a)), T = n, L = a), r === A && o === C && c === P && u === I || (e.blendFuncSeparate(i.convert(r), i.convert(o), i.convert(c), i.convert(u)), A = r, C = o, P = c, I = u), S = t, O = null
        }

        function u(t) {
            R !== t && (t ? e.frontFace(2304) : e.frontFace(2305), R = t)
        }

        function h(t) {
            0 !== t ? (s(2884), t !== D && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : l(2884), D = t
        }

        function d(t, i, n) {
            t ? (s(32823), (z !== i || B !== n) && (e.polygonOffset(i, n), z = i, B = n)) : l(32823)
        }

        function p(t) {
            void 0 === t && (t = 33984 + N - 1), H !== t && (e.activeTexture(t), H = t)
        }
        var f = new function () {
                var t = !1,
                    i = new a,
                    n = null,
                    r = new a(0, 0, 0, 0);
                return {
                    setMask: function (i) {
                        n === i || t || (e.colorMask(i, i, i, i), n = i)
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (t, n, o, s, a) {
                        !0 === a && (t *= s, n *= s, o *= s), i.set(t, n, o, s), !1 === r.equals(i) && (e.clearColor(t, n, o, s), r.copy(i))
                    },
                    reset: function () {
                        t = !1, n = null, r.set(-1, 0, 0, 0)
                    }
                }
            },
            m = new function () {
                var t = !1,
                    i = null,
                    n = null,
                    r = null;
                return {
                    setTest: function (e) {
                        e ? s(2929) : l(2929)
                    },
                    setMask: function (n) {
                        i === n || t || (e.depthMask(n), i = n)
                    },
                    setFunc: function (t) {
                        if (n !== t) {
                            if (t) switch (t) {
                                case 0:
                                    e.depthFunc(512);
                                    break;
                                case 1:
                                    e.depthFunc(519);
                                    break;
                                case 2:
                                    e.depthFunc(513);
                                    break;
                                case 3:
                                    e.depthFunc(515);
                                    break;
                                case 4:
                                    e.depthFunc(514);
                                    break;
                                case 5:
                                    e.depthFunc(518);
                                    break;
                                case 6:
                                    e.depthFunc(516);
                                    break;
                                case 7:
                                    e.depthFunc(517);
                                    break;
                                default:
                                    e.depthFunc(515)
                            } else e.depthFunc(515);
                            n = t
                        }
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (t) {
                        r !== t && (e.clearDepth(t), r = t)
                    },
                    reset: function () {
                        t = !1, r = n = i = null
                    }
                }
            },
            g = new function () {
                var t = !1,
                    i = null,
                    n = null,
                    r = null,
                    o = null,
                    a = null,
                    c = null,
                    u = null,
                    h = null;
                return {
                    setTest: function (e) {
                        e ? s(2960) : l(2960)
                    },
                    setMask: function (n) {
                        i === n || t || (e.stencilMask(n), i = n)
                    },
                    setFunc: function (t, i, s) {
                        n === t && r === i && o === s || (e.stencilFunc(t, i, s), n = t, r = i, o = s)
                    },
                    setOp: function (t, i, n) {
                        a === t && c === i && u === n || (e.stencilOp(t, i, n), a = t, c = i, u = n)
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (t) {
                        h !== t && (e.clearStencil(t), h = t)
                    },
                    reset: function () {
                        t = !1, h = u = c = a = o = r = n = i = null
                    }
                }
            },
            v = e.getParameter(34921),
            y = new Uint8Array(v),
            b = new Uint8Array(v),
            x = new Uint8Array(v),
            w = {},
            _ = null,
            E = null,
            M = null,
            S = null,
            T = null,
            A = null,
            C = null,
            L = null,
            P = null,
            I = null,
            O = !1,
            R = null,
            D = null,
            k = null,
            z = null,
            B = null,
            N = e.getParameter(35661),
            F = !1;
        v = 0, -1 !== (v = e.getParameter(7938)).indexOf("WebGL") ? (v = parseFloat(/^WebGL ([0-9])/.exec(v)[1]), F = 1 <= v) : -1 !== v.indexOf("OpenGL ES") && (v = parseFloat(/^OpenGL ES ([0-9])/.exec(v)[1]), F = 2 <= v);
        var H = null,
            U = {},
            j = new a,
            G = new a,
            V = {};
        return V[3553] = r(3553, 3553, 1), V[34067] = r(34067, 34069, 6), f.setClear(0, 0, 0, 1), m.setClear(1), g.setClear(0), s(2929), m.setFunc(3), u(!1), h(1), s(2884), c(0), {
            buffers: {
                color: f,
                depth: m,
                stencil: g
            },
            initAttributes: function () {
                for (var e = 0, t = y.length; e < t; e++) y[e] = 0
            },
            enableAttribute: function (e) {
                o(e, 0)
            },
            enableAttributeAndDivisor: o,
            disableUnusedAttributes: function () {
                for (var t = 0, i = b.length; t !== i; ++t) b[t] !== y[t] && (e.disableVertexAttribArray(t), b[t] = 0)
            },
            enable: s,
            disable: l,
            getCompressedTextureFormats: function () {
                if (null === _ && (_ = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
                    for (var i = e.getParameter(34467), n = 0; n < i.length; n++) _.push(i[n]);
                return _
            },
            useProgram: function (t) {
                return E !== t && (e.useProgram(t), E = t, !0)
            },
            setBlending: c,
            setMaterial: function (e, t) {
                2 === e.side ? l(2884) : s(2884);
                var i = 1 === e.side;
                t && (i = !i), u(i), 1 === e.blending && !1 === e.transparent ? c(0) : c(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), m.setFunc(e.depthFunc), m.setTest(e.depthTest), m.setMask(e.depthWrite), f.setMask(e.colorWrite), d(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            },
            setFlipSided: u,
            setCullFace: h,
            setLineWidth: function (t) {
                t !== k && (F && e.lineWidth(t), k = t)
            },
            setPolygonOffset: d,
            setScissorTest: function (e) {
                e ? s(3089) : l(3089)
            },
            activeTexture: p,
            bindTexture: function (t, i) {
                null === H && p();
                var n = U[H];
                void 0 === n && (n = {
                    type: void 0,
                    texture: void 0
                }, U[H] = n), n.type === t && n.texture === i || (e.bindTexture(t, i || V[t]), n.type = t, n.texture = i)
            },
            compressedTexImage2D: function () {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage2D: function () {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage3D: function () {
                try {
                    e.texImage3D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            scissor: function (t) {
                !1 === j.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), j.copy(t))
            },
            viewport: function (t) {
                !1 === G.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), G.copy(t))
            },
            reset: function () {
                for (var t = 0; t < b.length; t++) 1 === b[t] && (e.disableVertexAttribArray(t), b[t] = 0);
                w = {}, H = _ = null, U = {}, D = R = S = E = null, f.reset(), m.reset(), g.reset()
            }
        }
    }

    function vt(e, t, i, n, r, o, s) {
        function a(e, t) {
            return A ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }

        function l(e, t, i, n) {
            var r = 1;
            if ((e.width > n || e.height > n) && (r = n / Math.max(e.width, e.height)), 1 > r || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) return t = (n = t ? ho.floorPowerOfTwo : Math.floor)(r * e.width), r = n(r * e.height), void 0 === S && (S = a(t, r)), (i = i ? a(t, r) : S).width = t, i.height = r, i.getContext("2d").drawImage(e, 0, 0, t, r), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + t + "x" + r + ")."), i;
                "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ").")
            }
            return e
        }

        function c(e) {
            return ho.isPowerOfTwo(e.width) && ho.isPowerOfTwo(e.height)
        }

        function u(e, t) {
            return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter
        }

        function h(t, i, r, o) {
            e.generateMipmap(t), n.get(i).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
        }

        function d(e, i) {
            if (!r.isWebGL2) return e;
            var n = e;
            return 6403 === e && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 5121 === i && (n = 33321)), 6407 === e && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 5121 === i && (n = 32849)), 6408 === e && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 5121 === i && (n = 32856)), 33325 === n || 33326 === n || 34842 === n || 34836 === n ? t.get("EXT_color_buffer_float") : (34843 === n || 34837 === n) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n
        }

        function p(e) {
            return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729
        }

        function f(t) {
            (t = t.target).removeEventListener("dispose", f);
            var i = n.get(t);
            void 0 !== i.__webglInit && (e.deleteTexture(i.__webglTexture), n.remove(t)), t.isVideoTexture && delete T[t.id], s.memory.textures--
        }

        function m(t) {
            (t = t.target).removeEventListener("dispose", m);
            var i = n.get(t),
                r = n.get(t.texture);
            if (t) {
                if (void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
                    for (r = 0; 6 > r; r++) e.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[r]);
                else e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer);
                n.remove(t.texture), n.remove(t)
            }
            s.memory.textures--
        }

        function g(e, t) {
            var r = n.get(e);
            if (e.isVideoTexture) {
                var o = e.id,
                    a = s.render.frame;
                T[o] !== a && (T[o] = a, e.update())
            }
            if (0 < e.version && r.__version !== e.version)
                if (void 0 === (o = e.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== o.complete) return void w(r, e, t);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                } i.activeTexture(33984 + t), i.bindTexture(3553, r.__webglTexture)
        }

        function v(t, s) {
            var a = n.get(t);
            if (6 === t.image.length)
                if (0 < t.version && a.__version !== t.version) {
                    x(a, t), i.activeTexture(33984 + s), i.bindTexture(34067, a.__webglTexture), e.pixelStorei(37440, t.flipY), s = t && t.isCompressedTexture;
                    for (var p = t.image[0] && t.image[0].isDataTexture, f = [], m = 0; 6 > m; m++) f[m] = s || p ? p ? t.image[m].image : t.image[m] : l(t.image[m], !1, !0, r.maxCubemapSize);
                    var g = f[0],
                        v = c(g) || r.isWebGL2,
                        y = o.convert(t.format),
                        w = o.convert(t.type),
                        _ = d(y, w);
                    for (b(34067, t, v), m = 0; 6 > m; m++)
                        if (s)
                            for (var E, M = f[m].mipmaps, S = 0, T = M.length; S < T; S++) E = M[S], 1023 !== t.format && 1022 !== t.format ? -1 < i.getCompressedTextureFormats().indexOf(y) ? i.compressedTexImage2D(34069 + m, S, _, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + m, S, _, E.width, E.height, 0, y, w, E.data);
                        else p ? i.texImage2D(34069 + m, 0, _, f[m].width, f[m].height, 0, y, w, f[m].data) : i.texImage2D(34069 + m, 0, _, y, w, f[m]);
                    a.__maxMipLevel = s ? M.length - 1 : 0, u(t, v) && h(34067, t, g.width, g.height), a.__version = t.version, t.onUpdate && t.onUpdate(t)
                } else i.activeTexture(33984 + s), i.bindTexture(34067, a.__webglTexture)
        }

        function y(e, t) {
            i.activeTexture(33984 + t), i.bindTexture(34067, n.get(e).__webglTexture)
        }

        function b(i, s, a) {
            a ? (e.texParameteri(i, 10242, o.convert(s.wrapS)), e.texParameteri(i, 10243, o.convert(s.wrapT)), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, o.convert(s.wrapR)), e.texParameteri(i, 10240, o.convert(s.magFilter)), e.texParameteri(i, 10241, o.convert(s.minFilter))) : (e.texParameteri(i, 10242, 33071), e.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, 33071), 1001 === s.wrapS && 1001 === s.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(i, 10240, p(s.magFilter)), e.texParameteri(i, 10241, p(s.minFilter)), 1003 !== s.minFilter && 1006 !== s.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !(a = t.get("EXT_texture_filter_anisotropic")) || 1015 === s.type && null === t.get("OES_texture_float_linear") || 1016 === s.type && null === (r.isWebGL2 || t.get("OES_texture_half_float_linear")) || !(1 < s.anisotropy || n.get(s).__currentAnisotropy) || (e.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), n.get(s).__currentAnisotropy = s.anisotropy)
        }

        function x(t, i) {
            void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", f), t.__webglTexture = e.createTexture(), s.memory.textures++)
        }

        function w(t, n, s) {
            var a = 3553;
            n.isDataTexture2DArray && (a = 35866), n.isDataTexture3D && (a = 32879), x(t, n), i.activeTexture(33984 + s), i.bindTexture(a, t.__webglTexture), e.pixelStorei(37440, n.flipY), e.pixelStorei(37441, n.premultiplyAlpha), e.pixelStorei(3317, n.unpackAlignment), s = (s = !r.isWebGL2 && (1001 !== n.wrapS || 1001 !== n.wrapT || 1003 !== n.minFilter && 1006 !== n.minFilter)) && !1 === c(n.image);
            var p = c(s = l(n.image, s, !1, r.maxTextureSize)) || r.isWebGL2,
                f = o.convert(n.format),
                m = o.convert(n.type),
                g = d(f, m);
            b(a, n, p);
            var v = n.mipmaps;
            if (n.isDepthTexture) {
                if (g = 6402, 1015 === n.type) {
                    if (!r.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
                    g = 36012
                } else r.isWebGL2 && (g = 33189);
                1026 === n.format && 6402 === g && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, m = o.convert(n.type)), 1027 === n.format && (g = 34041, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, m = o.convert(n.type))), i.texImage2D(3553, 0, g, s.width, s.height, 0, f, m, null)
            } else if (n.isDataTexture)
                if (0 < v.length && p) {
                    for (var y = 0, w = v.length; y < w; y++) a = v[y], i.texImage2D(3553, y, g, a.width, a.height, 0, f, m, a.data);
                    n.generateMipmaps = !1, t.__maxMipLevel = v.length - 1
                } else i.texImage2D(3553, 0, g, s.width, s.height, 0, f, m, s.data), t.__maxMipLevel = 0;
            else if (n.isCompressedTexture) {
                for (y = 0, w = v.length; y < w; y++) a = v[y], 1023 !== n.format && 1022 !== n.format ? -1 < i.getCompressedTextureFormats().indexOf(f) ? i.compressedTexImage2D(3553, y, g, a.width, a.height, 0, a.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, y, g, a.width, a.height, 0, f, m, a.data);
                t.__maxMipLevel = v.length - 1
            } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, g, s.width, s.height, s.depth, 0, f, m, s.data), t.__maxMipLevel = 0;
            else if (n.isDataTexture3D) i.texImage3D(32879, 0, g, s.width, s.height, s.depth, 0, f, m, s.data), t.__maxMipLevel = 0;
            else if (0 < v.length && p) {
                for (y = 0, w = v.length; y < w; y++) a = v[y], i.texImage2D(3553, y, g, f, m, a);
                n.generateMipmaps = !1, t.__maxMipLevel = v.length - 1
            } else i.texImage2D(3553, 0, g, f, m, s), t.__maxMipLevel = 0;
            u(n, p) && h(3553, n, s.width, s.height), t.__version = n.version, n.onUpdate && n.onUpdate(n)
        }

        function _(t, r, s, a) {
            var l = o.convert(r.texture.format),
                c = o.convert(r.texture.type),
                u = d(l, c);
            i.texImage2D(a, 0, u, r.width, r.height, 0, l, c, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, s, a, n.get(r.texture).__webglTexture, 0), e.bindFramebuffer(36160, null)
        }

        function E(t, i, n) {
            if (e.bindRenderbuffer(36161, t), i.depthBuffer && !i.stencilBuffer) n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, 33189, i.width, i.height)) : e.renderbufferStorage(36161, 33189, i.width, i.height), e.framebufferRenderbuffer(36160, 36096, 36161, t);
            else if (i.depthBuffer && i.stencilBuffer) n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, 34041, i.width, i.height)) : e.renderbufferStorage(36161, 34041, i.width, i.height), e.framebufferRenderbuffer(36160, 33306, 36161, t);
            else {
                t = d(t = o.convert(i.texture.format), o.convert(i.texture.type)), n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, t, i.width, i.height)) : e.renderbufferStorage(36161, t, i.width, i.height)
            }
            e.bindRenderbuffer(36161, null)
        }

        function M(e) {
            return r.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, e.samples) : 0
        }
        var S, T = {},
            A = "undefined" != typeof OffscreenCanvas,
            C = 0,
            L = !1,
            P = !1;
        this.allocateTextureUnit = function () {
            var e = C;
            return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures), C += 1, e
        }, this.resetTextureUnits = function () {
            C = 0
        }, this.setTexture2D = g, this.setTexture2DArray = function (e, t) {
            var r = n.get(e);
            0 < e.version && r.__version !== e.version ? w(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(35866, r.__webglTexture))
        }, this.setTexture3D = function (e, t) {
            var r = n.get(e);
            0 < e.version && r.__version !== e.version ? w(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(32879, r.__webglTexture))
        }, this.setTextureCube = v, this.setTextureCubeDynamic = y, this.setupRenderTarget = function (t) {
            var a = n.get(t),
                l = n.get(t.texture);
            t.addEventListener("dispose", m), l.__webglTexture = e.createTexture(), s.memory.textures++;
            var p = !0 === t.isWebGLRenderTargetCube,
                f = !0 === t.isWebGLMultisampleRenderTarget,
                v = c(t) || r.isWebGL2;
            if (p)
                for (a.__webglFramebuffer = [], f = 0; 6 > f; f++) a.__webglFramebuffer[f] = e.createFramebuffer();
            else if (a.__webglFramebuffer = e.createFramebuffer(), f)
                if (r.isWebGL2) {
                    a.__webglMultisampledFramebuffer = e.createFramebuffer(), a.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, a.__webglColorRenderbuffer), f = o.convert(t.texture.format);
                    var y = o.convert(t.texture.type);
                    f = d(f, y), y = M(t), e.renderbufferStorageMultisample(36161, y, f, t.width, t.height), e.bindFramebuffer(36160, a.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, a.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (a.__webglDepthRenderbuffer = e.createRenderbuffer(), E(a.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (p) {
                for (i.bindTexture(34067, l.__webglTexture), b(34067, t.texture, v), f = 0; 6 > f; f++) _(a.__webglFramebuffer[f], t, 36064, 34069 + f);
                u(t.texture, v) && h(34067, t.texture, t.width, t.height), i.bindTexture(34067, null)
            } else i.bindTexture(3553, l.__webglTexture), b(3553, t.texture, v), _(a.__webglFramebuffer, t, 36064, 3553), u(t.texture, v) && h(3553, t.texture, t.width, t.height), i.bindTexture(3553, null);
            if (t.depthBuffer) {
                if (a = n.get(t), l = !0 === t.isWebGLRenderTargetCube, t.depthTexture) {
                    if (l) throw Error("target.depthTexture not supported in Cube render targets");
                    if (t && t.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
                    if (e.bindFramebuffer(36160, a.__webglFramebuffer), !t.depthTexture || !t.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    if (n.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), g(t.depthTexture, 0), a = n.get(t.depthTexture).__webglTexture, 1026 === t.depthTexture.format) e.framebufferTexture2D(36160, 36096, 3553, a, 0);
                    else {
                        if (1027 !== t.depthTexture.format) throw Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, a, 0)
                    }
                } else if (l)
                    for (a.__webglDepthbuffer = [], l = 0; 6 > l; l++) e.bindFramebuffer(36160, a.__webglFramebuffer[l]), a.__webglDepthbuffer[l] = e.createRenderbuffer(), E(a.__webglDepthbuffer[l], t);
                else e.bindFramebuffer(36160, a.__webglFramebuffer), a.__webglDepthbuffer = e.createRenderbuffer(), E(a.__webglDepthbuffer, t);
                e.bindFramebuffer(36160, null)
            }
        }, this.updateRenderTargetMipmap = function (e) {
            var t = e.texture,
                o = c(e) || r.isWebGL2;
            if (u(t, o)) {
                o = e.isWebGLRenderTargetCube ? 34067 : 3553;
                var s = n.get(t).__webglTexture;
                i.bindTexture(o, s), h(o, t, e.width, e.height), i.bindTexture(o, null)
            }
        }, this.updateMultisampleRenderTarget = function (t) {
            if (t.isWebGLMultisampleRenderTarget)
                if (r.isWebGL2) {
                    var i = n.get(t);
                    e.bindFramebuffer(36008, i.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, i.__webglFramebuffer), i = t.width;
                    var o = t.height,
                        s = 16384;
                    t.depthBuffer && (s |= 256), t.stencilBuffer && (s |= 1024), e.blitFramebuffer(0, 0, i, o, 0, 0, i, o, s, 9728)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }, this.safeSetTexture2D = function (e, t) {
            e && e.isWebGLRenderTarget && (!1 === L && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), L = !0), e = e.texture), g(e, t)
        }, this.safeSetTextureCube = function (e, t) {
            e && e.isWebGLRenderTargetCube && (!1 === P && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), P = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? v(e, t) : y(e, t)
        }
    }

    function yt(e, t, i) {
        return {
            convert: function (e) {
                if (1e3 === e) return 10497;
                if (1001 === e) return 33071;
                if (1002 === e) return 33648;
                if (1003 === e) return 9728;
                if (1004 === e) return 9984;
                if (1005 === e) return 9986;
                if (1006 === e) return 9729;
                if (1007 === e) return 9985;
                if (1008 === e) return 9987;
                if (1009 === e) return 5121;
                if (1017 === e) return 32819;
                if (1018 === e) return 32820;
                if (1019 === e) return 33635;
                if (1010 === e) return 5120;
                if (1011 === e) return 5122;
                if (1012 === e) return 5123;
                if (1013 === e) return 5124;
                if (1014 === e) return 5125;
                if (1015 === e) return 5126;
                if (1016 === e) {
                    if (i.isWebGL2) return 5131;
                    var n = t.get("OES_texture_half_float");
                    if (null !== n) return n.HALF_FLOAT_OES
                }
                if (1021 === e) return 6406;
                if (1022 === e) return 6407;
                if (1023 === e) return 6408;
                if (1024 === e) return 6409;
                if (1025 === e) return 6410;
                if (1026 === e) return 6402;
                if (1027 === e) return 34041;
                if (1028 === e) return 6403;
                if (100 === e) return 32774;
                if (101 === e) return 32778;
                if (102 === e) return 32779;
                if (200 === e) return 0;
                if (201 === e) return 1;
                if (202 === e) return 768;
                if (203 === e) return 769;
                if (204 === e) return 770;
                if (205 === e) return 771;
                if (206 === e) return 772;
                if (207 === e) return 773;
                if (208 === e) return 774;
                if (209 === e) return 775;
                if (210 === e) return 776;
                if ((33776 === e || 33777 === e || 33778 === e || 33779 === e) && null !== (n = t.get("WEBGL_compressed_texture_s3tc"))) {
                    if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((35840 === e || 35841 === e || 35842 === e || 35843 === e) && null !== (n = t.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === e && null !== (n = t.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
                if ((37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e) && null !== (n = t.get("WEBGL_compressed_texture_astc"))) return e;
                if (103 === e || 104 === e) {
                    if (i.isWebGL2) {
                        if (103 === e) return 32775;
                        if (104 === e) return 32776
                    }
                    if (null !== (n = t.get("EXT_blend_minmax"))) {
                        if (103 === e) return n.MIN_EXT;
                        if (104 === e) return n.MAX_EXT
                    }
                }
                if (1020 === e) {
                    if (i.isWebGL2) return 34042;
                    if (null !== (n = t.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }

    function bt() {
        S.call(this), this.type = "Group"
    }

    function xt() {
        S.call(this), this.type = "Camera", this.matrixWorldInverse = new g, this.projectionMatrix = new g, this.projectionMatrixInverse = new g
    }

    function wt(e, t, i, n) {
        xt.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    function _t(e) {
        wt.call(this), this.cameras = e || []
    }

    function Et(e, t, i) {
        No.setFromMatrixPosition(t.matrixWorld), Fo.setFromMatrixPosition(i.matrixWorld);
        var n = No.distanceTo(Fo),
            r = t.projectionMatrix.elements,
            o = i.projectionMatrix.elements,
            s = r[14] / (r[10] - 1);
        i = r[14] / (r[10] + 1);
        var a = (r[9] + 1) / r[5],
            l = (r[9] - 1) / r[5],
            c = (r[8] - 1) / r[0],
            u = (o[8] + 1) / o[0];
        r = s * c, o = s * u, c = (u = n / (-c + u)) * -c, t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(c), e.translateZ(u), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld), t = s + u, s = i + u, e.projectionMatrix.makePerspective(r - c, o + (n - c), a * i / s * t, l * i / s * t, t, s)
    }

    function Mt(e) {
        function t() {
            return null !== h && !0 === h.isPresenting
        }

        function o() {
            if (t()) {
                var i = h.getEyeParameters("left");
                l = 2 * i.renderWidth * y, c = i.renderHeight * y, A = e.getPixelRatio(), e.getSize(C), e.setDrawingBufferSize(l, c, 1), M.viewport.set(0, 0, l / 2, c), S.viewport.set(l / 2, 0, l / 2, c), P.start()
            } else u.enabled && e.setDrawingBufferSize(C.width, C.height, A), P.stop()
        }

        function s(e, t) {
            null !== t && 4 === t.length && e.set(t[0] * l, t[1] * c, t[2] * l, t[3] * c)
        }
        var l, c, u = this,
            h = null,
            d = null,
            p = null,
            f = [],
            m = new g,
            v = new g,
            y = 1,
            b = "local-floor";
        "undefined" != typeof window && "VRFrameData" in window && (d = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", o, !1));
        var w = new g,
            _ = new n,
            E = new r,
            M = new wt;
        M.viewport = new a, M.layers.enable(1);
        var S = new wt;
        S.viewport = new a, S.layers.enable(2);
        var T = new _t([M, S]);
        T.layers.enable(1), T.layers.enable(2);
        var A, C = new i,
            L = [];
        this.enabled = !1, this.getController = function (e) {
            var t = f[e];
            return void 0 === t && ((t = new bt).matrixAutoUpdate = !1, t.visible = !1, f[e] = t), t
        }, this.getDevice = function () {
            return h
        }, this.setDevice = function (e) {
            void 0 !== e && (h = e), P.setContext(e)
        }, this.setFramebufferScaleFactor = function (e) {
            y = e
        }, this.setReferenceSpaceType = function (e) {
            b = e
        }, this.setPoseTarget = function (e) {
            void 0 !== e && (p = e)
        }, this.getCamera = function (e) {
            var i = "local-floor" === b ? 1.6 : 0;
            if (!1 === t()) return e.position.set(0, i, 0), e.rotation.set(0, 0, 0), e;
            if (h.depthNear = e.near, h.depthFar = e.far, h.getFrameData(d), "local-floor" === b) {
                var n = h.stageParameters;
                n ? m.fromArray(n.sittingToStandingTransform) : m.makeTranslation(0, i, 0)
            }
            i = d.pose, (n = null !== p ? p : e).matrix.copy(m), n.matrix.decompose(n.position, n.quaternion, n.scale), null !== i.orientation && (_.fromArray(i.orientation), n.quaternion.multiply(_)), null !== i.position && (_.setFromRotationMatrix(m), E.fromArray(i.position), E.applyQuaternion(_), n.position.add(E)), n.updateMatrixWorld(), M.near = e.near, S.near = e.near, M.far = e.far, S.far = e.far, M.matrixWorldInverse.fromArray(d.leftViewMatrix), S.matrixWorldInverse.fromArray(d.rightViewMatrix), v.getInverse(m), "local-floor" === b && (M.matrixWorldInverse.multiply(v), S.matrixWorldInverse.multiply(v)), null !== (e = n.parent) && (w.getInverse(e.matrixWorld), M.matrixWorldInverse.multiply(w), S.matrixWorldInverse.multiply(w)), M.matrixWorld.getInverse(M.matrixWorldInverse), S.matrixWorld.getInverse(S.matrixWorldInverse), M.projectionMatrix.fromArray(d.leftProjectionMatrix), S.projectionMatrix.fromArray(d.rightProjectionMatrix), Et(T, M, S), (e = h.getLayers()).length && (e = e[0], s(M.viewport, e.leftBounds), s(S.viewport, e.rightBounds));
            e: for (e = 0; e < f.length; e++) {
                i = f[e];
                t: {
                    n = e;
                    for (var r = navigator.getGamepads && navigator.getGamepads(), o = 0, a = 0, l = r.length; o < l; o++) {
                        var c = r[o];
                        if (c && ("Daydream Controller" === c.id || "Gear VR Controller" === c.id || "Oculus Go Controller" === c.id || "OpenVR Gamepad" === c.id || c.id.startsWith("Oculus Touch") || c.id.startsWith("Spatial Controller"))) {
                            if (a === n) {
                                n = c;
                                break t
                            }
                            a++
                        }
                    }
                    n = void 0
                }
                if (void 0 !== n && void 0 !== n.pose) {
                    if (null === n.pose) break e;
                    !1 === (r = n.pose).hasPosition && i.position.set(.2, -.6, -.05), null !== r.position && i.position.fromArray(r.position), null !== r.orientation && i.quaternion.fromArray(r.orientation), i.matrix.compose(i.position, i.quaternion, i.scale), i.matrix.premultiply(m), i.matrix.decompose(i.position, i.quaternion, i.scale), i.matrixWorldNeedsUpdate = !0, i.visible = !0, r = "Daydream Controller" === n.id ? 0 : 1, void 0 === L[e] && (L[e] = !1), L[e] !== n.buttons[r].pressed && (L[e] = n.buttons[r].pressed, !0 === L[e] ? i.dispatchEvent({
                        type: "selectstart"
                    }) : (i.dispatchEvent({
                        type: "selectend"
                    }), i.dispatchEvent({
                        type: "select"
                    })))
                } else i.visible = !1
            }
            return T
        }, this.getStandingMatrix = function () {
            return m
        }, this.isPresenting = t;
        var P = new x;
        this.setAnimationLoop = function (e) {
            P.setAnimationLoop(e), t() && P.start()
        }, this.submitFrame = function () {
            t() && h.submitFrame()
        }, this.dispose = function () {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", o)
        }, this.setFrameOfReferenceType = function () {
            console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
        }
    }

    function St(e) {
        function t() {
            return null !== l && null !== c
        }

        function i(e) {
            for (var t = 0; t < d.length; t++) p[t] === e.inputSource && d[t].dispatchEvent({
                type: e.type
            })
        }

        function n() {
            e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), b.stop()
        }

        function r(e) {
            c = e, b.setContext(l), b.start()
        }

        function o(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld)
        }
        var s = e.context,
            l = null,
            c = null,
            u = "local-floor",
            h = null,
            d = [],
            p = [],
            f = new wt;
        f.layers.enable(1), f.viewport = new a;
        var m = new wt;
        m.layers.enable(2), m.viewport = new a;
        var v = new _t([f, m]);
        v.layers.enable(1), v.layers.enable(2), this.enabled = !1, this.getController = function (e) {
            var t = d[e];
            return void 0 === t && ((t = new bt).matrixAutoUpdate = !1, t.visible = !1, d[e] = t), t
        }, this.setFramebufferScaleFactor = function (e) {}, this.setReferenceSpaceType = function (e) {
            u = e
        }, this.setSession = function (e) {
            null !== (l = e) && (l.addEventListener("select", i), l.addEventListener("selectstart", i), l.addEventListener("selectend", i), l.addEventListener("end", n), l.updateRenderState({
                baseLayer: new XRWebGLLayer(l, s)
            }), l.requestReferenceSpace(u).then(r), p = l.inputSources, l.addEventListener("inputsourceschange", (function () {
                p = l.inputSources, console.log(p);
                for (var e = 0; e < d.length; e++) d[e].userData.inputSource = p[e]
            })))
        }, this.getCamera = function (e) {
            if (t()) {
                var i = e.parent,
                    n = v.cameras;
                o(v, i);
                for (var r = 0; r < n.length; r++) o(n[r], i);
                for (e.matrixWorld.copy(v.matrixWorld), r = 0, i = (e = e.children).length; r < i; r++) e[r].updateMatrixWorld(!0);
                return Et(v, f, m), v
            }
            return e
        }, this.isPresenting = t;
        var y = null,
            b = new x;
        b.setAnimationLoop((function (t, i) {
            if (null !== (h = i.getViewerPose(c))) {
                var n = h.views,
                    r = l.renderState.baseLayer;
                e.setFramebuffer(r.framebuffer);
                for (var o = 0; o < n.length; o++) {
                    var s = n[o],
                        a = r.getViewport(s),
                        u = v.cameras[o];
                    u.matrix.fromArray(s.transform.inverse.matrix).getInverse(u.matrix), u.projectionMatrix.fromArray(s.projectionMatrix), u.viewport.set(a.x, a.y, a.width, a.height), 0 === o && v.matrix.copy(u.matrix)
                }
            }
            for (o = 0; o < d.length; o++) n = d[o], (r = p[o]) && null !== (r = i.getPose(r.targetRaySpace, c)) ? (n.matrix.fromArray(r.transform.matrix), n.matrix.decompose(n.position, n.rotation, n.scale), n.visible = !0) : n.visible = !1;
            y && y(t)
        })), this.setAnimationLoop = function (e) {
            y = e
        }, this.dispose = function () {}, this.getStandingMatrix = function () {
            return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new g
        }, this.getDevice = function () {
            console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
        }, this.setDevice = function () {
            console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
        }, this.setFrameOfReferenceType = function () {
            console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
        }, this.submitFrame = function () {}
    }

    function Tt(e) {
        var t;

        function n() {
            k = new ee(ke), (z = new K(ke, k, e)).isWebGL2 || (k.get("WEBGL_depth_texture"), k.get("OES_texture_float"), k.get("OES_texture_half_float"), k.get("OES_texture_half_float_linear"), k.get("OES_standard_derivatives"), k.get("OES_element_index_uint"), k.get("ANGLE_instanced_arrays")), k.get("OES_texture_float_linear"), ae = new yt(ke, k, z), (B = new gt(ke, k, ae, z)).scissor(we.copy(Ae).multiplyScalar(Se)), B.viewport(xe.copy(Te).multiplyScalar(Se)), N = new ne(ke), F = new rt, H = new vt(ke, k, B, F, z, ae, N), U = new w(ke), j = new te(ke, U, N), G = new se(j, N), Y = new oe(ke), V = new nt(le, k, z, H), W = new lt, q = new dt, X = new Q(le, B, G, L), Z = new J(ke, k, N, z), re = new ie(ke, k, N, z), N.programs = V.programs, le.context = ke, le.capabilities = z, le.extensions = k, le.properties = F, le.renderLists = W, le.state = B, le.info = N
        }

        function o(e) {
            e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), ce = !0
        }

        function s() {
            console.log("THREE.WebGLRenderer: Context Restored."), ce = !1, n()
        }

        function l(e) {
            (e = e.target).removeEventListener("dispose", l), c(e), F.remove(e)
        }

        function c(e) {
            var t = F.get(e).program;
            e.program = void 0, void 0 !== t && V.releaseProgram(t)
        }

        function u(e, t, i, n) {
            for (var r = 0, o = e.length; r < o; r++) {
                var s = e[r],
                    a = s.object,
                    l = s.geometry,
                    c = void 0 === n ? s.material : n;
                if (s = s.group, i.isArrayCamera) {
                    be = i;
                    for (var u = i.cameras, h = 0, p = u.length; h < p; h++) {
                        var f = u[h];
                        a.layers.test(f.layers) && (B.viewport(xe.copy(f.viewport)), D.setupLights(f), d(a, t, f, l, c, s))
                    }
                } else be = null, d(a, t, i, l, c, s)
            }
        }

        function d(e, i, n, r, o, s) {
            if (e.onBeforeRender(le, i, n, r, o, s), D = q.get(i, be || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                B.setMaterial(o);
                var a = f(n, i.fog, o, e);
                ge = t = null, ve = !1,
                    function (e, t) {
                        e.render((function (e) {
                            le.renderBufferImmediate(e, t)
                        }))
                    }(e, a)
            } else le.renderBufferDirect(n, i.fog, r, o, e, s);
            e.onAfterRender(le, i, n, r, o, s), D = q.get(i, be || n)
        }

        function p(e, t, i) {
            var n = F.get(e),
                r = D.state.lights,
                o = n.lightsHash,
                s = r.state.hash;
            i = V.getParameters(e, r.state, D.state.shadowsArray, t, Pe.numPlanes, Pe.numIntersection, i);
            var a = V.getProgramCode(e, i),
                u = n.program,
                h = !0;
            if (void 0 === u) e.addEventListener("dispose", l);
            else if (u.code !== a) c(e);
            else {
                if (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o.rectAreaLength !== s.rectAreaLength || o.hemiLength !== s.hemiLength || o.shadowsLength !== s.shadowsLength) o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength;
                else if (void 0 !== i.shaderID) return;
                h = !1
            }
            if (h && (i.shaderID ? (a = xo[i.shaderID], n.shader = {
                    name: e.type,
                    uniforms: v(a.uniforms),
                    vertexShader: a.vertexShader,
                    fragmentShader: a.fragmentShader
                }) : n.shader = {
                    name: e.type,
                    uniforms: e.uniforms,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader
                }, e.onBeforeCompile(n.shader, le), a = V.getProgramCode(e, i), u = V.acquireProgram(e, n.shader, i, a), n.program = u, e.program = u), i = u.getAttributes(), e.morphTargets)
                for (a = e.numSupportedMorphTargets = 0; a < le.maxMorphTargets; a++) 0 <= i["morphTarget" + a] && e.numSupportedMorphTargets++;
            if (e.morphNormals)
                for (a = e.numSupportedMorphNormals = 0; a < le.maxMorphNormals; a++) 0 <= i["morphNormal" + a] && e.numSupportedMorphNormals++;
            i = n.shader.uniforms, (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (n.numClippingPlanes = Pe.numPlanes, n.numIntersection = Pe.numIntersection, i.clippingPlanes = Pe.uniform), n.fog = t, void 0 === o && (n.lightsHash = o = {}), o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, e.lights && (i.ambientLightColor.value = r.state.ambient, i.lightProbe.value = r.state.probe, i.directionalLights.value = r.state.directional, i.spotLights.value = r.state.spot, i.rectAreaLights.value = r.state.rectArea, i.pointLights.value = r.state.point, i.hemisphereLights.value = r.state.hemi, i.directionalShadowMap.value = r.state.directionalShadowMap, i.directionalShadowMatrix.value = r.state.directionalShadowMatrix, i.spotShadowMap.value = r.state.spotShadowMap, i.spotShadowMatrix.value = r.state.spotShadowMatrix, i.pointShadowMap.value = r.state.pointShadowMap, i.pointShadowMatrix.value = r.state.pointShadowMatrix), e = n.program.getUniforms(), e = We.seqWithValue(e.seq, i), n.uniformsList = e
        }

        function f(e, t, i, n) {
            H.resetTextureUnits();
            var r = F.get(i),
                o = r.lightsHash,
                s = D.state.lights.state.hash;
            Ie && (Oe || e !== ye) && Pe.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, e, r, e === ye && i.id === me), !1 === i.needsUpdate && (void 0 === r.program || i.fog && r.fog !== t ? i.needsUpdate = !0 : (!i.lights || o.stateID === s.stateID && o.directionalLength === s.directionalLength && o.pointLength === s.pointLength && o.spotLength === s.spotLength && o.rectAreaLength === s.rectAreaLength && o.hemiLength === s.hemiLength && o.shadowsLength === s.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === Pe.numPlanes && r.numIntersection === Pe.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (p(i, t, n), i.needsUpdate = !1);
            var a = !1,
                l = !1,
                c = !1;
            s = (o = r.program).getUniforms();
            var u = r.shader.uniforms;
            if (B.useProgram(o.program) && (c = l = a = !0), i.id !== me && (me = i.id, l = !0), (a || ye !== e) && (s.setValue(ke, "projectionMatrix", e.projectionMatrix), z.logarithmicDepthBuffer && s.setValue(ke, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), ye !== e && (ye = e, c = l = !0), (i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) && (void 0 !== (a = s.map.cameraPosition) && a.setValue(ke, De.setFromMatrixPosition(e.matrixWorld))), (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && s.setValue(ke, "viewMatrix", e.matrixWorldInverse)), i.skinning && (s.setOptional(ke, n, "bindMatrix"), s.setOptional(ke, n, "bindMatrixInverse"), e = n.skeleton))
                if (a = e.bones, z.floatVertexTextures) {
                    if (void 0 === e.boneTexture) {
                        a = Math.sqrt(4 * a.length), a = ho.ceilPowerOfTwo(a), a = Math.max(a, 4);
                        var d = new Float32Array(a * a * 4);
                        d.set(e.boneMatrices);
                        var f = new h(d, a, a, 1023, 1015);
                        f.needsUpdate = !0, e.boneMatrices = d, e.boneTexture = f, e.boneTextureSize = a
                    }
                    s.setValue(ke, "boneTexture", e.boneTexture, H), s.setValue(ke, "boneTextureSize", e.boneTextureSize)
                } else s.setOptional(ke, e, "boneMatrices");
            return l && (s.setValue(ke, "toneMappingExposure", le.toneMappingExposure), s.setValue(ke, "toneMappingWhitePoint", le.toneMappingWhitePoint), i.lights && (l = c, u.ambientLightColor.needsUpdate = l, u.lightProbe.needsUpdate = l, u.directionalLights.needsUpdate = l, u.pointLights.needsUpdate = l, u.spotLights.needsUpdate = l, u.rectAreaLights.needsUpdate = l, u.hemisphereLights.needsUpdate = l), t && i.fog && (u.fogColor.value.copy(t.color), t.isFog ? (u.fogNear.value = t.near, u.fogFar.value = t.far) : t.isFogExp2 && (u.fogDensity.value = t.density)), i.isMeshBasicMaterial ? y(u, i) : i.isMeshLambertMaterial ? (y(u, i), i.emissiveMap && (u.emissiveMap.value = i.emissiveMap)) : i.isMeshPhongMaterial ? (y(u, i), i.isMeshToonMaterial ? (b(u, i), i.gradientMap && (u.gradientMap.value = i.gradientMap)) : b(u, i)) : i.isMeshStandardMaterial ? (y(u, i), i.isMeshPhysicalMaterial ? (_(u, i), u.reflectivity.value = i.reflectivity, u.clearCoat.value = i.clearCoat, u.clearCoatRoughness.value = i.clearCoatRoughness) : _(u, i)) : i.isMeshMatcapMaterial ? (y(u, i), i.matcap && (u.matcap.value = i.matcap), i.bumpMap && (u.bumpMap.value = i.bumpMap, u.bumpScale.value = i.bumpScale, 1 === i.side && (u.bumpScale.value *= -1)), i.normalMap && (u.normalMap.value = i.normalMap, u.normalScale.value.copy(i.normalScale), 1 === i.side && u.normalScale.value.negate()), i.displacementMap && (u.displacementMap.value = i.displacementMap, u.displacementScale.value = i.displacementScale, u.displacementBias.value = i.displacementBias)) : i.isMeshDepthMaterial ? (y(u, i), i.displacementMap && (u.displacementMap.value = i.displacementMap, u.displacementScale.value = i.displacementScale, u.displacementBias.value = i.displacementBias)) : i.isMeshDistanceMaterial ? (y(u, i), i.displacementMap && (u.displacementMap.value = i.displacementMap, u.displacementScale.value = i.displacementScale, u.displacementBias.value = i.displacementBias), u.referencePosition.value.copy(i.referencePosition), u.nearDistance.value = i.nearDistance, u.farDistance.value = i.farDistance) : i.isMeshNormalMaterial ? (y(u, i), i.bumpMap && (u.bumpMap.value = i.bumpMap, u.bumpScale.value = i.bumpScale, 1 === i.side && (u.bumpScale.value *= -1)), i.normalMap && (u.normalMap.value = i.normalMap, u.normalScale.value.copy(i.normalScale), 1 === i.side && u.normalScale.value.negate()), i.displacementMap && (u.displacementMap.value = i.displacementMap, u.displacementScale.value = i.displacementScale, u.displacementBias.value = i.displacementBias)) : i.isLineBasicMaterial ? (u.diffuse.value.copy(i.color), u.opacity.value = i.opacity, i.isLineDashedMaterial && (u.dashSize.value = i.dashSize, u.totalSize.value = i.dashSize + i.gapSize, u.scale.value = i.scale)) : i.isPointsMaterial ? (u.diffuse.value.copy(i.color), u.opacity.value = i.opacity, u.size.value = i.size * Se, u.scale.value = .5 * Me, u.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), u.uvTransform.value.copy(i.map.matrix))) : i.isSpriteMaterial ? (u.diffuse.value.copy(i.color), u.opacity.value = i.opacity, u.rotation.value = i.rotation, u.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), u.uvTransform.value.copy(i.map.matrix))) : i.isShadowMaterial && (u.color.value.copy(i.color), u.opacity.value = i.opacity), void 0 !== u.ltc_1 && (u.ltc_1.value = bo.LTC_1), void 0 !== u.ltc_2 && (u.ltc_2.value = bo.LTC_2), We.upload(ke, r.uniformsList, u, H)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (We.upload(ke, r.uniformsList, u, H), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && s.setValue(ke, "center", n.center), s.setValue(ke, "modelViewMatrix", n.modelViewMatrix), s.setValue(ke, "normalMatrix", n.normalMatrix), s.setValue(ke, "modelMatrix", n.matrixWorld), o
        }

        function y(e, t) {
            if (e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = F.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map) var i = t.map;
            else t.specularMap ? i = t.specularMap : t.displacementMap ? i = t.displacementMap : t.normalMap ? i = t.normalMap : t.bumpMap ? i = t.bumpMap : t.roughnessMap ? i = t.roughnessMap : t.metalnessMap ? i = t.metalnessMap : t.alphaMap ? i = t.alphaMap : t.emissiveMap && (i = t.emissiveMap);
            void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix))
        }

        function b(e, t) {
            e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
        }

        function _(e, t) {
            e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }
        console.log("THREE.WebGLRenderer", "105");
        var E = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            M = void 0 !== e.context ? e.context : null,
            S = void 0 !== e.alpha && e.alpha,
            T = void 0 === e.depth || e.depth,
            A = void 0 === e.stencil || e.stencil,
            C = void 0 !== e.antialias && e.antialias,
            L = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            P = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            I = void 0 !== e.powerPreference ? e.powerPreference : "default",
            O = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
            R = null,
            D = null;
        this.domElement = E, this.context = null, this.debug = {
            checkShaderErrors: !0
        }, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var k, z, B, N, F, H, U, j, G, V, W, q, X, Y, Z, re, ae, le = this,
            ce = !1,
            ue = null,
            he = 0,
            de = 0,
            pe = null,
            fe = null,
            me = -1,
            ge = t = null,
            ve = !1,
            ye = null,
            be = null,
            xe = new a,
            we = new a,
            _e = null,
            Ee = E.width,
            Me = E.height,
            Se = 1,
            Te = new a(0, 0, Ee, Me),
            Ae = new a(0, 0, Ee, Me),
            Ce = !1,
            Le = new m,
            Pe = new $,
            Ie = !1,
            Oe = !1,
            Re = new g,
            De = new r;
        try {
            S = {
                alpha: S,
                depth: T,
                stencil: A,
                antialias: C,
                premultipliedAlpha: L,
                preserveDrawingBuffer: P,
                powerPreference: I,
                failIfMajorPerformanceCaveat: O,
                xrCompatible: !0
            }, E.addEventListener("webglcontextlost", o, !1), E.addEventListener("webglcontextrestored", s, !1);
            var ke = M || E.getContext("webgl", S) || E.getContext("experimental-webgl", S);
            if (null === ke) {
                if (null !== E.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
                throw Error("Error creating WebGL context.")
            }
            void 0 === ke.getShaderPrecisionFormat && (ke.getShaderPrecisionFormat = function () {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (e) {
            throw console.error("THREE.WebGLRenderer: " + e.message), e
        }
        n();
        var ze = "undefined" != typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new St(le) : new Mt(le);
        this.vr = ze;
        var Be = new mt(le, G, z.maxTextureSize);
        this.shadowMap = Be, this.getContext = function () {
            return ke
        }, this.getContextAttributes = function () {
            return ke.getContextAttributes()
        }, this.forceContextLoss = function () {
            var e = k.get("WEBGL_lose_context");
            e && e.loseContext()
        }, this.forceContextRestore = function () {
            var e = k.get("WEBGL_lose_context");
            e && e.restoreContext()
        }, this.getPixelRatio = function () {
            return Se
        }, this.setPixelRatio = function (e) {
            void 0 !== e && (Se = e, this.setSize(Ee, Me, !1))
        }, this.getSize = function (e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new i), e.set(Ee, Me)
        }, this.setSize = function (e, t, i) {
            ze.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Ee = e, Me = t, E.width = e * Se, E.height = t * Se, !1 !== i && (E.style.width = e + "px", E.style.height = t + "px"), this.setViewport(0, 0, e, t))
        }, this.getDrawingBufferSize = function (e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new i), e.set(Ee * Se, Me * Se)
        }, this.setDrawingBufferSize = function (e, t, i) {
            Ee = e, Me = t, Se = i, E.width = e * i, E.height = t * i, this.setViewport(0, 0, e, t)
        }, this.getCurrentViewport = function (e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new a), e.copy(xe)
        }, this.getViewport = function (e) {
            return e.copy(Te)
        }, this.setViewport = function (e, t, i, n) {
            e.isVector4 ? Te.set(e.x, e.y, e.z, e.w) : Te.set(e, t, i, n), B.viewport(xe.copy(Te).multiplyScalar(Se))
        }, this.getScissor = function (e) {
            return e.copy(Ae)
        }, this.setScissor = function (e, t, i, n) {
            e.isVector4 ? Ae.set(e.x, e.y, e.z, e.w) : Ae.set(e, t, i, n), B.scissor(we.copy(Ae).multiplyScalar(Se))
        }, this.getScissorTest = function () {
            return Ce
        }, this.setScissorTest = function (e) {
            B.setScissorTest(Ce = e)
        }, this.getClearColor = function () {
            return X.getClearColor()
        }, this.setClearColor = function () {
            X.setClearColor.apply(X, arguments)
        }, this.getClearAlpha = function () {
            return X.getClearAlpha()
        }, this.setClearAlpha = function () {
            X.setClearAlpha.apply(X, arguments)
        }, this.clear = function (e, t, i) {
            var n = 0;
            (void 0 === e || e) && (n |= 16384), (void 0 === t || t) && (n |= 256), (void 0 === i || i) && (n |= 1024), ke.clear(n)
        }, this.clearColor = function () {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function () {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function () {
            this.clear(!1, !1, !0)
        }, this.dispose = function () {
            E.removeEventListener("webglcontextlost", o, !1), E.removeEventListener("webglcontextrestored", s, !1), W.dispose(), q.dispose(), F.dispose(), G.dispose(), ze.dispose(), Fe.stop()
        }, this.renderBufferImmediate = function (e, t) {
            B.initAttributes();
            var i = F.get(e);
            e.hasPositions && !i.position && (i.position = ke.createBuffer()), e.hasNormals && !i.normal && (i.normal = ke.createBuffer()), e.hasUvs && !i.uv && (i.uv = ke.createBuffer()), e.hasColors && !i.color && (i.color = ke.createBuffer()), t = t.getAttributes(), e.hasPositions && (ke.bindBuffer(34962, i.position), ke.bufferData(34962, e.positionArray, 35048), B.enableAttribute(t.position), ke.vertexAttribPointer(t.position, 3, 5126, !1, 0, 0)), e.hasNormals && (ke.bindBuffer(34962, i.normal), ke.bufferData(34962, e.normalArray, 35048), B.enableAttribute(t.normal), ke.vertexAttribPointer(t.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (ke.bindBuffer(34962, i.uv), ke.bufferData(34962, e.uvArray, 35048), B.enableAttribute(t.uv), ke.vertexAttribPointer(t.uv, 2, 5126, !1, 0, 0)), e.hasColors && (ke.bindBuffer(34962, i.color), ke.bufferData(34962, e.colorArray, 35048), B.enableAttribute(t.color), ke.vertexAttribPointer(t.color, 3, 5126, !1, 0, 0)), B.disableUnusedAttributes(), ke.drawArrays(4, 0, e.count), e.count = 0
        }, this.renderBufferDirect = function (e, i, n, r, o, s) {
            var a = o.isMesh && 0 > o.matrixWorld.determinant();
            B.setMaterial(r, a);
            var l = f(e, i, r, o),
                c = !1;
            t === n.id && ge === l.id && ve === (!0 === r.wireframe) || (t = n.id, ge = l.id, ve = !0 === r.wireframe, c = !0), o.morphTargetInfluences && (Y.update(o, n, r, l), c = !0), a = n.index;
            var u = n.attributes.position;
            if (i = 1, !0 === r.wireframe && (a = j.getWireframeAttribute(n), i = 2), e = Z, null !== a) {
                var h = U.get(a);
                (e = re).setIndex(h)
            }
            if (c) {
                if (n && n.isInstancedBufferGeometry && !z.isWebGL2 && null === k.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    B.initAttributes(), c = n.attributes, l = l.getAttributes();
                    var d = r.defaultAttributeValues;
                    for (E in l) {
                        var p = l[E];
                        if (0 <= p) {
                            var m = c[E];
                            if (void 0 !== m) {
                                var g = m.normalized,
                                    v = m.itemSize,
                                    y = U.get(m);
                                if (void 0 !== y) {
                                    var b = y.buffer,
                                        x = y.type;
                                    if (y = y.bytesPerElement, m.isInterleavedBufferAttribute) {
                                        var w = m.data,
                                            _ = w.stride;
                                        m = m.offset, w && w.isInstancedInterleavedBuffer ? (B.enableAttributeAndDivisor(p, w.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = w.meshPerAttribute * w.count)) : B.enableAttribute(p), ke.bindBuffer(34962, b), ke.vertexAttribPointer(p, v, x, g, _ * y, m * y)
                                    } else m.isInstancedBufferAttribute ? (B.enableAttributeAndDivisor(p, m.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = m.meshPerAttribute * m.count)) : B.enableAttribute(p), ke.bindBuffer(34962, b), ke.vertexAttribPointer(p, v, x, g, 0, 0)
                                }
                            } else if (void 0 !== d && void 0 !== (g = d[E])) switch (g.length) {
                                case 2:
                                    ke.vertexAttrib2fv(p, g);
                                    break;
                                case 3:
                                    ke.vertexAttrib3fv(p, g);
                                    break;
                                case 4:
                                    ke.vertexAttrib4fv(p, g);
                                    break;
                                default:
                                    ke.vertexAttrib1fv(p, g)
                            }
                        }
                    }
                    B.disableUnusedAttributes()
                }
                null !== a && ke.bindBuffer(34963, h.buffer)
            }
            h = 1 / 0, null !== a ? h = a.count : void 0 !== u && (h = u.count), a = n.drawRange.start * i, u = null !== s ? s.start * i : 0;
            var E = Math.max(a, u);
            if (0 !== (s = Math.max(0, Math.min(h, a + n.drawRange.count * i, u + (null !== s ? s.count * i : 1 / 0)) - 1 - E + 1))) {
                if (o.isMesh)
                    if (!0 === r.wireframe) B.setLineWidth(r.wireframeLinewidth * (null === pe ? Se : 1)), e.setMode(1);
                    else switch (o.drawMode) {
                        case 0:
                            e.setMode(4);
                            break;
                        case 1:
                            e.setMode(5);
                            break;
                        case 2:
                            e.setMode(6)
                    } else o.isLine ? (void 0 === (r = r.linewidth) && (r = 1), B.setLineWidth(r * (null === pe ? Se : 1)), o.isLineSegments ? e.setMode(1) : o.isLineLoop ? e.setMode(2) : e.setMode(3)) : o.isPoints ? e.setMode(0) : o.isSprite && e.setMode(4);
                n && n.isInstancedBufferGeometry ? 0 < n.maxInstancedCount && e.renderInstances(n, E, s) : e.render(E, s)
            }
        }, this.compile = function (e, t) {
            (D = q.get(e, t)).init(), e.traverse((function (e) {
                e.isLight && (D.pushLight(e), e.castShadow && D.pushShadow(e))
            })), D.setupLights(t), e.traverse((function (t) {
                if (t.material)
                    if (Array.isArray(t.material))
                        for (var i = 0; i < t.material.length; i++) p(t.material[i], e.fog, t);
                    else p(t.material, e.fog, t)
            }))
        };
        var Ne = null,
            Fe = new x;
        Fe.setAnimationLoop((function (e) {
            ze.isPresenting() || Ne && Ne(e)
        })), "undefined" != typeof window && Fe.setContext(window), this.setAnimationLoop = function (e) {
            Ne = e, ze.setAnimationLoop(e), Fe.start()
        }, this.render = function (e, i, n, r) {
            if (void 0 !== n) {
                console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
                var o = n
            }
            if (void 0 !== r) {
                console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
                var s = r
            }
            i && i.isCamera ? ce || (ge = t = null, ve = !1, me = -1, ye = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === i.parent && i.updateMatrixWorld(), ze.enabled && (i = ze.getCamera(i)), (D = q.get(e, i)).init(), e.onBeforeRender(le, e, i, o || pe), Re.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), Le.setFromMatrix(Re), Oe = this.localClippingEnabled, Ie = Pe.init(this.clippingPlanes, Oe, i), (R = W.get(e, i)).init(), function e(t, i, n, r) {
                if (!1 !== t.visible) {
                    if (t.layers.test(i.layers))
                        if (t.isGroup) n = t.renderOrder;
                        else if (t.isLight) D.pushLight(t), t.castShadow && D.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || Le.intersectsSprite(t)) {
                            r && De.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Re);
                            var o = G.update(t),
                                s = t.material;
                            s.visible && R.push(t, o, s, n, De.z, null)
                        }
                    } else if (t.isImmediateRenderObject) r && De.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Re), R.push(t, null, t.material, n, De.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || Le.intersectsObject(t)))
                        if (r && De.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Re), o = G.update(t), s = t.material, Array.isArray(s))
                            for (var a = o.groups, l = 0, c = a.length; l < c; l++) {
                                var u = a[l],
                                    h = s[u.materialIndex];
                                h && h.visible && R.push(t, o, h, n, De.z, u)
                            } else s.visible && R.push(t, o, s, n, De.z, null);
                    for (l = 0, c = (t = t.children).length; l < c; l++) e(t[l], i, n, r)
                }
            }(e, i, 0, le.sortObjects), !0 === le.sortObjects && R.sort(), Ie && Pe.beginShadows(), Be.render(D.state.shadowsArray, e, i), D.setupLights(i), Ie && Pe.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== o && this.setRenderTarget(o), X.render(R, e, i, s), n = R.opaque, r = R.transparent, e.overrideMaterial ? (o = e.overrideMaterial, n.length && u(n, e, i, o), r.length && u(r, e, i, o)) : (n.length && u(n, e, i), r.length && u(r, e, i)), e.onAfterRender(le, e, i), null !== pe && (H.updateRenderTargetMipmap(pe), H.updateMultisampleRenderTarget(pe)), B.buffers.depth.setTest(!0), B.buffers.depth.setMask(!0), B.buffers.color.setMask(!0), B.setPolygonOffset(!1), ze.enabled && ze.submitFrame(), D = R = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.setFramebuffer = function (e) {
            ue !== e && ke.bindFramebuffer(36160, e), ue = e
        }, this.getActiveCubeFace = function () {
            return he
        }, this.getActiveMipMapLevel = function () {
            return de
        }, this.getRenderTarget = function () {
            return pe
        }, this.setRenderTarget = function (e, t, i) {
            pe = e, he = t, de = i, e && void 0 === F.get(e).__webglFramebuffer && H.setupRenderTarget(e);
            var n = ue,
                r = !1;
            e ? (n = F.get(e).__webglFramebuffer, e.isWebGLRenderTargetCube ? (n = n[t || 0], r = !0) : n = e.isWebGLMultisampleRenderTarget ? F.get(e).__webglMultisampledFramebuffer : n, xe.copy(e.viewport), we.copy(e.scissor), _e = e.scissorTest) : (xe.copy(Te).multiplyScalar(Se), we.copy(Ae).multiplyScalar(Se), _e = Ce), fe !== n && (ke.bindFramebuffer(36160, n), fe = n), B.viewport(xe), B.scissor(we), B.setScissorTest(_e), r && (e = F.get(e.texture), ke.framebufferTexture2D(36160, 36064, 34069 + (t || 0), e.__webglTexture, i || 0))
        }, this.readRenderTargetPixels = function (e, t, i, n, r, o, s) {
            if (e && e.isWebGLRenderTarget) {
                var a = F.get(e).__webglFramebuffer;
                if (e.isWebGLRenderTargetCube && void 0 !== s && (a = a[s]), a) {
                    s = !1, a !== fe && (ke.bindFramebuffer(36160, a), s = !0);
                    try {
                        var l = e.texture,
                            c = l.format,
                            u = l.type;
                        1023 !== c && ae.convert(c) !== ke.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === u || ae.convert(u) === ke.getParameter(35738) || 1015 === u && (z.isWebGL2 || k.get("OES_texture_float") || k.get("WEBGL_color_buffer_float")) || 1016 === u && (z.isWebGL2 ? k.get("EXT_color_buffer_float") : k.get("EXT_color_buffer_half_float")) ? 36053 === ke.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - n && 0 <= i && i <= e.height - r && ke.readPixels(t, i, n, r, ae.convert(c), ae.convert(u), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                    } finally {
                        s && ke.bindFramebuffer(36160, fe)
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function (e, t, i) {
            var n = t.image.width,
                r = t.image.height,
                o = ae.convert(t.format);
            H.setTexture2D(t, 0), ke.copyTexImage2D(3553, i || 0, o, e.x, e.y, n, r, 0)
        }, this.copyTextureToTexture = function (e, t, i, n) {
            var r = t.image.width,
                o = t.image.height,
                s = ae.convert(i.format),
                a = ae.convert(i.type);
            H.setTexture2D(i, 0), t.isDataTexture ? ke.texSubImage2D(3553, n || 0, e.x, e.y, r, o, s, a, t.image.data) : ke.texSubImage2D(3553, n || 0, e.x, e.y, s, a, t.image)
        }
    }

    function At(e, t) {
        this.name = "", this.color = new b(e), this.density = void 0 !== t ? t : 25e-5
    }

    function Ct(e, t, i) {
        this.name = "", this.color = new b(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3
    }

    function Lt() {
        S.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0
    }

    function Pt(e, t) {
        this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function It(e, t, i, n) {
        this.data = e, this.itemSize = t, this.offset = i, this.normalized = !0 === n
    }

    function Ot(e) {
        V.call(this), this.type = "SpriteMaterial", this.color = new b(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(e)
    }

    function Rt(e) {
        if (S.call(this), this.type = "Sprite", void 0 === Bo) {
            Bo = new F;
            var t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
            t = new Pt(t, 5), Bo.setIndex([0, 1, 2, 0, 2, 3]), Bo.addAttribute("position", new It(t, 3, 0, !1)), Bo.addAttribute("uv", new It(t, 2, 3, !1))
        }
        this.geometry = Bo, this.material = void 0 !== e ? e : new Ot, this.center = new i(.5, .5)
    }

    function Dt() {
        S.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }

    function kt(e, t) {
        e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Z.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new g, this.bindMatrixInverse = new g
    }

    function zt(e, t) {
        if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
        else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
        else
            for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new g)
    }

    function Bt() {
        S.call(this), this.type = "Bone"
    }

    function Nt(e) {
        V.call(this), this.type = "LineBasicMaterial", this.color = new b(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(e)
    }

    function Ft(e, t, i) {
        1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), S.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new F, this.material = void 0 !== t ? t : new Nt({
            color: 16777215 * Math.random()
        })
    }

    function Ht(e, t) {
        Ft.call(this, e, t), this.type = "LineSegments"
    }

    function Ut(e, t) {
        Ft.call(this, e, t), this.type = "LineLoop"
    }

    function jt(e) {
        V.call(this), this.type = "PointsMaterial", this.color = new b(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = this.morphTargets = !1, this.setValues(e)
    }

    function Gt(e, t) {
        S.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new F, this.material = void 0 !== t ? t : new jt({
            color: 16777215 * Math.random()
        })
    }

    function Vt(e, t, i, n, r, o, a, l, c) {
        s.call(this, e, t, i, n, r, o, a, l, c), this.format = void 0 !== a ? a : 1022, this.minFilter = void 0 !== o ? o : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1
    }

    function Wt(e, t, i, n, r, o, a, l, c, u, h, d) {
        s.call(this, null, o, a, l, c, u, n, r, h, d), this.image = {
            width: t,
            height: i
        }, this.mipmaps = e, this.generateMipmaps = this.flipY = !1
    }

    function qt(e, t, i, n, r, o, a, l, c) {
        s.call(this, e, t, i, n, r, o, a, l, c), this.needsUpdate = !0
    }

    function Xt(e, t, i, n, r, o, a, l, c, u) {
        if (1026 !== (u = void 0 !== u ? u : 1026) && 1027 !== u) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && 1026 === u && (i = 1012), void 0 === i && 1027 === u && (i = 1020), s.call(this, null, n, r, o, a, l, u, i, c), this.image = {
            width: e,
            height: t
        }, this.magFilter = void 0 !== a ? a : 1003, this.minFilter = void 0 !== l ? l : 1003, this.generateMipmaps = this.flipY = !1
    }

    function Yt(e) {
        F.call(this), this.type = "WireframeGeometry";
        var t, i, n, o = [],
            s = [0, 0],
            a = {},
            l = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var c = e.faces,
                u = 0;
            for (i = c.length; u < i; u++) {
                var h = c[u];
                for (t = 0; 3 > t; t++) {
                    var d = h[l[t]],
                        p = h[l[(t + 1) % 3]];
                    s[0] = Math.min(d, p), s[1] = Math.max(d, p), void 0 === a[d = s[0] + "," + s[1]] && (a[d] = {
                        index1: s[0],
                        index2: s[1]
                    })
                }
            }
            for (d in a) u = a[d], l = e.vertices[u.index1], o.push(l.x, l.y, l.z), l = e.vertices[u.index2], o.push(l.x, l.y, l.z)
        } else if (e && e.isBufferGeometry)
            if (l = new r, null !== e.index) {
                c = e.attributes.position, h = e.index;
                var f = e.groups;
                for (0 === f.length && (f = [{
                        start: 0,
                        count: h.count,
                        materialIndex: 0
                    }]), e = 0, n = f.length; e < n; ++e)
                    for (t = (u = f[e]).start, i = u.count, u = t, i = t + i; u < i; u += 3)
                        for (t = 0; 3 > t; t++) d = h.getX(u + t), p = h.getX(u + (t + 1) % 3), s[0] = Math.min(d, p), s[1] = Math.max(d, p), void 0 === a[d = s[0] + "," + s[1]] && (a[d] = {
                            index1: s[0],
                            index2: s[1]
                        });
                for (d in a) u = a[d], l.fromBufferAttribute(c, u.index1), o.push(l.x, l.y, l.z), l.fromBufferAttribute(c, u.index2), o.push(l.x, l.y, l.z)
            } else
                for (u = 0, i = (c = e.attributes.position).count / 3; u < i; u++)
                    for (t = 0; 3 > t; t++) a = 3 * u + t, l.fromBufferAttribute(c, a), o.push(l.x, l.y, l.z), a = 3 * u + (t + 1) % 3, l.fromBufferAttribute(c, a), o.push(l.x, l.y, l.z);
        this.addAttribute("position", new k(o, 3))
    }

    function Zt(e, t, i) {
        T.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: i
        }, this.fromBufferGeometry(new Qt(e, t, i)), this.mergeVertices()
    }

    function Qt(e, t, i) {
        F.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: i
        };
        var n, o, s = [],
            a = [],
            l = [],
            c = [],
            u = new r,
            h = new r,
            d = new r,
            p = new r,
            f = new r;
        3 > e.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var m = t + 1;
        for (n = 0; n <= i; n++) {
            var g = n / i;
            for (o = 0; o <= t; o++) {
                var v = o / t;
                e(v, g, h), a.push(h.x, h.y, h.z), 0 <= v - 1e-5 ? (e(v - 1e-5, g, d), p.subVectors(h, d)) : (e(v + 1e-5, g, d), p.subVectors(d, h)), 0 <= g - 1e-5 ? (e(v, g - 1e-5, d), f.subVectors(h, d)) : (e(v, g + 1e-5, d), f.subVectors(d, h)), u.crossVectors(p, f).normalize(), l.push(u.x, u.y, u.z), c.push(v, g)
            }
        }
        for (n = 0; n < i; n++)
            for (o = 0; o < t; o++) e = n * m + o + 1, u = (n + 1) * m + o + 1, h = (n + 1) * m + o, s.push(n * m + o, e, h), s.push(e, u, h);
        this.setIndex(s), this.addAttribute("position", new k(a, 3)), this.addAttribute("normal", new k(l, 3)), this.addAttribute("uv", new k(c, 2))
    }

    function Jt(e, t, i, n) {
        T.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: n
        }, this.fromBufferGeometry(new Kt(e, t, i, n)), this.mergeVertices()
    }

    function Kt(e, t, n, o) {
        function s(e) {
            c.push(e.x, e.y, e.z)
        }

        function a(t, i) {
            t *= 3, i.x = e[t + 0], i.y = e[t + 1], i.z = e[t + 2]
        }

        function l(e, t, i, n) {
            0 > n && 1 === e.x && (u[t] = e.x - 1), 0 === i.x && 0 === i.z && (u[t] = n / 2 / Math.PI + .5)
        }
        F.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: o
        }, n = n || 1;
        var c = [],
            u = [];
        ! function (e) {
            for (var i = new r, n = new r, o = new r, l = 0; l < t.length; l += 3) {
                a(t[l + 0], i), a(t[l + 1], n), a(t[l + 2], o);
                var c, u, h = i,
                    d = n,
                    p = o,
                    f = Math.pow(2, e),
                    m = [];
                for (u = 0; u <= f; u++) {
                    m[u] = [];
                    var g = h.clone().lerp(p, u / f),
                        v = d.clone().lerp(p, u / f),
                        y = f - u;
                    for (c = 0; c <= y; c++) m[u][c] = 0 === c && u === f ? g : g.clone().lerp(v, c / y)
                }
                for (u = 0; u < f; u++)
                    for (c = 0; c < 2 * (f - u) - 1; c++) h = Math.floor(c / 2), 0 == c % 2 ? (s(m[u][h + 1]), s(m[u + 1][h]), s(m[u][h])) : (s(m[u][h + 1]), s(m[u + 1][h + 1]), s(m[u + 1][h]))
            }
        }(o = o || 0),
        function (e) {
            for (var t = new r, i = 0; i < c.length; i += 3) t.x = c[i + 0], t.y = c[i + 1], t.z = c[i + 2], t.normalize().multiplyScalar(e), c[i + 0] = t.x, c[i + 1] = t.y, c[i + 2] = t.z
        }(n),
        function () {
            for (var e = new r, t = 0; t < c.length; t += 3) e.x = c[t + 0], e.y = c[t + 1], e.z = c[t + 2], u.push(Math.atan2(e.z, -e.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5));
            e = new r, t = new r;
            for (var n = new r, o = new r, s = new i, a = new i, h = new i, d = 0, p = 0; d < c.length; d += 9, p += 6) {
                e.set(c[d + 0], c[d + 1], c[d + 2]), t.set(c[d + 3], c[d + 4], c[d + 5]), n.set(c[d + 6], c[d + 7], c[d + 8]), s.set(u[p + 0], u[p + 1]), a.set(u[p + 2], u[p + 3]), h.set(u[p + 4], u[p + 5]), o.copy(e).add(t).add(n).divideScalar(3);
                var f = Math.atan2(o.z, -o.x);
                l(s, p + 0, e, f), l(a, p + 2, t, f), l(h, p + 4, n, f)
            }
            for (e = 0; e < u.length; e += 6) t = u[e + 0], n = u[e + 2], o = u[e + 4], s = Math.min(t, n, o), .9 < Math.max(t, n, o) && .1 > s && (.2 > t && (u[e + 0] += 1), .2 > n && (u[e + 2] += 1), .2 > o && (u[e + 4] += 1))
        }(), this.addAttribute("position", new k(c, 3)), this.addAttribute("normal", new k(c.slice(), 3)), this.addAttribute("uv", new k(u, 2)), 0 === o ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function $t(e, t) {
        T.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ei(e, t)), this.mergeVertices()
    }

    function ei(e, t) {
        Kt.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function ti(e, t) {
        T.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ii(e, t)), this.mergeVertices()
    }

    function ii(e, t) {
        Kt.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function ni(e, t) {
        T.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ri(e, t)), this.mergeVertices()
    }

    function ri(e, t) {
        var i = (1 + Math.sqrt(5)) / 2;
        Kt.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function oi(e, t) {
        T.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new si(e, t)), this.mergeVertices()
    }

    function si(e, t) {
        var i = (1 + Math.sqrt(5)) / 2,
            n = 1 / i;
        Kt.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function ai(e, t, i, n, r, o) {
        T.call(this), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: n,
            closed: r
        }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed."), e = new li(e, t, i, n, r), this.tangents = e.tangents, this.normals = e.normals, this.binormals = e.binormals, this.fromBufferGeometry(e), this.mergeVertices()
    }

    function li(e, t, n, o, s) {
        function a(i) {
            f = e.getPointAt(i / t, f);
            var r = l.normals[i];
            for (i = l.binormals[i], u = 0; u <= o; u++) {
                var s = u / o * Math.PI * 2,
                    a = Math.sin(s);
                s = -Math.cos(s), d.x = s * r.x + a * i.x, d.y = s * r.y + a * i.y, d.z = s * r.z + a * i.z, d.normalize(), g.push(d.x, d.y, d.z), h.x = f.x + n * d.x, h.y = f.y + n * d.y, h.z = f.z + n * d.z, m.push(h.x, h.y, h.z)
            }
        }
        F.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: o,
            closed: s
        }, t = t || 64, n = n || 1, o = o || 8, s = s || !1;
        var l = e.computeFrenetFrames(t, s);
        this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
        var c, u, h = new r,
            d = new r,
            p = new i,
            f = new r,
            m = [],
            g = [],
            v = [],
            y = [];
        for (c = 0; c < t; c++) a(c);
        for (a(!1 === s ? t : 0), c = 0; c <= t; c++)
            for (u = 0; u <= o; u++) p.x = c / t, p.y = u / o, v.push(p.x, p.y);
        ! function () {
            for (u = 1; u <= t; u++)
                for (c = 1; c <= o; c++) {
                    var e = (o + 1) * u + (c - 1),
                        i = (o + 1) * u + c,
                        n = (o + 1) * (u - 1) + c;
                    y.push((o + 1) * (u - 1) + (c - 1), e, n), y.push(e, i, n)
                }
        }(), this.setIndex(y), this.addAttribute("position", new k(m, 3)), this.addAttribute("normal", new k(g, 3)), this.addAttribute("uv", new k(v, 2))
    }

    function ci(e, t, i, n, r, o, s) {
        T.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: o
        }, void 0 !== s && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new ui(e, t, i, n, r, o)), this.mergeVertices()
    }

    function ui(e, t, i, n, o, s) {
        function a(e, t, i, n, r) {
            var o = Math.sin(e);
            t = i / t * e, i = Math.cos(t), r.x = n * (2 + i) * .5 * Math.cos(e), r.y = n * (2 + i) * o * .5, r.z = n * Math.sin(t) * .5
        }
        F.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: o,
            q: s
        }, e = e || 1, t = t || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, o = o || 2, s = s || 3;
        var l, c = [],
            u = [],
            h = [],
            d = [],
            p = new r,
            f = new r,
            m = new r,
            g = new r,
            v = new r,
            y = new r,
            b = new r;
        for (l = 0; l <= i; ++l) {
            var x = l / i * o * Math.PI * 2;
            for (a(x, o, s, e, m), a(x + .01, o, s, e, g), y.subVectors(g, m), b.addVectors(g, m), v.crossVectors(y, b), b.crossVectors(v, y), v.normalize(), b.normalize(), x = 0; x <= n; ++x) {
                var w = x / n * Math.PI * 2,
                    _ = -t * Math.cos(w);
                w = t * Math.sin(w), p.x = m.x + (_ * b.x + w * v.x), p.y = m.y + (_ * b.y + w * v.y), p.z = m.z + (_ * b.z + w * v.z), u.push(p.x, p.y, p.z), f.subVectors(p, m).normalize(), h.push(f.x, f.y, f.z), d.push(l / i), d.push(x / n)
            }
        }
        for (x = 1; x <= i; x++)
            for (l = 1; l <= n; l++) e = (n + 1) * x + (l - 1), t = (n + 1) * x + l, o = (n + 1) * (x - 1) + l, c.push((n + 1) * (x - 1) + (l - 1), e, o), c.push(e, t, o);
        this.setIndex(c), this.addAttribute("position", new k(u, 3)), this.addAttribute("normal", new k(h, 3)), this.addAttribute("uv", new k(d, 2))
    }

    function hi(e, t, i, n, r) {
        T.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        }, this.fromBufferGeometry(new di(e, t, i, n, r)), this.mergeVertices()
    }

    function di(e, t, i, n, o) {
        F.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: o
        }, e = e || 1, t = t || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, o = o || 2 * Math.PI;
        var s, a, l = [],
            c = [],
            u = [],
            h = [],
            d = new r,
            p = new r,
            f = new r;
        for (s = 0; s <= i; s++)
            for (a = 0; a <= n; a++) {
                var m = a / n * o,
                    g = s / i * Math.PI * 2;
                p.x = (e + t * Math.cos(g)) * Math.cos(m), p.y = (e + t * Math.cos(g)) * Math.sin(m), p.z = t * Math.sin(g), c.push(p.x, p.y, p.z), d.x = e * Math.cos(m), d.y = e * Math.sin(m), f.subVectors(p, d).normalize(), u.push(f.x, f.y, f.z), h.push(a / n), h.push(s / i)
            }
        for (s = 1; s <= i; s++)
            for (a = 1; a <= n; a++) e = (n + 1) * (s - 1) + a - 1, t = (n + 1) * (s - 1) + a, o = (n + 1) * s + a, l.push((n + 1) * s + a - 1, e, o), l.push(e, t, o);
        this.setIndex(l), this.addAttribute("position", new k(c, 3)), this.addAttribute("normal", new k(u, 3)), this.addAttribute("uv", new k(h, 2))
    }

    function pi(e, t, i, n, r) {
        for (var o, s = 0, a = t, l = i - n; a < i; a += n) s += (e[l] - e[a]) * (e[a + 1] + e[l + 1]), l = a;
        if (r === 0 < s)
            for (r = t; r < i; r += n) o = Si(r, e[r], e[r + 1], o);
        else
            for (r = i - n; r >= t; r -= n) o = Si(r, e[r], e[r + 1], o);
        return o && wi(o, o.next) && (Ti(o), o = o.next), o
    }

    function fi(e, t) {
        if (!e) return e;
        t || (t = e);
        do {
            var i = !1;
            if (e.steiner || !wi(e, e.next) && 0 !== xi(e.prev, e, e.next)) e = e.next;
            else {
                if (Ti(e), (e = t = e.prev) === e.next) break;
                i = !0
            }
        } while (i || e !== t);
        return t
    }

    function mi(e, t) {
        return e.x - t.x
    }

    function gi(e, t) {
        var i = t,
            n = e.x,
            r = e.y,
            o = -1 / 0;
        do {
            if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                var s = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                if (s <= n && s > o) {
                    if (o = s, s === n) {
                        if (r === i.y) return i;
                        if (r === i.next.y) return i.next
                    }
                    var a = i.x < i.next.x ? i : i.next
                }
            }
            i = i.next
        } while (i !== t);
        if (!a) return null;
        if (n === o) return a.prev;
        t = a, s = a.x;
        var l = a.y,
            c = 1 / 0;
        for (i = a.next; i !== t;) {
            if (n >= i.x && i.x >= s && n !== i.x && bi(r < l ? n : o, r, s, l, r < l ? o : n, r, i.x, i.y)) {
                var u = Math.abs(r - i.y) / (n - i.x);
                (u < c || u === c && i.x > a.x) && Ei(i, e) && (a = i, c = u)
            }
            i = i.next
        }
        return a
    }

    function vi(e, t, i, n, r) {
        return 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1) | (1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }

    function yi(e) {
        var t = e,
            i = e;
        do {
            t.x < i.x && (i = t), t = t.next
        } while (t !== e);
        return i
    }

    function bi(e, t, i, n, r, o, s, a) {
        return 0 <= (r - s) * (t - a) - (e - s) * (o - a) && 0 <= (e - s) * (n - a) - (i - s) * (t - a) && 0 <= (i - s) * (o - a) - (r - s) * (n - a)
    }

    function xi(e, t, i) {
        return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
    }

    function wi(e, t) {
        return e.x === t.x && e.y === t.y
    }

    function _i(e, t, i, n) {
        return !!(wi(e, t) && wi(i, n) || wi(e, n) && wi(i, t)) || 0 < xi(e, t, i) != 0 < xi(e, t, n) && 0 < xi(i, n, e) != 0 < xi(i, n, t)
    }

    function Ei(e, t) {
        return 0 > xi(e.prev, e, e.next) ? 0 <= xi(e, t, e.next) && 0 <= xi(e, e.prev, t) : 0 > xi(e, t, e.prev) || 0 > xi(e, e.next, t)
    }

    function Mi(e, t) {
        var i = new Ai(e.i, e.x, e.y),
            n = new Ai(t.i, t.x, t.y),
            r = e.next,
            o = t.prev;
        return e.next = t, t.prev = e, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n
    }

    function Si(e, t, i, n) {
        return e = new Ai(e, t, i), n ? (e.next = n.next, e.prev = n, n.next.prev = e, n.next = e) : (e.prev = e, e.next = e), e
    }

    function Ti(e) {
        e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }

    function Ai(e, t, i) {
        this.i = e, this.x = t, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1
    }

    function Ci(e) {
        var t = e.length;
        2 < t && e[t - 1].equals(e[0]) && e.pop()
    }

    function Li(e, t) {
        for (var i = 0; i < t.length; i++) e.push(t[i].x), e.push(t[i].y)
    }

    function Pi(e, t) {
        T.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
        }, this.fromBufferGeometry(new Ii(e, t)), this.mergeVertices()
    }

    function Ii(e, t) {
        function n(e) {
            function n(e, t, i) {
                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e)
            }

            function l(e, t, n) {
                var r = e.x - t.x,
                    o = e.y - t.y,
                    s = n.x - e.x,
                    a = n.y - e.y,
                    l = r * r + o * o;
                if (Math.abs(r * a - o * s) > Number.EPSILON) {
                    var c = Math.sqrt(l),
                        u = Math.sqrt(s * s + a * a);
                    if (l = t.x - o / c, t = t.y + r / c, 2 >= (o = (s = l + r * (a = ((n.x - a / u - l) * a - (n.y + s / u - t) * s) / (r * a - o * s)) - e.x) * s + (r = t + o * a - e.y) * r)) return new i(s, r);
                    o = Math.sqrt(o / 2)
                } else e = !1, r > Number.EPSILON ? s > Number.EPSILON && (e = !0) : r < -Number.EPSILON ? s < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(a) && (e = !0), e ? (s = -o, o = Math.sqrt(l)) : (s = r, r = o, o = Math.sqrt(l / 2));
                return new i(s / o, r / o)
            }

            function c(e, t) {
                for (U = e.length; 0 <= --U;) {
                    var i = U,
                        n = U - 1;
                    0 > n && (n = e.length - 1);
                    var r, a = g + 2 * _;
                    for (r = 0; r < a; r++) {
                        var l = F * r,
                            c = F * (r + 1),
                            u = t + n + l,
                            h = t + n + c;
                        c = t + i + c, d(t + i + l), d(u), d(c), d(u), d(h), d(c), l = s.length / 3, p((l = M.generateSideWallUV(o, s, l - 6, l - 3, l - 2, l - 1))[0]), p(l[1]), p(l[3]), p(l[1]), p(l[2]), p(l[3])
                    }
                }
            }

            function u(e, t, i) {
                f.push(e), f.push(t), f.push(i)
            }

            function h(e, t, i) {
                d(e), d(t), d(i), e = s.length / 3, p((e = M.generateTopUV(o, s, e - 3, e - 2, e - 1))[0]), p(e[1]), p(e[2])
            }

            function d(e) {
                s.push(f[3 * e]), s.push(f[3 * e + 1]), s.push(f[3 * e + 2])
            }

            function p(e) {
                a.push(e.x), a.push(e.y)
            }
            var f = [],
                m = void 0 !== t.curveSegments ? t.curveSegments : 12,
                g = void 0 !== t.steps ? t.steps : 1,
                v = void 0 !== t.depth ? t.depth : 100,
                y = void 0 === t.bevelEnabled || t.bevelEnabled,
                b = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                x = void 0 !== t.bevelSize ? t.bevelSize : b - 2,
                w = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                _ = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                E = t.extrudePath,
                M = void 0 !== t.UVGenerator ? t.UVGenerator : jo;
            void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), v = t.amount);
            var S, T = !1;
            if (E) {
                var A = E.getSpacedPoints(g);
                T = !0, y = !1;
                var C = E.computeFrenetFrames(g, !1),
                    L = new r,
                    P = new r,
                    I = new r
            }
            y || (w = x = b = _ = 0), m = e.extractPoints(m), e = m.shape;
            var O = m.holes;
            if (!Uo.isClockWise(e)) {
                e = e.reverse();
                var R = 0;
                for (S = O.length; R < S; R++) {
                    var D = O[R];
                    Uo.isClockWise(D) && (O[R] = D.reverse())
                }
            }
            var k = Uo.triangulateShape(e, O),
                z = e;
            for (R = 0, S = O.length; R < S; R++) D = O[R], e = e.concat(D);
            var B, N, F = e.length,
                H = k.length;
            m = [];
            var U = 0,
                j = z.length,
                G = j - 1;
            for (B = U + 1; U < j; U++, G++, B++) G === j && (G = 0), B === j && (B = 0), m[U] = l(z[U], z[G], z[B]);
            E = [];
            var V = m.concat();
            for (R = 0, S = O.length; R < S; R++) {
                D = O[R];
                var W = [];
                for (U = 0, G = (j = D.length) - 1, B = U + 1; U < j; U++, G++, B++) G === j && (G = 0), B === j && (B = 0), W[U] = l(D[U], D[G], D[B]);
                E.push(W), V = V.concat(W)
            }
            for (G = 0; G < _; G++) {
                j = G / _;
                var q = b * Math.cos(j * Math.PI / 2);
                for (B = x * Math.sin(j * Math.PI / 2) + w, U = 0, j = z.length; U < j; U++) {
                    var X = n(z[U], m[U], B);
                    u(X.x, X.y, -q)
                }
                for (R = 0, S = O.length; R < S; R++)
                    for (D = O[R], W = E[R], U = 0, j = D.length; U < j; U++) u((X = n(D[U], W[U], B)).x, X.y, -q)
            }
            for (B = x + w, U = 0; U < F; U++) X = y ? n(e[U], V[U], B) : e[U], T ? (P.copy(C.normals[0]).multiplyScalar(X.x), L.copy(C.binormals[0]).multiplyScalar(X.y), I.copy(A[0]).add(P).add(L), u(I.x, I.y, I.z)) : u(X.x, X.y, 0);
            for (j = 1; j <= g; j++)
                for (U = 0; U < F; U++) X = y ? n(e[U], V[U], B) : e[U], T ? (P.copy(C.normals[j]).multiplyScalar(X.x), L.copy(C.binormals[j]).multiplyScalar(X.y), I.copy(A[j]).add(P).add(L), u(I.x, I.y, I.z)) : u(X.x, X.y, v / g * j);
            for (G = _ - 1; 0 <= G; G--) {
                for (j = G / _, q = b * Math.cos(j * Math.PI / 2), B = x * Math.sin(j * Math.PI / 2) + w, U = 0, j = z.length; U < j; U++) u((X = n(z[U], m[U], B)).x, X.y, v + q);
                for (R = 0, S = O.length; R < S; R++)
                    for (D = O[R], W = E[R], U = 0, j = D.length; U < j; U++) X = n(D[U], W[U], B), T ? u(X.x, X.y + A[g - 1].y, A[g - 1].x + q) : u(X.x, X.y, v + q)
            }! function () {
                var e = s.length / 3;
                if (y) {
                    var t = 0 * F;
                    for (U = 0; U < H; U++) h((N = k[U])[2] + t, N[1] + t, N[0] + t);
                    for (t = F * (g + 2 * _), U = 0; U < H; U++) h((N = k[U])[0] + t, N[1] + t, N[2] + t)
                } else {
                    for (U = 0; U < H; U++) h((N = k[U])[2], N[1], N[0]);
                    for (U = 0; U < H; U++) h((N = k[U])[0] + F * g, N[1] + F * g, N[2] + F * g)
                }
                o.addGroup(e, s.length / 3 - e, 0)
            }(),
            function () {
                var e = s.length / 3,
                    t = 0;
                for (c(z, t), t += z.length, R = 0, S = O.length; R < S; R++) c(D = O[R], t), t += D.length;
                o.addGroup(e, s.length / 3 - e, 1)
            }()
        }
        F.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
            shapes: e,
            options: t
        }, e = Array.isArray(e) ? e : [e];
        for (var o = this, s = [], a = [], l = 0, c = e.length; l < c; l++) n(e[l]);
        this.addAttribute("position", new k(s, 3)), this.addAttribute("uv", new k(a, 2)), this.computeVertexNormals()
    }

    function Oi(e, t, i) {
        if (i.shapes = [], Array.isArray(e))
            for (var n = 0, r = e.length; n < r; n++) i.shapes.push(e[n].uuid);
        else i.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()), i
    }

    function Ri(e, t) {
        T.call(this), this.type = "TextGeometry", this.parameters = {
            text: e,
            parameters: t
        }, this.fromBufferGeometry(new Di(e, t)), this.mergeVertices()
    }

    function Di(e, t) {
        var i = (t = t || {}).font;
        if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new T;
        e = i.generateShapes(e, t.size), t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Ii.call(this, e, t), this.type = "TextBufferGeometry"
    }

    function ki(e, t, i, n, r, o, s) {
        T.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: o,
            thetaLength: s
        }, this.fromBufferGeometry(new zi(e, t, i, n, r, o, s)), this.mergeVertices()
    }

    function zi(e, t, i, n, o, s, a) {
        F.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: o,
            thetaStart: s,
            thetaLength: a
        }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : Math.PI;
        var l, c, u = Math.min(s + a, Math.PI),
            h = 0,
            d = [],
            p = new r,
            f = new r,
            m = [],
            g = [],
            v = [],
            y = [];
        for (c = 0; c <= i; c++) {
            var b = [],
                x = c / i,
                w = 0;
            for (0 == c && 0 == s ? w = .5 / t : c == i && u == Math.PI && (w = -.5 / t), l = 0; l <= t; l++) {
                var _ = l / t;
                p.x = -e * Math.cos(n + _ * o) * Math.sin(s + x * a), p.y = e * Math.cos(s + x * a), p.z = e * Math.sin(n + _ * o) * Math.sin(s + x * a), g.push(p.x, p.y, p.z), f.copy(p).normalize(), v.push(f.x, f.y, f.z), y.push(_ + w, 1 - x), b.push(h++)
            }
            d.push(b)
        }
        for (c = 0; c < i; c++)
            for (l = 0; l < t; l++) e = d[c][l + 1], n = d[c][l], o = d[c + 1][l], a = d[c + 1][l + 1], (0 !== c || 0 < s) && m.push(e, n, a), (c !== i - 1 || u < Math.PI) && m.push(n, o, a);
        this.setIndex(m), this.addAttribute("position", new k(g, 3)), this.addAttribute("normal", new k(v, 3)), this.addAttribute("uv", new k(y, 2))
    }

    function Bi(e, t, i, n, r, o) {
        T.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: o
        }, this.fromBufferGeometry(new Ni(e, t, i, n, r, o)), this.mergeVertices()
    }

    function Ni(e, t, n, o, s, a) {
        F.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: o,
            thetaStart: s,
            thetaLength: a
        }, e = e || .5, t = t || 1, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
        var l, c, u = [],
            h = [],
            d = [],
            p = [],
            f = e,
            m = (t - e) / (o = void 0 !== o ? Math.max(1, o) : 1),
            g = new r,
            v = new i;
        for (l = 0; l <= o; l++) {
            for (c = 0; c <= n; c++) e = s + c / n * a, g.x = f * Math.cos(e), g.y = f * Math.sin(e), h.push(g.x, g.y, g.z), d.push(0, 0, 1), v.x = (g.x / t + 1) / 2, v.y = (g.y / t + 1) / 2, p.push(v.x, v.y);
            f += m
        }
        for (l = 0; l < o; l++)
            for (t = l * (n + 1), c = 0; c < n; c++) s = (e = c + t) + n + 1, a = e + n + 2, f = e + 1, u.push(e, s, f), u.push(s, a, f);
        this.setIndex(u), this.addAttribute("position", new k(h, 3)), this.addAttribute("normal", new k(d, 3)), this.addAttribute("uv", new k(p, 2))
    }

    function Fi(e, t, i, n) {
        T.call(this), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: n
        }, this.fromBufferGeometry(new Hi(e, t, i, n)), this.mergeVertices()
    }

    function Hi(e, t, n, o) {
        F.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: o
        }, t = Math.floor(t) || 12, n = n || 0, o = o || 2 * Math.PI, o = ho.clamp(o, 0, 2 * Math.PI);
        var s, a = [],
            l = [],
            c = [],
            u = 1 / t,
            h = new r,
            d = new i;
        for (s = 0; s <= t; s++) {
            var p = n + s * u * o,
                f = Math.sin(p),
                m = Math.cos(p);
            for (p = 0; p <= e.length - 1; p++) h.x = e[p].x * f, h.y = e[p].y, h.z = e[p].x * m, l.push(h.x, h.y, h.z), d.x = s / t, d.y = p / (e.length - 1), c.push(d.x, d.y)
        }
        for (s = 0; s < t; s++)
            for (p = 0; p < e.length - 1; p++) u = (n = p + s * e.length) + e.length, h = n + e.length + 1, d = n + 1, a.push(n, u, d), a.push(u, h, d);
        if (this.setIndex(a), this.addAttribute("position", new k(l, 3)), this.addAttribute("uv", new k(c, 2)), this.computeVertexNormals(), o === 2 * Math.PI)
            for (o = this.attributes.normal.array, a = new r, l = new r, c = new r, n = t * e.length * 3, p = s = 0; s < e.length; s++, p += 3) a.x = o[p + 0], a.y = o[p + 1], a.z = o[p + 2], l.x = o[n + p + 0], l.y = o[n + p + 1], l.z = o[n + p + 2], c.addVectors(a, l).normalize(), o[p + 0] = o[n + p + 0] = c.x, o[p + 1] = o[n + p + 1] = c.y, o[p + 2] = o[n + p + 2] = c.z
    }

    function Ui(e, t) {
        T.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
            shapes: e,
            curveSegments: t
        }, this.fromBufferGeometry(new ji(e, t)), this.mergeVertices()
    }

    function ji(e, t) {
        function i(e) {
            var i, a = r.length / 3,
                c = (e = e.extractPoints(t)).shape,
                u = e.holes;
            for (!1 === Uo.isClockWise(c) && (c = c.reverse()), e = 0, i = u.length; e < i; e++) {
                var h = u[e];
                !0 === Uo.isClockWise(h) && (u[e] = h.reverse())
            }
            var d = Uo.triangulateShape(c, u);
            for (e = 0, i = u.length; e < i; e++) h = u[e], c = c.concat(h);
            for (e = 0, i = c.length; e < i; e++) h = c[e], r.push(h.x, h.y, 0), o.push(0, 0, 1), s.push(h.x, h.y);
            for (e = 0, i = d.length; e < i; e++) c = d[e], n.push(c[0] + a, c[1] + a, c[2] + a), l += 3
        }
        F.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: e,
            curveSegments: t
        }, t = t || 12;
        var n = [],
            r = [],
            o = [],
            s = [],
            a = 0,
            l = 0;
        if (!1 === Array.isArray(e)) i(e);
        else
            for (var c = 0; c < e.length; c++) i(e[c]), this.addGroup(a, l, c), a += l, l = 0;
        this.setIndex(n), this.addAttribute("position", new k(r, 3)), this.addAttribute("normal", new k(o, 3)), this.addAttribute("uv", new k(s, 2))
    }

    function Gi(e, t) {
        if (t.shapes = [], Array.isArray(e))
            for (var i = 0, n = e.length; i < n; i++) t.shapes.push(e[i].uuid);
        else t.shapes.push(e.uuid);
        return t
    }

    function Vi(e, t) {
        F.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: t
        };
        var i = [];
        t = Math.cos(ho.DEG2RAD * (void 0 !== t ? t : 1));
        var n = [0, 0],
            r = {},
            o = ["a", "b", "c"];
        if (e.isBufferGeometry) {
            var s = new T;
            s.fromBufferGeometry(e)
        } else s = e.clone();
        s.mergeVertices(), s.computeFaceNormals(), e = s.vertices;
        for (var a = 0, l = (s = s.faces).length; a < l; a++)
            for (var c = s[a], u = 0; 3 > u; u++) {
                var h = c[o[u]],
                    d = c[o[(u + 1) % 3]];
                n[0] = Math.min(h, d), n[1] = Math.max(h, d), void 0 === r[h = n[0] + "," + n[1]] ? r[h] = {
                    index1: n[0],
                    index2: n[1],
                    face1: a,
                    face2: void 0
                } : r[h].face2 = a
            }
        for (h in r)(void 0 === (n = r[h]).face2 || s[n.face1].normal.dot(s[n.face2].normal) <= t) && (o = e[n.index1], i.push(o.x, o.y, o.z), o = e[n.index2], i.push(o.x, o.y, o.z));
        this.addAttribute("position", new k(i, 3))
    }

    function Wi(e, t, i, n, r, o, s, a) {
        T.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: o,
            thetaStart: s,
            thetaLength: a
        }, this.fromBufferGeometry(new qi(e, t, i, n, r, o, s, a)), this.mergeVertices()
    }

    function qi(e, t, n, o, s, a, l, c) {
        function u(n) {
            var s, a = new i,
                u = new r,
                v = 0,
                x = !0 === n ? e : t,
                w = !0 === n ? 1 : -1,
                _ = g;
            for (s = 1; s <= o; s++) p.push(0, y * w, 0), f.push(0, w, 0), m.push(.5, .5), g++;
            var E = g;
            for (s = 0; s <= o; s++) {
                var M = s / o * c + l,
                    S = Math.cos(M);
                M = Math.sin(M), u.x = x * M, u.y = y * w, u.z = x * S, p.push(u.x, u.y, u.z), f.push(0, w, 0), a.x = .5 * S + .5, a.y = .5 * M * w + .5, m.push(a.x, a.y), g++
            }
            for (s = 0; s < o; s++) a = _ + s, u = E + s, !0 === n ? d.push(u, u + 1, a) : d.push(u + 1, u, a), v += 3;
            h.addGroup(b, v, !0 === n ? 1 : 2), b += v
        }
        F.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: o,
            heightSegments: s,
            openEnded: a,
            thetaStart: l,
            thetaLength: c
        };
        var h = this;
        e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, n = n || 1, o = Math.floor(o) || 8, s = Math.floor(s) || 1, a = void 0 !== a && a, l = void 0 !== l ? l : 0, c = void 0 !== c ? c : 2 * Math.PI;
        var d = [],
            p = [],
            f = [],
            m = [],
            g = 0,
            v = [],
            y = n / 2,
            b = 0;
        ! function () {
            var i, a, u = new r,
                x = new r,
                w = 0,
                _ = (t - e) / n;
            for (a = 0; a <= s; a++) {
                var E = [],
                    M = a / s,
                    S = M * (t - e) + e;
                for (i = 0; i <= o; i++) {
                    var T = i / o,
                        A = T * c + l,
                        C = Math.sin(A);
                    A = Math.cos(A), x.x = S * C, x.y = -M * n + y, x.z = S * A, p.push(x.x, x.y, x.z), u.set(C, _, A).normalize(), f.push(u.x, u.y, u.z), m.push(T, 1 - M), E.push(g++)
                }
                v.push(E)
            }
            for (i = 0; i < o; i++)
                for (a = 0; a < s; a++) u = v[a + 1][i], x = v[a + 1][i + 1], _ = v[a][i + 1], d.push(v[a][i], u, _), d.push(u, x, _), w += 6;
            h.addGroup(b, w, 0), b += w
        }(), !1 === a && (0 < e && u(!0), 0 < t && u(!1)), this.setIndex(d), this.addAttribute("position", new k(p, 3)), this.addAttribute("normal", new k(f, 3)), this.addAttribute("uv", new k(m, 2))
    }

    function Xi(e, t, i, n, r, o, s) {
        Wi.call(this, 0, e, t, i, n, r, o, s), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: o,
            thetaLength: s
        }
    }

    function Yi(e, t, i, n, r, o, s) {
        qi.call(this, 0, e, t, i, n, r, o, s), this.type = "ConeBufferGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: o,
            thetaLength: s
        }
    }

    function Zi(e, t, i, n) {
        T.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: n
        }, this.fromBufferGeometry(new Qi(e, t, i, n)), this.mergeVertices()
    }

    function Qi(e, t, n, o) {
        F.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: o
        }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI;
        var s, a = [],
            l = [],
            c = [],
            u = [],
            h = new r,
            d = new i;
        l.push(0, 0, 0), c.push(0, 0, 1), u.push(.5, .5);
        var p = 0;
        for (s = 3; p <= t; p++, s += 3) {
            var f = n + p / t * o;
            h.x = e * Math.cos(f), h.y = e * Math.sin(f), l.push(h.x, h.y, h.z), c.push(0, 0, 1), d.x = (l[s] / e + 1) / 2, d.y = (l[s + 1] / e + 1) / 2, u.push(d.x, d.y)
        }
        for (s = 1; s <= t; s++) a.push(s, s + 1, 0);
        this.setIndex(a), this.addAttribute("position", new k(l, 3)), this.addAttribute("normal", new k(c, 3)), this.addAttribute("uv", new k(u, 2))
    }

    function Ji(e) {
        V.call(this), this.type = "ShadowMaterial", this.color = new b(0), this.transparent = !0, this.setValues(e)
    }

    function Ki(e) {
        W.call(this, e), this.type = "RawShaderMaterial"
    }

    function $i(e) {
        V.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new b(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function en(e) {
        $i.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(e)
    }

    function tn(e) {
        V.call(this), this.type = "MeshPhongMaterial", this.color = new b(16777215), this.specular = new b(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function nn(e) {
        tn.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
    }

    function rn(e) {
        V.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(e)
    }

    function on(e) {
        V.call(this), this.type = "MeshLambertMaterial", this.color = new b(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function sn(e) {
        V.call(this), this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new b(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.lights = this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }

    function an(e) {
        Nt.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
    }

    function ln(e, t, i, n) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i
    }

    function cn(e, t, i, n) {
        ln.call(this, e, t, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
    }

    function un(e, t, i, n) {
        ln.call(this, e, t, i, n)
    }

    function hn(e, t, i, n) {
        ln.call(this, e, t, i, n)
    }

    function dn(e, t, i, n) {
        if (void 0 === e) throw Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = Wo.convertArray(t, this.TimeBufferType), this.values = Wo.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
    }

    function pn(e, t, i) {
        dn.call(this, e, t, i)
    }

    function fn(e, t, i, n) {
        dn.call(this, e, t, i, n)
    }

    function mn(e, t, i, n) {
        dn.call(this, e, t, i, n)
    }

    function gn(e, t, i, n) {
        ln.call(this, e, t, i, n)
    }

    function vn(e, t, i, n) {
        dn.call(this, e, t, i, n)
    }

    function yn(e, t, i, n) {
        dn.call(this, e, t, i, n)
    }

    function bn(e, t, i, n) {
        dn.call(this, e, t, i, n)
    }

    function xn(e, t, i) {
        this.name = e, this.tracks = i, this.duration = void 0 !== t ? t : -1, this.uuid = ho.generateUUID(), 0 > this.duration && this.resetDuration()
    }

    function wn(e) {
        if (void 0 === e.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var t = function (e) {
            switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return mn;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return bn;
                case "color":
                    return fn;
                case "quaternion":
                    return vn;
                case "bool":
                case "boolean":
                    return pn;
                case "string":
                    return yn
            }
            throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            var i = [],
                n = [];
            Wo.flattenJSON(e.keys, i, n, "value"), e.times = i, e.values = n
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
    }

    function _n(e, t, i) {
        var n = this,
            r = !1,
            o = 0,
            s = 0,
            a = void 0;
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (e) {
            s++, !1 === r && void 0 !== n.onStart && n.onStart(e, o, s), r = !0
        }, this.itemEnd = function (e) {
            o++, void 0 !== n.onProgress && n.onProgress(e, o, s), o === s && (r = !1, void 0 !== n.onLoad) && n.onLoad()
        }, this.itemError = function (e) {
            void 0 !== n.onError && n.onError(e)
        }, this.resolveURL = function (e) {
            return a ? a(e) : e
        }, this.setURLModifier = function (e) {
            return a = e, this
        }
    }

    function En(e) {
        this.manager = void 0 !== e ? e : Xo
    }

    function Mn(e) {
        this.manager = void 0 !== e ? e : Xo
    }

    function Sn(e) {
        this.manager = void 0 !== e ? e : Xo, this._parser = null
    }

    function Tn(e) {
        this.manager = void 0 !== e ? e : Xo, this._parser = null
    }

    function An(e) {
        this.manager = void 0 !== e ? e : Xo
    }

    function Cn(e) {
        this.manager = void 0 !== e ? e : Xo
    }

    function Ln(e) {
        this.manager = void 0 !== e ? e : Xo
    }

    function Pn() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function In(e, t, i, n, r, o, s, a) {
        Pn.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = a || 0
    }

    function On(e, t, i, n, r, o) {
        In.call(this, e, t, i, i, n, r, o), this.type = "ArcCurve"
    }

    function Rn() {
        var e = 0,
            t = 0,
            i = 0,
            n = 0;
        return {
            initCatmullRom: function (r, o, s, a, l) {
                e = o, t = r = l * (s - r), i = -3 * o + 3 * s - 2 * r - (a = l * (a - o)), n = 2 * o - 2 * s + r + a
            },
            initNonuniformCatmullRom: function (r, o, s, a, l, c, u) {
                e = o, t = r = ((o - r) / l - (s - r) / (l + c) + (s - o) / c) * c, i = -3 * o + 3 * s - 2 * r - (a = ((s - o) / c - (a - o) / (c + u) + (a - s) / u) * c), n = 2 * o - 2 * s + r + a
            },
            calc: function (r) {
                var o = r * r;
                return e + t * r + i * o + n * o * r
            }
        }
    }

    function Dn(e, t, i, n) {
        Pn.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = i || "centripetal", this.tension = n || .5
    }

    function kn(e, t, i, n, r) {
        var o = e * e;
        return (2 * i - 2 * n + (t = .5 * (n - t)) + (r = .5 * (r - i))) * e * o + (-3 * i + 3 * n - 2 * t - r) * o + t * e + i
    }

    function zn(e, t, i, n) {
        var r = 1 - e;
        return r * r * t + 2 * (1 - e) * e * i + e * e * n
    }

    function Bn(e, t, i, n, r) {
        var o = 1 - e,
            s = 1 - e;
        return o * o * o * t + 3 * s * s * e * i + 3 * (1 - e) * e * e * n + e * e * e * r
    }

    function Nn(e, t, n, r) {
        Pn.call(this), this.type = "CubicBezierCurve", this.v0 = e || new i, this.v1 = t || new i, this.v2 = n || new i, this.v3 = r || new i
    }

    function Fn(e, t, i, n) {
        Pn.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new r, this.v1 = t || new r, this.v2 = i || new r, this.v3 = n || new r
    }

    function Hn(e, t) {
        Pn.call(this), this.type = "LineCurve", this.v1 = e || new i, this.v2 = t || new i
    }

    function Un(e, t) {
        Pn.call(this), this.type = "LineCurve3", this.v1 = e || new r, this.v2 = t || new r
    }

    function jn(e, t, n) {
        Pn.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new i, this.v1 = t || new i, this.v2 = n || new i
    }

    function Gn(e, t, i) {
        Pn.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new r, this.v1 = t || new r, this.v2 = i || new r
    }

    function Vn(e) {
        Pn.call(this), this.type = "SplineCurve", this.points = e || []
    }

    function Wn() {
        Pn.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function qn(e) {
        Wn.call(this), this.type = "Path", this.currentPoint = new i, e && this.setFromPoints(e)
    }

    function Xn(e) {
        qn.call(this, e), this.uuid = ho.generateUUID(), this.type = "Shape", this.holes = []
    }

    function Yn(e, t) {
        S.call(this), this.type = "Light", this.color = new b(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
    }

    function Zn(e, t, i) {
        Yn.call(this, e, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(S.DefaultUp), this.updateMatrix(), this.groundColor = new b(t)
    }

    function Qn(e) {
        this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.matrix = new g
    }

    function Jn() {
        Qn.call(this, new wt(50, 1, .5, 500))
    }

    function Kn(e, t, i, n, r, o) {
        Yn.call(this, e, t), this.type = "SpotLight", this.position.copy(S.DefaultUp), this.updateMatrix(), this.target = new S, Object.defineProperty(this, "power", {
            get: function () {
                return this.intensity * Math.PI
            },
            set: function (e) {
                this.intensity = e / Math.PI
            }
        }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Jn
    }

    function $n(e, t, i, n) {
        Yn.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function () {
                return 4 * this.intensity * Math.PI
            },
            set: function (e) {
                this.intensity = e / (4 * Math.PI)
            }
        }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new Qn(new wt(90, 1, .5, 500))
    }

    function er(e, t, i, n, r, o) {
        xt.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }

    function tr() {
        Qn.call(this, new er(-5, 5, 5, -5, .5, 500))
    }

    function ir(e, t) {
        Yn.call(this, e, t), this.type = "DirectionalLight", this.position.copy(S.DefaultUp), this.updateMatrix(), this.target = new S, this.shadow = new tr
    }

    function nr(e, t) {
        Yn.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
    }

    function rr(e, t, i, n) {
        Yn.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
    }

    function or(e) {
        this.manager = void 0 !== e ? e : Xo, this.textures = {}
    }

    function sr() {
        F.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function ar(e, t, i, n) {
        "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), A.call(this, e, t, i), this.meshPerAttribute = n || 1
    }

    function lr(e) {
        this.manager = void 0 !== e ? e : Xo
    }

    function cr(e) {
        this.manager = void 0 !== e ? e : Xo, this.resourcePath = ""
    }

    function ur(e) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e ? e : Xo, this.options = void 0
    }

    function hr() {
        this.type = "ShapePath", this.color = new b, this.subPaths = [], this.currentPath = null
    }

    function dr(e) {
        this.type = "Font", this.data = e
    }

    function pr(e) {
        this.manager = void 0 !== e ? e : Xo
    }

    function fr() {}

    function mr(e) {
        this.manager = void 0 !== e ? e : Xo
    }

    function gr() {
        this.coefficients = [];
        for (var e = 0; 9 > e; e++) this.coefficients.push(new r)
    }

    function vr(e, t) {
        Yn.call(this, void 0, t), this.sh = void 0 !== e ? e : new gr
    }

    function yr(e, t, i) {
        vr.call(this, void 0, i), e = (new b).set(e), i = (new b).set(t), t = new r(e.r, e.g, e.b), e = new r(i.r, i.g, i.b);
        var n = (i = Math.sqrt(Math.PI)) * Math.sqrt(.75);
        this.sh.coefficients[0].copy(t).add(e).multiplyScalar(i), this.sh.coefficients[1].copy(t).sub(e).multiplyScalar(n)
    }

    function br(e, t) {
        vr.call(this, void 0, t), e = (new b).set(e), this.sh.coefficients[0].set(e.r, e.g, e.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }

    function xr() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new wt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new wt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
    }

    function wr(e, t, i, n) {
        S.call(this), this.type = "CubeCamera";
        var o = new wt(90, 1, e, t);
        o.up.set(0, -1, 0), o.lookAt(new r(1, 0, 0)), this.add(o);
        var s = new wt(90, 1, e, t);
        s.up.set(0, -1, 0), s.lookAt(new r(-1, 0, 0)), this.add(s);
        var a = new wt(90, 1, e, t);
        a.up.set(0, 0, 1), a.lookAt(new r(0, 1, 0)), this.add(a);
        var l = new wt(90, 1, e, t);
        l.up.set(0, 0, -1), l.lookAt(new r(0, -1, 0)), this.add(l);
        var c = new wt(90, 1, e, t);
        c.up.set(0, -1, 0), c.lookAt(new r(0, 0, 1)), this.add(c);
        var h = new wt(90, 1, e, t);
        h.up.set(0, -1, 0), h.lookAt(new r(0, 0, -1)), this.add(h), n = n || {
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        }, this.renderTarget = new u(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function (e, t) {
            null === this.parent && this.updateMatrixWorld();
            var i = e.getRenderTarget(),
                n = this.renderTarget,
                r = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, o), e.setRenderTarget(n, 1), e.render(t, s), e.setRenderTarget(n, 2), e.render(t, a), e.setRenderTarget(n, 3), e.render(t, l), e.setRenderTarget(n, 4), e.render(t, c), n.texture.generateMipmaps = r, e.setRenderTarget(n, 5), e.render(t, h), e.setRenderTarget(i)
        }, this.clear = function (e, t, i, n) {
            for (var r = e.getRenderTarget(), o = this.renderTarget, s = 0; 6 > s; s++) e.setRenderTarget(o, s), e.clear(t, i, n);
            e.setRenderTarget(r)
        }
    }

    function _r(e) {
        this.autoStart = void 0 === e || e, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
    }

    function Er() {
        S.call(this), this.type = "AudioListener", this.context = ls.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
    }

    function Mr(e) {
        S.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
    }

    function Sr(e) {
        Mr.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
    }

    function Tr(e, t) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
    }

    function Ar(e, t, i) {
        switch (this.binding = e, this.valueSize = i, e = Float64Array, t) {
            case "quaternion":
                t = this._slerp;
                break;
            case "string":
            case "bool":
                e = Array, t = this._select;
                break;
            default:
                t = this._lerp
        }
        this.buffer = new e(4 * i), this._mixBufferRegion = t, this.referenceCount = this.useCount = this.cumulativeWeight = 0
    }

    function Cr(e, t, i) {
        i = i || Lr.parseTrackName(t), this._targetGroup = e, this._bindings = e.subscribe_(t, i)
    }

    function Lr(e, t, i) {
        this.path = t, this.parsedPath = i || Lr.parseTrackName(t), this.node = Lr.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
    }

    function Pr() {
        this.uuid = ho.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, i = arguments.length; t !== i; ++t) e[arguments[t].uuid] = t;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                },
                get inUse() {
                    return this.total - n.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }

    function Ir(e, t, i) {
        this._mixer = e, this._clip = t, this._localRoot = i || null, t = (e = t.tracks).length, i = Array(t);
        for (var n = {
                endingStart: 2400,
                endingEnd: 2400
            }, r = 0; r !== t; ++r) {
            var o = e[r].createInterpolant(null);
            i[r] = o, o.settings = n
        }
        this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(t), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
    }

    function Or(e) {
        this._root = e, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
    }

    function Rr(e, t) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = t), this.value = e
    }

    function Dr(e, t, i) {
        Pt.call(this, e, t), this.meshPerAttribute = i || 1
    }

    function kr(e, t, i, n) {
        this.ray = new q(e, t), this.near = i || 0, this.far = n || 1 / 0, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function () {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function zr(e, t) {
        return e.distance - t.distance
    }

    function Br(e, t, i, n) {
        if (!1 !== e.visible && (e.raycast(t, i), !0 === n)) {
            n = 0;
            for (var r = (e = e.children).length; n < r; n++) Br(e[n], t, i, !0)
        }
    }

    function Nr(e, t, i) {
        return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== i ? i : 0, this
    }

    function Fr(e, t, i) {
        return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== i ? i : 0, this
    }

    function Hr(e, t) {
        this.min = void 0 !== e ? e : new i(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new i(-1 / 0, -1 / 0)
    }

    function Ur(e, t) {
        this.start = void 0 !== e ? e : new r, this.end = void 0 !== t ? t : new r
    }

    function jr(e) {
        S.call(this), this.material = e, this.render = function () {}
    }

    function Gr(e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16711680, n = void 0 !== n ? n : 1, t = 0, (i = this.object.geometry) && i.isGeometry ? t = 3 * i.faces.length : i && i.isBufferGeometry && (t = i.attributes.normal.count), i = new F, t = new k(6 * t, 3), i.addAttribute("position", t), Ht.call(this, i, new Nt({
            color: e,
            linewidth: n
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function Vr(e, t) {
        S.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, e = new F, t = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var i = 0, n = 1; 32 > i; i++, n++) {
            var r = i / 32 * Math.PI * 2,
                o = n / 32 * Math.PI * 2;
            t.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1)
        }
        e.addAttribute("position", new k(t, 3)), t = new Nt({
            fog: !1
        }), this.cone = new Ht(e, t), this.add(this.cone), this.update()
    }

    function Wr(e) {
        for (var t = function e(t) {
                var i = [];
                t && t.isBone && i.push(t);
                for (var n = 0; n < t.children.length; n++) i.push.apply(i, e(t.children[n]));
                return i
            }(e), i = new F, n = [], r = [], o = new b(0, 0, 1), s = new b(0, 1, 0), a = 0; a < t.length; a++) {
            var l = t[a];
            l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b))
        }
        i.addAttribute("position", new k(n, 3)), i.addAttribute("color", new k(r, 3)), n = new Nt({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), Ht.call(this, i, n), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }

    function qr(e, t, i) {
        this.light = e, this.light.updateMatrixWorld(), this.color = i, e = new zi(t, 4, 2), t = new Y({
            wireframe: !0,
            fog: !1
        }), Z.call(this, e, t), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }

    function Xr(e, t) {
        this.type = "RectAreaLightHelper", this.light = e, this.color = t, (e = new F).addAttribute("position", new k([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), e.computeBoundingSphere(), t = new Nt({
            fog: !1
        }), Ft.call(this, e, t), (e = new F).addAttribute("position", new k([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), e.computeBoundingSphere(), this.add(new Z(e, new Y({
            side: 1,
            fog: !1
        }))), this.update()
    }

    function Yr(e, t, i) {
        S.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, (e = new ii(t)).rotateY(.5 * Math.PI), this.material = new Y({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = 2), t = e.getAttribute("position"), t = new Float32Array(3 * t.count), e.addAttribute("color", new A(t, 3)), this.add(new Z(e, this.material)), this.update()
    }

    function Zr(e, t) {
        this.lightProbe = e, this.size = t, e = new W({
            defines: {
                GAMMA_OUTPUT: ""
            },
            uniforms: {
                sh: {
                    value: this.lightProbe.sh.coefficients
                },
                intensity: {
                    value: this.lightProbe.intensity
                }
            },
            vertexShader: "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            fragmentShader: "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}"
        }), t = new zi(1, 32, 16), Z.call(this, t, e), this.onBeforeRender()
    }

    function Qr(e, t, i, n) {
        e = e || 10, t = t || 10, i = new b(void 0 !== i ? i : 4473924), n = new b(void 0 !== n ? n : 8947848);
        var r = t / 2,
            o = e / t,
            s = e / 2;
        e = [];
        for (var a = [], l = 0, c = 0, u = -s; l <= t; l++, u += o) {
            e.push(-s, 0, u, s, 0, u), e.push(u, 0, -s, u, 0, s);
            var h = l === r ? i : n;
            h.toArray(a, c), c += 3, h.toArray(a, c), c += 3, h.toArray(a, c), c += 3, h.toArray(a, c), c += 3
        }(t = new F).addAttribute("position", new k(e, 3)), t.addAttribute("color", new k(a, 3)), i = new Nt({
            vertexColors: 2
        }), Ht.call(this, t, i)
    }

    function Jr(e, t, i, n, r, o) {
        e = e || 10, t = t || 16, i = i || 8, n = n || 64, r = new b(void 0 !== r ? r : 4473924), o = new b(void 0 !== o ? o : 8947848);
        var s, a = [],
            l = [];
        for (s = 0; s <= t; s++) {
            var c = s / t * 2 * Math.PI,
                u = Math.sin(c) * e;
            c = Math.cos(c) * e, a.push(0, 0, 0), a.push(u, 0, c);
            var h = 1 & s ? r : o;
            l.push(h.r, h.g, h.b), l.push(h.r, h.g, h.b)
        }
        for (s = 0; s <= i; s++) {
            h = 1 & s ? r : o;
            var d = e - e / i * s;
            for (t = 0; t < n; t++) c = t / n * 2 * Math.PI, u = Math.sin(c) * d, c = Math.cos(c) * d, a.push(u, 0, c), l.push(h.r, h.g, h.b), c = (t + 1) / n * 2 * Math.PI, u = Math.sin(c) * d, c = Math.cos(c) * d, a.push(u, 0, c), l.push(h.r, h.g, h.b)
        }(e = new F).addAttribute("position", new k(a, 3)), e.addAttribute("color", new k(l, 3)), a = new Nt({
            vertexColors: 2
        }), Ht.call(this, e, a)
    }

    function Kr(e, t, i, n) {
        this.audio = e, this.range = t || 1, this.divisionsInnerAngle = i || 16, this.divisionsOuterAngle = n || 2, e = new F, t = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3)), e.addAttribute("position", new A(t, 3)), t = new Nt({
            color: 65280
        }), i = new Nt({
            color: 16776960
        }), Ft.call(this, e, [i, t]), this.update()
    }

    function $r(e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16776960, n = void 0 !== n ? n : 1, t = 0, (i = this.object.geometry) && i.isGeometry ? t = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), i = new F, t = new k(6 * t, 3), i.addAttribute("position", t), Ht.call(this, i, new Nt({
            color: e,
            linewidth: n
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function eo(e, t, i) {
        S.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === t && (t = 1), (e = new F).addAttribute("position", new k([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)), t = new Nt({
            fog: !1
        }), this.lightPlane = new Ft(e, t), this.add(this.lightPlane), (e = new F).addAttribute("position", new k([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ft(e, t), this.add(this.targetLine), this.update()
    }

    function to(e) {
        function t(e, t, n) {
            i(e, n), i(t, n)
        }

        function i(e, t) {
            o.push(0, 0, 0), s.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(o.length / 3 - 1)
        }
        var n = new F,
            r = new Nt({
                color: 16777215,
                vertexColors: 1
            }),
            o = [],
            s = [],
            a = {},
            l = new b(16755200),
            c = new b(16711680),
            u = new b(43775),
            h = new b(16777215),
            d = new b(3355443);
        t("n1", "n2", l), t("n2", "n4", l), t("n4", "n3", l), t("n3", "n1", l), t("f1", "f2", l), t("f2", "f4", l), t("f4", "f3", l), t("f3", "f1", l), t("n1", "f1", l), t("n2", "f2", l), t("n3", "f3", l), t("n4", "f4", l), t("p", "n1", c), t("p", "n2", c), t("p", "n3", c), t("p", "n4", c), t("u1", "u2", u), t("u2", "u3", u), t("u3", "u1", u), t("c", "t", h), t("p", "c", d), t("cn1", "cn2", d), t("cn3", "cn4", d), t("cf1", "cf2", d), t("cf3", "cf4", d), n.addAttribute("position", new k(o, 3)), n.addAttribute("color", new k(s, 3)), Ht.call(this, n, r), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
    }

    function io(e, t) {
        this.object = e, void 0 === t && (t = 16776960), e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new Float32Array(24),
            n = new F;
        n.setIndex(new A(e, 1)), n.addAttribute("position", new A(i, 3)), Ht.call(this, n, new Nt({
            color: t
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function no(e, t) {
        this.type = "Box3Helper", this.box = e, e = void 0 !== t ? t : 16776960, t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new F;
        i.setIndex(new A(t, 1)), i.addAttribute("position", new k([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Ht.call(this, i, new Nt({
            color: e
        })), this.geometry.computeBoundingSphere()
    }

    function ro(e, t, i) {
        this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t, e = void 0 !== i ? i : 16776960, (t = new F).addAttribute("position", new k([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), t.computeBoundingSphere(), Ft.call(this, t, new Nt({
            color: e
        })), (t = new F).addAttribute("position", new k([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), t.computeBoundingSphere(), this.add(new Z(t, new Y({
            color: e,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }

    function oo(e, t, i, n, o, s) {
        S.call(this), void 0 === e && (e = new r(0, 0, 1)), void 0 === t && (t = new r(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === o && (o = .2 * i), void 0 === s && (s = .2 * o), void 0 === ss && ((ss = new F).addAttribute("position", new k([0, 0, 0, 0, 1, 0], 3)), (as = new qi(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new Ft(ss, new Nt({
            color: n
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Z(as, new Y({
            color: n
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, o, s)
    }

    function so(e) {
        var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e];
        (e = new F).addAttribute("position", new k(t, 3)), e.addAttribute("color", new k([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), t = new Nt({
            vertexColors: 2
        }), Ht.call(this, e, t)
    }

    function ao(e) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Dn.call(this, e), this.type = "catmullrom", this.closed = !0
    }

    function lo(e) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Dn.call(this, e), this.type = "catmullrom"
    }

    function co(e) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Dn.call(this, e), this.type = "catmullrom"
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }), void 0 === Math.sign && (Math.sign = function (e) {
        return 0 > e ? -1 : 0 < e ? 1 : +e
    }), !1 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
        get: function () {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && (Object.assign = function (e) {
        if (null == e) throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), i = 1; i < arguments.length; i++) {
            var n = arguments[i];
            if (null != n)
                for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }), Object.assign(t.prototype, {
        addEventListener: function (e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t)
        },
        hasEventListener: function (e, t) {
            if (void 0 === this._listeners) return !1;
            var i = this._listeners;
            return void 0 !== i[e] && -1 !== i[e].indexOf(t)
        },
        removeEventListener: function (e, t) {
            void 0 !== this._listeners && (void 0 !== (e = this._listeners[e]) && (-1 !== (t = e.indexOf(t)) && e.splice(t, 1)))
        },
        dispatchEvent: function (e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var i = 0, n = (t = t.slice(0)).length; i < n; i++) t[i].call(this, e)
                }
            }
        }
    });
    var uo, ho = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function () {
            for (var e = [], t = 0; 256 > t; t++) e[t] = (16 > t ? "0" : "") + t.toString(16);
            return function () {
                var t = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0;
                return (e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & i] + e[i >> 8 & 255] + "-" + e[i >> 16 & 15 | 64] + e[i >> 24 & 255] + "-" + e[63 & n | 128] + e[n >> 8 & 255] + "-" + e[n >> 16 & 255] + e[n >> 24 & 255] + e[255 & r] + e[r >> 8 & 255] + e[r >> 16 & 255] + e[r >> 24 & 255]).toUpperCase()
            }
        }(),
        clamp: function (e, t, i) {
            return Math.max(t, Math.min(i, e))
        },
        euclideanModulo: function (e, t) {
            return (e % t + t) % t
        },
        mapLinear: function (e, t, i, n, r) {
            return n + (e - t) * (r - n) / (i - t)
        },
        lerp: function (e, t, i) {
            return (1 - i) * e + i * t
        },
        smoothstep: function (e, t, i) {
            return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e)
        },
        smootherstep: function (e, t, i) {
            return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function (e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function (e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function (e) {
            return e * (.5 - Math.random())
        },
        degToRad: function (e) {
            return e * ho.DEG2RAD
        },
        radToDeg: function (e) {
            return e * ho.RAD2DEG
        },
        isPowerOfTwo: function (e) {
            return 0 == (e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function (e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function (e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
    };
    Object.defineProperties(i.prototype, {
        width: {
            get: function () {
                return this.x
            },
            set: function (e) {
                this.x = e
            }
        },
        height: {
            get: function () {
                return this.y
            },
            set: function (e) {
                this.y = e
            }
        }
    }), Object.assign(i.prototype, {
        isVector2: !0,
        set: function (e, t) {
            return this.x = e, this.y = t, this
        },
        setScalar: function (e) {
            return this.y = this.x = e, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y)
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        },
        addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        },
        subScalar: function (e) {
            return this.x -= e, this.y -= e, this
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        },
        multiply: function (e) {
            return this.x *= e.x, this.y *= e.y, this
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this
        },
        divide: function (e) {
            return this.x /= e.x, this.y /= e.y, this
        },
        divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        },
        applyMatrix3: function (e) {
            var t = this.x,
                i = this.y;
            return e = e.elements, this.x = e[0] * t + e[3] * i + e[6], this.y = e[1] * t + e[4] * i + e[7], this
        },
        min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        },
        max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        },
        clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        },
        clampScalar: function (e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
        },
        clampLength: function (e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function () {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y
        },
        cross: function (e) {
            return this.x * e.y - this.y * e.x
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        angle: function () {
            var e = Math.atan2(this.y, this.x);
            return 0 > e && (e += 2 * Math.PI), e
        },
        distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function (e) {
            var t = this.x - e.x;
            return t * t + (e = this.y - e.y) * e
        },
        manhattanDistanceTo: function (e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        },
        lerpVectors: function (e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
        },
        fromBufferAttribute: function (e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
        },
        rotateAround: function (e, t) {
            var i = Math.cos(t);
            t = Math.sin(t);
            var n = this.x - e.x,
                r = this.y - e.y;
            return this.x = n * i - r * t + e.x, this.y = n * t + r * i + e.y, this
        }
    }), Object.assign(n, {
        slerp: function (e, t, i, n) {
            return i.copy(e).slerp(t, n)
        },
        slerpFlat: function (e, t, i, n, r, o, s) {
            var a = i[n + 0],
                l = i[n + 1],
                c = i[n + 2];
            i = i[n + 3], n = r[o + 0];
            var u = r[o + 1],
                h = r[o + 2];
            if (i !== (r = r[o + 3]) || a !== n || l !== u || c !== h) {
                o = 1 - s;
                var d = a * n + l * u + c * h + i * r,
                    p = 0 <= d ? 1 : -1,
                    f = 1 - d * d;
                f > Number.EPSILON && (f = Math.sqrt(f), d = Math.atan2(f, d * p), o = Math.sin(o * d) / f, s = Math.sin(s * d) / f), a = a * o + n * (p *= s), l = l * o + u * p, c = c * o + h * p, i = i * o + r * p, o === 1 - s && (a *= s = 1 / Math.sqrt(a * a + l * l + c * c + i * i), l *= s, c *= s, i *= s)
            }
            e[t] = a, e[t + 1] = l, e[t + 2] = c, e[t + 3] = i
        }
    }), Object.defineProperties(n.prototype, {
        x: {
            get: function () {
                return this._x
            },
            set: function (e) {
                this._x = e, this.onChangeCallback()
            }
        },
        y: {
            get: function () {
                return this._y
            },
            set: function (e) {
                this._y = e, this.onChangeCallback()
            }
        },
        z: {
            get: function () {
                return this._z
            },
            set: function (e) {
                this._z = e, this.onChangeCallback()
            }
        },
        w: {
            get: function () {
                return this._w
            },
            set: function (e) {
                this._w = e, this.onChangeCallback()
            }
        }
    }), Object.assign(n.prototype, {
        isQuaternion: !0,
        set: function (e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._w = n, this.onChangeCallback(), this
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function (e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
        },
        setFromEuler: function (e, t) {
            if (!e || !e.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var i = e._x,
                n = e._y,
                r = e._z;
            e = e.order;
            var o = Math.cos,
                s = Math.sin,
                a = o(i / 2),
                l = o(n / 2);
            return o = o(r / 2), i = s(i / 2), n = s(n / 2), r = s(r / 2), "XYZ" === e ? (this._x = i * l * o + a * n * r, this._y = a * n * o - i * l * r, this._z = a * l * r + i * n * o, this._w = a * l * o - i * n * r) : "YXZ" === e ? (this._x = i * l * o + a * n * r, this._y = a * n * o - i * l * r, this._z = a * l * r - i * n * o, this._w = a * l * o + i * n * r) : "ZXY" === e ? (this._x = i * l * o - a * n * r, this._y = a * n * o + i * l * r, this._z = a * l * r + i * n * o, this._w = a * l * o - i * n * r) : "ZYX" === e ? (this._x = i * l * o - a * n * r, this._y = a * n * o + i * l * r, this._z = a * l * r - i * n * o, this._w = a * l * o + i * n * r) : "YZX" === e ? (this._x = i * l * o + a * n * r, this._y = a * n * o + i * l * r, this._z = a * l * r - i * n * o, this._w = a * l * o - i * n * r) : "XZY" === e && (this._x = i * l * o - a * n * r, this._y = a * n * o - i * l * r, this._z = a * l * r + i * n * o, this._w = a * l * o + i * n * r), !1 !== t && this.onChangeCallback(), this
        },
        setFromAxisAngle: function (e, t) {
            t /= 2;
            var i = Math.sin(t);
            return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(t), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function (e) {
            var t = e.elements,
                i = t[0];
            e = t[4];
            var n = t[8],
                r = t[1],
                o = t[5],
                s = t[9],
                a = t[2],
                l = t[6],
                c = i + o + (t = t[10]);
            return 0 < c ? (i = .5 / Math.sqrt(c + 1), this._w = .25 / i, this._x = (l - s) * i, this._y = (n - a) * i, this._z = (r - e) * i) : i > o && i > t ? (i = 2 * Math.sqrt(1 + i - o - t), this._w = (l - s) / i, this._x = .25 * i, this._y = (e + r) / i, this._z = (n + a) / i) : o > t ? (i = 2 * Math.sqrt(1 + o - i - t), this._w = (n - a) / i, this._x = (e + r) / i, this._y = .25 * i, this._z = (s + l) / i) : (i = 2 * Math.sqrt(1 + t - i - o), this._w = (r - e) / i, this._x = (n + a) / i, this._y = (s + l) / i, this._z = .25 * i), this.onChangeCallback(), this
        },
        setFromUnitVectors: function (e, t) {
            var i = e.dot(t) + 1;
            return 1e-6 > i ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = i, this.normalize()
        },
        angleTo: function (e) {
            return 2 * Math.acos(Math.abs(ho.clamp(this.dot(e), -1, 1)))
        },
        rotateTowards: function (e, t) {
            var i = this.angleTo(e);
            return 0 === i || this.slerp(e, Math.min(1, t / i)), this
        },
        inverse: function () {
            return this.conjugate()
        },
        conjugate: function () {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function (e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function () {
            var e = this.length();
            return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e), this.onChangeCallback(), this
        },
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        premultiply: function (e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function (e, t) {
            var i = e._x,
                n = e._y,
                r = e._z;
            e = e._w;
            var o = t._x,
                s = t._y,
                a = t._z;
            return t = t._w, this._x = i * t + e * o + n * a - r * s, this._y = n * t + e * s + r * o - i * a, this._z = r * t + e * a + i * s - n * o, this._w = e * t - i * o - n * s - r * a, this.onChangeCallback(), this
        },
        slerp: function (e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            var i = this._x,
                n = this._y,
                r = this._z,
                o = this._w,
                s = o * e._w + i * e._x + n * e._y + r * e._z;
            if (0 > s ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), 1 <= s) return this._w = o, this._x = i, this._y = n, this._z = r, this;
            if ((e = 1 - s * s) <= Number.EPSILON) return s = 1 - t, this._w = s * o + t * this._w, this._x = s * i + t * this._x, this._y = s * n + t * this._y, this._z = s * r + t * this._z, this.normalize();
            e = Math.sqrt(e);
            var a = Math.atan2(e, s);
            return s = Math.sin((1 - t) * a) / e, t = Math.sin(t * a) / e, this._w = o * s + this._w * t, this._x = i * s + this._x * t, this._y = n * s + this._y * t, this._z = r * s + this._z * t, this.onChangeCallback(), this
        },
        equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        },
        onChange: function (e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function () {}
    }), Object.assign(r.prototype, {
        isVector3: !0,
        set: function (e, t, i) {
            return this.x = e, this.y = t, this.z = i, this
        },
        setScalar: function (e) {
            return this.z = this.y = this.x = e, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setZ: function (e) {
            return this.z = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this.z += e, this
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        },
        addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        },
        subScalar: function (e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        },
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        },
        multiplyVectors: function (e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        },
        applyEuler: (uo = new n, function (e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(uo.setFromEuler(e))
        }),
        applyAxisAngle: function () {
            var e = new n;
            return function (t, i) {
                return this.applyQuaternion(e.setFromAxisAngle(t, i))
            }
        }(),
        applyMatrix3: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            return e = e.elements, this.x = e[0] * t + e[3] * i + e[6] * n, this.y = e[1] * t + e[4] * i + e[7] * n, this.z = e[2] * t + e[5] * i + e[8] * n, this
        },
        applyMatrix4: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = 1 / ((e = e.elements)[3] * t + e[7] * i + e[11] * n + e[15]);
            return this.x = (e[0] * t + e[4] * i + e[8] * n + e[12]) * r, this.y = (e[1] * t + e[5] * i + e[9] * n + e[13]) * r, this.z = (e[2] * t + e[6] * i + e[10] * n + e[14]) * r, this
        },
        applyQuaternion: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = e.x,
                o = e.y,
                s = e.z,
                a = (e = e.w) * t + o * n - s * i,
                l = e * i + s * t - r * n,
                c = e * n + r * i - o * t;
            return t = -r * t - o * i - s * n, this.x = a * e + t * -r + l * -s - c * -o, this.y = l * e + t * -o + c * -r - a * -s, this.z = c * e + t * -s + a * -o - l * -r, this
        },
        project: function (e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        },
        unproject: function (e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        },
        transformDirection: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n, this.y = e[1] * t + e[5] * i + e[9] * n, this.z = e[2] * t + e[6] * i + e[10] * n, this.normalize()
        },
        divide: function (e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        },
        divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        },
        min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        },
        max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        },
        clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
        },
        clampScalar: function (e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
        },
        clampLength: function (e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function () {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        },
        lerpVectors: function (e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        cross: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
        },
        crossVectors: function (e, t) {
            var i = e.x,
                n = e.y;
            e = e.z;
            var r = t.x,
                o = t.y;
            return t = t.z, this.x = n * t - e * o, this.y = e * r - i * t, this.z = i * o - n * r, this
        },
        projectOnVector: function (e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t)
        },
        projectOnPlane: function () {
            var e = new r;
            return function (t) {
                return e.copy(this).projectOnVector(t), this.sub(e)
            }
        }(),
        reflect: function () {
            var e = new r;
            return function (t) {
                return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
            }
        }(),
        angleTo: function (e) {
            return e = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq()), Math.acos(ho.clamp(e, -1, 1))
        },
        distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function (e) {
            var t = this.x - e.x,
                i = this.y - e.y;
            return t * t + i * i + (e = this.z - e.z) * e
        },
        manhattanDistanceTo: function (e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function (e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        },
        setFromSphericalCoords: function (e, t, i) {
            var n = Math.sin(t) * e;
            return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this
        },
        setFromCylindrical: function (e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        },
        setFromCylindricalCoords: function (e, t, i) {
            return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
        },
        setFromMatrixPosition: function (e) {
            return e = e.elements, this.x = e[12], this.y = e[13], this.z = e[14], this
        },
        setFromMatrixScale: function (e) {
            var t = this.setFromMatrixColumn(e, 0).length(),
                i = this.setFromMatrixColumn(e, 1).length();
            return e = this.setFromMatrixColumn(e, 2).length(), this.x = t, this.y = i, this.z = e, this
        },
        setFromMatrixColumn: function (e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        },
        fromBufferAttribute: function (e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
    }), Object.assign(o.prototype, {
        isMatrix3: !0,
        set: function (e, t, i, n, r, o, s, a, l) {
            var c = this.elements;
            return c[0] = e, c[1] = n, c[2] = s, c[3] = t, c[4] = r, c[5] = a, c[6] = i, c[7] = o, c[8] = l, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function () {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function (e) {
            var t = this.elements;
            return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], this
        },
        setFromMatrix4: function (e) {
            return e = e.elements, this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        },
        applyToBufferAttribute: function () {
            var e = new r;
            return function (t) {
                for (var i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix3(this), t.setXYZ(i, e.x, e.y, e.z);
                return t
            }
        }(),
        multiply: function (e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function (e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function (e, t) {
            var i = e.elements,
                n = t.elements;
            t = this.elements, e = i[0];
            var r = i[3],
                o = i[6],
                s = i[1],
                a = i[4],
                l = i[7],
                c = i[2],
                u = i[5];
            i = i[8];
            var h = n[0],
                d = n[3],
                p = n[6],
                f = n[1],
                m = n[4],
                g = n[7],
                v = n[2],
                y = n[5];
            return n = n[8], t[0] = e * h + r * f + o * v, t[3] = e * d + r * m + o * y, t[6] = e * p + r * g + o * n, t[1] = s * h + a * f + l * v, t[4] = s * d + a * m + l * y, t[7] = s * p + a * g + l * n, t[2] = c * h + u * f + i * v, t[5] = c * d + u * m + i * y, t[8] = c * p + u * g + i * n, this
        },
        multiplyScalar: function (e) {
            var t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        },
        determinant: function () {
            var e = this.elements,
                t = e[0],
                i = e[1],
                n = e[2],
                r = e[3],
                o = e[4],
                s = e[5],
                a = e[6],
                l = e[7];
            return t * o * (e = e[8]) - t * s * l - i * r * e + i * s * a + n * r * l - n * o * a
        },
        getInverse: function (e, t) {
            e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var i = e.elements;
            e = this.elements;
            var n = i[0],
                r = i[1],
                o = i[2],
                s = i[3],
                a = i[4],
                l = i[5],
                c = i[6],
                u = i[7],
                h = (i = i[8]) * a - l * u,
                d = l * c - i * s,
                p = u * s - a * c,
                f = n * h + r * d + o * p;
            if (0 === f) {
                if (!0 === t) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"), this.identity()
            }
            return t = 1 / f, e[0] = h * t, e[1] = (o * u - i * r) * t, e[2] = (l * r - o * a) * t, e[3] = d * t, e[4] = (i * n - o * c) * t, e[5] = (o * s - l * n) * t, e[6] = p * t, e[7] = (r * c - u * n) * t, e[8] = (a * n - r * s) * t, this
        },
        transpose: function () {
            var e = this.elements,
                t = e[1];
            return e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        },
        getNormalMatrix: function (e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function (e) {
            var t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        },
        setUvTransform: function (e, t, i, n, r, o, s) {
            var a = Math.cos(r);
            r = Math.sin(r), this.set(i * a, i * r, -i * (a * o + r * s) + o + e, -n * r, n * a, -n * (-r * o + a * s) + s + t, 0, 0, 1)
        },
        scale: function (e, t) {
            var i = this.elements;
            return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this
        },
        rotate: function (e) {
            var t = Math.cos(e);
            e = Math.sin(e);
            var i = this.elements,
                n = i[0],
                r = i[3],
                o = i[6],
                s = i[1],
                a = i[4],
                l = i[7];
            return i[0] = t * n + e * s, i[3] = t * r + e * a, i[6] = t * o + e * l, i[1] = -e * n + t * s, i[4] = -e * r + t * a, i[7] = -e * o + t * l, this
        },
        translate: function (e, t) {
            var i = this.elements;
            return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this
        },
        equals: function (e) {
            var t = this.elements;
            e = e.elements;
            for (var i = 0; 9 > i; i++)
                if (t[i] !== e[i]) return !1;
            return !0
        },
        fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; 9 > i; i++) this.elements[i] = e[i + t];
            return this
        },
        toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
        }
    });
    var po, fo = {
            getDataURL: function (e) {
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                if (!(e instanceof HTMLCanvasElement)) {
                    void 0 === po && (po = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), po.width = e.width, po.height = e.height;
                    var t = po.getContext("2d");
                    e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height), e = po
                }
                return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
            }
        },
        mo = 0;
    s.DEFAULT_IMAGE = void 0, s.DEFAULT_MAPPING = 300, s.prototype = Object.assign(Object.create(t.prototype), {
        constructor: s,
        isTexture: !0,
        updateMatrix: function () {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
        },
        toJSON: function (e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var n = this.image;
                if (void 0 === n.uuid && (n.uuid = ho.generateUUID()), !t && void 0 === e.images[n.uuid]) {
                    if (Array.isArray(n))
                        for (var r = [], o = 0, s = n.length; o < s; o++) r.push(fo.getDataURL(n[o]));
                    else r = fo.getDataURL(n);
                    e.images[n.uuid] = {
                        uuid: n.uuid,
                        url: r
                    }
                }
                i.image = n.uuid
            }
            return t || (e.textures[this.uuid] = i), i
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function (e) {
            if (300 !== this.mapping) return e;
            if (e.applyMatrix3(this.matrix), 0 > e.x || 1 < e.x) switch (this.wrapS) {
                case 1e3:
                    e.x -= Math.floor(e.x);
                    break;
                case 1001:
                    e.x = 0 > e.x ? 0 : 1;
                    break;
                case 1002:
                    e.x = 1 === Math.abs(Math.floor(e.x) % 2) ? Math.ceil(e.x) - e.x : e.x - Math.floor(e.x)
            }
            if (0 > e.y || 1 < e.y) switch (this.wrapT) {
                case 1e3:
                    e.y -= Math.floor(e.y);
                    break;
                case 1001:
                    e.y = 0 > e.y ? 0 : 1;
                    break;
                case 1002:
                    e.y = 1 === Math.abs(Math.floor(e.y) % 2) ? Math.ceil(e.y) - e.y : e.y - Math.floor(e.y)
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
    }), Object.defineProperty(s.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.assign(a.prototype, {
        isVector4: !0,
        set: function (e, t, i, n) {
            return this.x = e, this.y = t, this.z = i, this.w = n, this
        },
        setScalar: function (e) {
            return this.w = this.z = this.y = this.x = e, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setZ: function (e) {
            return this.z = e, this
        },
        setW: function (e) {
            return this.w = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        },
        addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        },
        subScalar: function (e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        },
        applyMatrix4: function (e) {
            var t = this.x,
                i = this.y,
                n = this.z,
                r = this.w;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n + e[12] * r, this.y = e[1] * t + e[5] * i + e[9] * n + e[13] * r, this.z = e[2] * t + e[6] * i + e[10] * n + e[14] * r, this.w = e[3] * t + e[7] * i + e[11] * n + e[15] * r, this
        },
        divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function (e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        },
        setAxisAngleFromRotationMatrix: function (e) {
            var t = (e = e.elements)[0],
                i = e[4],
                n = e[8],
                r = e[1],
                o = e[5],
                s = e[9],
                a = e[2],
                l = e[6],
                c = e[10];
            return .01 > Math.abs(i - r) && .01 > Math.abs(n - a) && .01 > Math.abs(s - l) ? .1 > Math.abs(i + r) && .1 > Math.abs(n + a) && .1 > Math.abs(s + l) && .1 > Math.abs(t + o + c - 3) ? (this.set(1, 0, 0, 0), this) : (e = Math.PI, c = (c + 1) / 2, i = (i + r) / 4, n = (n + a) / 4, s = (s + l) / 4, (t = (t + 1) / 2) > (o = (o + 1) / 2) && t > c ? .01 > t ? (l = 0, i = a = .707106781) : (a = i / (l = Math.sqrt(t)), i = n / l) : o > c ? .01 > o ? (l = .707106781, a = 0, i = .707106781) : (l = i / (a = Math.sqrt(o)), i = s / a) : .01 > c ? (a = l = .707106781, i = 0) : (l = n / (i = Math.sqrt(c)), a = s / i), this.set(l, a, i, e), this) : (e = Math.sqrt((l - s) * (l - s) + (n - a) * (n - a) + (r - i) * (r - i)), .001 > Math.abs(e) && (e = 1), this.x = (l - s) / e, this.y = (n - a) / e, this.z = (r - i) / e, this.w = Math.acos((t + o + c - 1) / 2), this)
        },
        min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        },
        max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        },
        clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
        },
        clampScalar: function () {
            var e, t;
            return function (i, n) {
                return void 0 === e && (e = new a, t = new a), e.set(i, i, i, i), t.set(n, n, n, n), this.clamp(e, t)
            }
        }(),
        clampLength: function (e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function () {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        },
        lerpVectors: function (e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        },
        fromBufferAttribute: function (e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
    }), l.prototype = Object.assign(Object.create(t.prototype), {
        constructor: l,
        isWebGLRenderTarget: !0,
        setSize: function (e, t) {
            this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), c.prototype = Object.assign(Object.create(l.prototype), {
        constructor: c,
        isWebGLMultisampleRenderTarget: !0,
        copy: function (e) {
            return l.prototype.copy.call(this, e), this.samples = e.samples, this
        }
    }), u.prototype = Object.create(l.prototype), u.prototype.constructor = u, u.prototype.isWebGLRenderTargetCube = !0, h.prototype = Object.create(s.prototype), h.prototype.constructor = h, h.prototype.isDataTexture = !0, Object.assign(d.prototype, {
        isBox3: !0,
        set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromArray: function (e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0, a = 0, l = e.length; a < l; a += 3) {
                var c = e[a],
                    u = e[a + 1],
                    h = e[a + 2];
                c < t && (t = c), u < i && (i = u), h < n && (n = h), c > r && (r = c), u > o && (o = u), h > s && (s = h)
            }
            return this.min.set(t, i, n), this.max.set(r, o, s), this
        },
        setFromBufferAttribute: function (e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0, a = 0, l = e.count; a < l; a++) {
                var c = e.getX(a),
                    u = e.getY(a),
                    h = e.getZ(a);
                c < t && (t = c), u < i && (i = u), h < n && (n = h), c > r && (r = c), u > o && (o = u), h > s && (s = h)
            }
            return this.min.set(t, i, n), this.max.set(r, o, s), this
        },
        setFromPoints: function (e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function () {
            var e = new r;
            return function (t, i) {
                return i = e.copy(i).multiplyScalar(.5), this.min.copy(t).sub(i), this.max.copy(t).add(i), this
            }
        }(),
        setFromObject: function (e) {
            return this.makeEmpty(), this.expandByObject(e)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function () {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function (e) {
            return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new r), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function (e) {
            return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new r), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        expandByObject: function () {
            function e(e) {
                var r = e.geometry;
                if (void 0 !== r)
                    if (r.isGeometry)
                        for (r = r.vertices, i = 0, n = r.length; i < n; i++) o.copy(r[i]), o.applyMatrix4(e.matrixWorld), t.expandByPoint(o);
                    else if (r.isBufferGeometry && void 0 !== (r = r.attributes.position))
                    for (i = 0, n = r.count; i < n; i++) o.fromBufferAttribute(r, i).applyMatrix4(e.matrixWorld), t.expandByPoint(o)
            }
            var t, i, n, o = new r;
            return function (i) {
                return t = this, i.updateMatrixWorld(!0), i.traverse(e), this
            }
        }(),
        containsPoint: function (e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function (e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new r), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function (e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        intersectsSphere: function () {
            var e = new r;
            return function (t) {
                return this.clampPoint(t.center, e), e.distanceToSquared(t.center) <= t.radius * t.radius
            }
        }(),
        intersectsPlane: function (e) {
            if (0 < e.normal.x) var t = e.normal.x * this.min.x,
                i = e.normal.x * this.max.x;
            else t = e.normal.x * this.max.x, i = e.normal.x * this.min.x;
            return 0 < e.normal.y ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
        },
        intersectsTriangle: function () {
            function e(e) {
                var r, o = 0;
                for (r = e.length - 3; o <= r; o += 3) {
                    l.fromArray(e, o);
                    var s = u.x * Math.abs(l.x) + u.y * Math.abs(l.y) + u.z * Math.abs(l.z),
                        a = t.dot(l),
                        c = i.dot(l),
                        h = n.dot(l);
                    if (Math.max(-Math.max(a, c, h), Math.min(a, c, h)) > s) return !1
                }
                return !0
            }
            var t = new r,
                i = new r,
                n = new r,
                o = new r,
                s = new r,
                a = new r,
                l = new r,
                c = new r,
                u = new r,
                h = new r;
            return function (r) {
                return !this.isEmpty() && (this.getCenter(c), u.subVectors(this.max, c), t.subVectors(r.a, c), i.subVectors(r.b, c), n.subVectors(r.c, c), o.subVectors(i, t), s.subVectors(n, i), a.subVectors(t, n), !!e(r = [0, -o.z, o.y, 0, -s.z, s.y, 0, -a.z, a.y, o.z, 0, -o.x, s.z, 0, -s.x, a.z, 0, -a.x, -o.y, o.x, 0, -s.y, s.x, 0, -a.y, a.x, 0]) && (!!e(r = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (h.crossVectors(o, s), e(r = [h.x, h.y, h.z]))))
            }
        }(),
        clampPoint: function (e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new r), t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function () {
            var e = new r;
            return function (t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        getBoundingSphere: function () {
            var e = new r;
            return function (t) {
                return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(e).length(), t
            }
        }(),
        intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        applyMatrix4: function () {
            var e = [new r, new r, new r, new r, new r, new r, new r, new r];
            return function (t) {
                return this.isEmpty() || (e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(e)), this
            }
        }(),
        translate: function (e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }), Object.assign(p.prototype, {
        set: function (e, t) {
            return this.center.copy(e), this.radius = t, this
        },
        setFromPoints: function () {
            var e = new d;
            return function (t, i) {
                var n = this.center;
                void 0 !== i ? n.copy(i) : e.setFromPoints(t).getCenter(n);
                for (var r = i = 0, o = t.length; r < o; r++) i = Math.max(i, n.distanceToSquared(t[r]));
                return this.radius = Math.sqrt(i), this
            }
        }(),
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        },
        empty: function () {
            return 0 >= this.radius
        },
        containsPoint: function (e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function (e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function (e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function (e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function (e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function (e, t) {
            var i = this.center.distanceToSquared(e);
            return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new r), t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
        },
        getBoundingBox: function (e) {
            return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new d), e.set(this.center, this.center), e.expandByScalar(this.radius), e
        },
        applyMatrix4: function (e) {
            return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this
        },
        translate: function (e) {
            return this.center.add(e), this
        },
        equals: function (e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    }), Object.assign(f.prototype, {
        set: function (e, t) {
            return this.normal.copy(e), this.constant = t, this
        },
        setComponents: function (e, t, i, n) {
            return this.normal.set(e, t, i), this.constant = n, this
        },
        setFromNormalAndCoplanarPoint: function (e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        },
        setFromCoplanarPoints: function () {
            var e = new r,
                t = new r;
            return function (i, n, r) {
                return n = e.subVectors(r, n).cross(t.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this
            }
        }(),
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        },
        normalize: function () {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        },
        negate: function () {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function (e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function (e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function (e, t) {
            return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new r), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        },
        intersectLine: function () {
            var e = new r;
            return function (t, i) {
                void 0 === i && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new r);
                var n = t.delta(e),
                    o = this.normal.dot(n);
                if (0 === o) {
                    if (0 === this.distanceToPoint(t.start)) return i.copy(t.start)
                } else if (!(0 > (o = -(t.start.dot(this.normal) + this.constant) / o) || 1 < o)) return i.copy(n).multiplyScalar(o).add(t.start)
            }
        }(),
        intersectsLine: function (e) {
            var t = this.distanceToPoint(e.start);
            return e = this.distanceToPoint(e.end), 0 > t && 0 < e || 0 > e && 0 < t
        },
        intersectsBox: function (e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function (e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function (e) {
            return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new r), e.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function () {
            var e = new r,
                t = new o;
            return function (i, n) {
                return n = n || t.getNormalMatrix(i), i = this.coplanarPoint(e).applyMatrix4(i), n = this.normal.applyMatrix3(n).normalize(), this.constant = -i.dot(n), this
            }
        }(),
        translate: function (e) {
            return this.constant -= e.dot(this.normal), this
        },
        equals: function (e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    }), Object.assign(m.prototype, {
        set: function (e, t, i, n, r, o) {
            var s = this.planes;
            return s[0].copy(e), s[1].copy(t), s[2].copy(i), s[3].copy(n), s[4].copy(r), s[5].copy(o), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            for (var t = this.planes, i = 0; 6 > i; i++) t[i].copy(e.planes[i]);
            return this
        },
        setFromMatrix: function (e) {
            var t = this.planes,
                i = e.elements;
            e = i[0];
            var n = i[1],
                r = i[2],
                o = i[3],
                s = i[4],
                a = i[5],
                l = i[6],
                c = i[7],
                u = i[8],
                h = i[9],
                d = i[10],
                p = i[11],
                f = i[12],
                m = i[13],
                g = i[14];
            return i = i[15], t[0].setComponents(o - e, c - s, p - u, i - f).normalize(), t[1].setComponents(o + e, c + s, p + u, i + f).normalize(), t[2].setComponents(o + n, c + a, p + h, i + m).normalize(), t[3].setComponents(o - n, c - a, p - h, i - m).normalize(), t[4].setComponents(o - r, c - l, p - d, i - g).normalize(), t[5].setComponents(o + r, c + l, p + d, i + g).normalize(), this
        },
        intersectsObject: function () {
            var e = new p;
            return function (t) {
                var i = t.geometry;
                return null === i.boundingSphere && i.computeBoundingSphere(), e.copy(i.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
            }
        }(),
        intersectsSprite: function () {
            var e = new p;
            return function (t) {
                return e.center.set(0, 0, 0), e.radius = .7071067811865476, e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
            }
        }(),
        intersectsSphere: function (e) {
            var t = this.planes,
                i = e.center;
            e = -e.radius;
            for (var n = 0; 6 > n; n++)
                if (t[n].distanceToPoint(i) < e) return !1;
            return !0
        },
        intersectsBox: function () {
            var e = new r;
            return function (t) {
                for (var i = this.planes, n = 0; 6 > n; n++) {
                    var r = i[n];
                    if (e.x = 0 < r.normal.x ? t.max.x : t.min.x, e.y = 0 < r.normal.y ? t.max.y : t.min.y, e.z = 0 < r.normal.z ? t.max.z : t.min.z, 0 > r.distanceToPoint(e)) return !1
                }
                return !0
            }
        }(),
        containsPoint: function (e) {
            for (var t = this.planes, i = 0; 6 > i; i++)
                if (0 > t[i].distanceToPoint(e)) return !1;
            return !0
        }
    }), Object.assign(g.prototype, {
        isMatrix4: !0,
        set: function (e, t, i, n, r, o, s, a, l, c, u, h, d, p, f, m) {
            var g = this.elements;
            return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = o, g[9] = s, g[13] = a, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function () {
            return (new g).fromArray(this.elements)
        },
        copy: function (e) {
            var t = this.elements;
            return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], this
        },
        copyPosition: function (e) {
            var t = this.elements;
            return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this
        },
        extractBasis: function (e, t, i) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function (e, t, i) {
            return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function () {
            var e = new r;
            return function (t) {
                var i = this.elements,
                    n = t.elements,
                    r = 1 / e.setFromMatrixColumn(t, 0).length(),
                    o = 1 / e.setFromMatrixColumn(t, 1).length();
                return t = 1 / e.setFromMatrixColumn(t, 2).length(), i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = 0, i[4] = n[4] * o, i[5] = n[5] * o, i[6] = n[6] * o, i[7] = 0, i[8] = n[8] * t, i[9] = n[9] * t, i[10] = n[10] * t, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this
            }
        }(),
        makeRotationFromEuler: function (e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements,
                i = e.x,
                n = e.y,
                r = e.z,
                o = Math.cos(i);
            i = Math.sin(i);
            var s = Math.cos(n);
            n = Math.sin(n);
            var a = Math.cos(r);
            if (r = Math.sin(r), "XYZ" === e.order) {
                e = o * a;
                var l = o * r,
                    c = i * a,
                    u = i * r;
                t[0] = s * a, t[4] = -s * r, t[8] = n, t[1] = l + c * n, t[5] = e - u * n, t[9] = -i * s, t[2] = u - e * n, t[6] = c + l * n, t[10] = o * s
            } else "YXZ" === e.order ? (e = s * a, l = s * r, c = n * a, u = n * r, t[0] = e + u * i, t[4] = c * i - l, t[8] = o * n, t[1] = o * r, t[5] = o * a, t[9] = -i, t[2] = l * i - c, t[6] = u + e * i, t[10] = o * s) : "ZXY" === e.order ? (e = s * a, l = s * r, c = n * a, u = n * r, t[0] = e - u * i, t[4] = -o * r, t[8] = c + l * i, t[1] = l + c * i, t[5] = o * a, t[9] = u - e * i, t[2] = -o * n, t[6] = i, t[10] = o * s) : "ZYX" === e.order ? (e = o * a, l = o * r, c = i * a, u = i * r, t[0] = s * a, t[4] = c * n - l, t[8] = e * n + u, t[1] = s * r, t[5] = u * n + e, t[9] = l * n - c, t[2] = -n, t[6] = i * s, t[10] = o * s) : "YZX" === e.order ? (e = o * s, l = o * n, c = i * s, u = i * n, t[0] = s * a, t[4] = u - e * r, t[8] = c * r + l, t[1] = r, t[5] = o * a, t[9] = -i * a, t[2] = -n * a, t[6] = l * r + c, t[10] = e - u * r) : "XZY" === e.order && (e = o * s, l = o * n, c = i * s, u = i * n, t[0] = s * a, t[4] = -r, t[8] = n * a, t[1] = e * r + u, t[5] = o * a, t[9] = l * r - c, t[2] = c * r - l, t[6] = i * a, t[10] = u * r + e);
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        makeRotationFromQuaternion: function () {
            var e = new r(0, 0, 0),
                t = new r(1, 1, 1);
            return function (i) {
                return this.compose(e, i, t)
            }
        }(),
        lookAt: function () {
            var e = new r,
                t = new r,
                i = new r;
            return function (n, r, o) {
                var s = this.elements;
                return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), e.crossVectors(o, i), 0 === e.lengthSq() && (1 === Math.abs(o.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), e.crossVectors(o, i)), e.normalize(), t.crossVectors(i, e), s[0] = e.x, s[4] = t.x, s[8] = i.x, s[1] = e.y, s[5] = t.y, s[9] = i.y, s[2] = e.z, s[6] = t.z, s[10] = i.z, this
            }
        }(),
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        premultiply: function (e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function (e, t) {
            var i = e.elements,
                n = t.elements;
            t = this.elements, e = i[0];
            var r = i[4],
                o = i[8],
                s = i[12],
                a = i[1],
                l = i[5],
                c = i[9],
                u = i[13],
                h = i[2],
                d = i[6],
                p = i[10],
                f = i[14],
                m = i[3],
                g = i[7],
                v = i[11];
            i = i[15];
            var y = n[0],
                b = n[4],
                x = n[8],
                w = n[12],
                _ = n[1],
                E = n[5],
                M = n[9],
                S = n[13],
                T = n[2],
                A = n[6],
                C = n[10],
                L = n[14],
                P = n[3],
                I = n[7],
                O = n[11];
            return n = n[15], t[0] = e * y + r * _ + o * T + s * P, t[4] = e * b + r * E + o * A + s * I, t[8] = e * x + r * M + o * C + s * O, t[12] = e * w + r * S + o * L + s * n, t[1] = a * y + l * _ + c * T + u * P, t[5] = a * b + l * E + c * A + u * I, t[9] = a * x + l * M + c * C + u * O, t[13] = a * w + l * S + c * L + u * n, t[2] = h * y + d * _ + p * T + f * P, t[6] = h * b + d * E + p * A + f * I, t[10] = h * x + d * M + p * C + f * O, t[14] = h * w + d * S + p * L + f * n, t[3] = m * y + g * _ + v * T + i * P, t[7] = m * b + g * E + v * A + i * I, t[11] = m * x + g * M + v * C + i * O, t[15] = m * w + g * S + v * L + i * n, this
        },
        multiplyScalar: function (e) {
            var t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        },
        applyToBufferAttribute: function () {
            var e = new r;
            return function (t) {
                for (var i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix4(this), t.setXYZ(i, e.x, e.y, e.z);
                return t
            }
        }(),
        determinant: function () {
            var e = this.elements,
                t = e[0],
                i = e[4],
                n = e[8],
                r = e[12],
                o = e[1],
                s = e[5],
                a = e[9],
                l = e[13],
                c = e[2],
                u = e[6],
                h = e[10],
                d = e[14];
            return e[3] * (+r * a * u - n * l * u - r * s * h + i * l * h + n * s * d - i * a * d) + e[7] * (+t * a * d - t * l * h + r * o * h - n * o * d + n * l * c - r * a * c) + e[11] * (+t * l * u - t * s * d - r * o * u + i * o * d + r * s * c - i * l * c) + e[15] * (-n * s * c - t * a * u + t * s * h + n * o * u - i * o * h + i * a * c)
        },
        transpose: function () {
            var e = this.elements,
                t = e[1];
            return e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        },
        setPosition: function (e, t, i) {
            var n = this.elements;
            return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this
        },
        getInverse: function (e, t) {
            var i = this.elements,
                n = e.elements;
            e = n[0];
            var r = n[1],
                o = n[2],
                s = n[3],
                a = n[4],
                l = n[5],
                c = n[6],
                u = n[7],
                h = n[8],
                d = n[9],
                p = n[10],
                f = n[11],
                m = n[12],
                g = n[13],
                v = n[14],
                y = d * v * u - g * p * u + g * c * f - l * v * f - d * c * (n = n[15]) + l * p * n,
                b = m * p * u - h * v * u - m * c * f + a * v * f + h * c * n - a * p * n,
                x = h * g * u - m * d * u + m * l * f - a * g * f - h * l * n + a * d * n,
                w = m * d * c - h * g * c - m * l * p + a * g * p + h * l * v - a * d * v,
                _ = e * y + r * b + o * x + s * w;
            if (0 === _) {
                if (!0 === t) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"), this.identity()
            }
            return t = 1 / _, i[0] = y * t, i[1] = (g * p * s - d * v * s - g * o * f + r * v * f + d * o * n - r * p * n) * t, i[2] = (l * v * s - g * c * s + g * o * u - r * v * u - l * o * n + r * c * n) * t, i[3] = (d * c * s - l * p * s - d * o * u + r * p * u + l * o * f - r * c * f) * t, i[4] = b * t, i[5] = (h * v * s - m * p * s + m * o * f - e * v * f - h * o * n + e * p * n) * t, i[6] = (m * c * s - a * v * s - m * o * u + e * v * u + a * o * n - e * c * n) * t, i[7] = (a * p * s - h * c * s + h * o * u - e * p * u - a * o * f + e * c * f) * t, i[8] = x * t, i[9] = (m * d * s - h * g * s - m * r * f + e * g * f + h * r * n - e * d * n) * t, i[10] = (a * g * s - m * l * s + m * r * u - e * g * u - a * r * n + e * l * n) * t, i[11] = (h * l * s - a * d * s - h * r * u + e * d * u + a * r * f - e * l * f) * t, i[12] = w * t, i[13] = (h * g * o - m * d * o + m * r * p - e * g * p - h * r * v + e * d * v) * t, i[14] = (m * l * o - a * g * o - m * r * c + e * g * c + a * r * v - e * l * v) * t, i[15] = (a * d * o - h * l * o + h * r * c - e * d * c - a * r * p + e * l * p) * t, this
        },
        scale: function (e) {
            var t = this.elements,
                i = e.x,
                n = e.y;
            return e = e.z, t[0] *= i, t[4] *= n, t[8] *= e, t[1] *= i, t[5] *= n, t[9] *= e, t[2] *= i, t[6] *= n, t[10] *= e, t[3] *= i, t[7] *= n, t[11] *= e, this
        },
        getMaxScaleOnAxis: function () {
            var e = this.elements;
            return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10]))
        },
        makeTranslation: function (e, t, i) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
        },
        makeRotationX: function (e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function (e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function (e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function (e, t) {
            var i = Math.cos(t);
            t = Math.sin(t);
            var n = 1 - i,
                r = e.x,
                o = e.y;
            e = e.z;
            var s = n * r,
                a = n * o;
            return this.set(s * r + i, s * o - t * e, s * e + t * o, 0, s * o + t * e, a * o + i, a * e - t * r, 0, s * e - t * o, a * e + t * r, n * e * e + i, 0, 0, 0, 0, 1), this
        },
        makeScale: function (e, t, i) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
        },
        makeShear: function (e, t, i) {
            return this.set(1, t, i, 0, e, 1, i, 0, e, t, 1, 0, 0, 0, 0, 1), this
        },
        compose: function (e, t, i) {
            var n = this.elements,
                r = t._x,
                o = t._y,
                s = t._z,
                a = t._w,
                l = r + r,
                c = o + o,
                u = s + s;
            t = r * l;
            var h = r * c;
            r *= u;
            var d = o * c;
            o *= u, s *= u, l *= a, c *= a, a *= u, u = i.x;
            var p = i.y;
            return i = i.z, n[0] = (1 - (d + s)) * u, n[1] = (h + a) * u, n[2] = (r - c) * u, n[3] = 0, n[4] = (h - a) * p, n[5] = (1 - (t + s)) * p, n[6] = (o + l) * p, n[7] = 0, n[8] = (r + c) * i, n[9] = (o - l) * i, n[10] = (1 - (t + d)) * i, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this
        },
        decompose: function () {
            var e = new r,
                t = new g;
            return function (i, n, r) {
                var o = this.elements,
                    s = e.set(o[0], o[1], o[2]).length(),
                    a = e.set(o[4], o[5], o[6]).length(),
                    l = e.set(o[8], o[9], o[10]).length();
                0 > this.determinant() && (s = -s), i.x = o[12], i.y = o[13], i.z = o[14], t.copy(this), i = 1 / s, o = 1 / a;
                var c = 1 / l;
                return t.elements[0] *= i, t.elements[1] *= i, t.elements[2] *= i, t.elements[4] *= o, t.elements[5] *= o, t.elements[6] *= o, t.elements[8] *= c, t.elements[9] *= c, t.elements[10] *= c, n.setFromRotationMatrix(t), r.x = s, r.y = a, r.z = l, this
            }
        }(),
        makePerspective: function (e, t, i, n, r, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var s = this.elements;
            return s[0] = 2 * r / (t - e), s[4] = 0, s[8] = (t + e) / (t - e), s[12] = 0, s[1] = 0, s[5] = 2 * r / (i - n), s[9] = (i + n) / (i - n), s[13] = 0, s[2] = 0, s[6] = 0, s[10] = -(o + r) / (o - r), s[14] = -2 * o * r / (o - r), s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
        },
        makeOrthographic: function (e, t, i, n, r, o) {
            var s = this.elements,
                a = 1 / (t - e),
                l = 1 / (i - n),
                c = 1 / (o - r);
            return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -(t + e) * a, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -(i + n) * l, s[2] = 0, s[6] = 0, s[10] = -2 * c, s[14] = -(o + r) * c, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
        },
        equals: function (e) {
            var t = this.elements;
            e = e.elements;
            for (var i = 0; 16 > i; i++)
                if (t[i] !== e[i]) return !1;
            return !0
        },
        fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; 16 > i; i++) this.elements[i] = e[i + t];
            return this
        },
        toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
        }
    });
    var go = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
            lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
            map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
            uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
            shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
        },
        vo = {
            clone: v,
            merge: y
        },
        yo = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
    Object.assign(b.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function (e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        },
        setScalar: function (e) {
            return this.b = this.g = this.r = e, this
        },
        setHex: function (e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        },
        setRGB: function (e, t, i) {
            return this.r = e, this.g = t, this.b = i, this
        },
        setHSL: function () {
            function e(e, t, i) {
                return 0 > i && (i += 1), 1 < i && --i, i < 1 / 6 ? e + 6 * (t - e) * i : .5 > i ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
            }
            return function (t, i, n) {
                return t = ho.euclideanModulo(t, 1), i = ho.clamp(i, 0, 1), n = ho.clamp(n, 0, 1), 0 === i ? this.r = this.g = this.b = n : (n = 2 * n - (i = .5 >= n ? n * (1 + i) : n + i - n * i), this.r = e(n, i, t + 1 / 3), this.g = e(n, i, t), this.b = e(n, i, t - 1 / 3)), this
            }
        }(),
        setStyle: function (e) {
            function t(t) {
                void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            var i;
            if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                var n = i[2];
                switch (i[1]) {
                    case "rgb":
                    case "rgba":
                        if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, t(i[5]), this;
                        if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, t(i[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) {
                            n = parseFloat(i[1]) / 360;
                            var r = parseInt(i[2], 10) / 100,
                                o = parseInt(i[3], 10) / 100;
                            return t(i[5]), this.setHSL(n, r, o)
                        }
                }
            } else if (i = /^#([A-Fa-f0-9]+)$/.exec(e)) {
                if (3 === (n = (i = i[1]).length)) return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
                if (6 === n) return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this
            }
            return e && 0 < e.length && (void 0 !== (i = yo[e]) ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + e)), this
        },
        clone: function () {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function (e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        },
        copyGammaToLinear: function (e, t) {
            return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        },
        copyLinearToGamma: function (e, t) {
            return void 0 === t && (t = 2), t = 0 < t ? 1 / t : 1, this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        },
        convertGammaToLinear: function (e) {
            return this.copyGammaToLinear(this, e), this
        },
        convertLinearToGamma: function (e) {
            return this.copyLinearToGamma(this, e), this
        },
        copySRGBToLinear: function () {
            function e(e) {
                return .04045 > e ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }
            return function (t) {
                return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
            }
        }(),
        copyLinearToSRGB: function () {
            function e(e) {
                return .0031308 > e ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            return function (t) {
                return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
            }
        }(),
        convertSRGBToLinear: function () {
            return this.copySRGBToLinear(this), this
        },
        convertLinearToSRGB: function () {
            return this.copyLinearToSRGB(this), this
        },
        getHex: function () {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function () {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function (e) {
            void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
                h: 0,
                s: 0,
                l: 0
            });
            var t, i = this.r,
                n = this.g,
                r = this.b,
                o = Math.max(i, n, r),
                s = Math.min(i, n, r),
                a = (s + o) / 2;
            if (s === o) s = t = 0;
            else {
                var l = o - s;
                switch (s = .5 >= a ? l / (o + s) : l / (2 - o - s), o) {
                    case i:
                        t = (n - r) / l + (n < r ? 6 : 0);
                        break;
                    case n:
                        t = (r - i) / l + 2;
                        break;
                    case r:
                        t = (i - n) / l + 4
                }
                t /= 6
            }
            return e.h = t, e.s = s, e.l = a, e
        },
        getStyle: function () {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function () {
            var e = {};
            return function (t, i, n) {
                return this.getHSL(e), e.h += t, e.s += i, e.l += n, this.setHSL(e.h, e.s, e.l), this
            }
        }(),
        add: function (e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        },
        addColors: function (e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        },
        addScalar: function (e) {
            return this.r += e, this.g += e, this.b += e, this
        },
        sub: function (e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        },
        multiply: function (e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        },
        multiplyScalar: function (e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        },
        lerp: function (e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        },
        lerpHSL: function () {
            var e = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                t = {
                    h: 0,
                    s: 0,
                    l: 0
                };
            return function (i, n) {
                this.getHSL(e), i.getHSL(t), i = ho.lerp(e.h, t.h, n);
                var r = ho.lerp(e.s, t.s, n);
                return n = ho.lerp(e.l, t.l, n), this.setHSL(i, r, n), this
            }
        }(),
        equals: function (e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        },
        toJSON: function () {
            return this.getHex()
        }
    });
    var bo = {
            common: {
                diffuse: {
                    value: new b(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new o
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new i(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new b(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new b(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new o
                }
            },
            sprite: {
                diffuse: {
                    value: new b(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new i(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new o
                }
            }
        },
        xo = {
            basic: {
                uniforms: y([bo.common, bo.specularmap, bo.envmap, bo.aomap, bo.lightmap, bo.fog]),
                vertexShader: go.meshbasic_vert,
                fragmentShader: go.meshbasic_frag
            },
            lambert: {
                uniforms: y([bo.common, bo.specularmap, bo.envmap, bo.aomap, bo.lightmap, bo.emissivemap, bo.fog, bo.lights, {
                    emissive: {
                        value: new b(0)
                    }
                }]),
                vertexShader: go.meshlambert_vert,
                fragmentShader: go.meshlambert_frag
            },
            phong: {
                uniforms: y([bo.common, bo.specularmap, bo.envmap, bo.aomap, bo.lightmap, bo.emissivemap, bo.bumpmap, bo.normalmap, bo.displacementmap, bo.gradientmap, bo.fog, bo.lights, {
                    emissive: {
                        value: new b(0)
                    },
                    specular: {
                        value: new b(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: go.meshphong_vert,
                fragmentShader: go.meshphong_frag
            },
            standard: {
                uniforms: y([bo.common, bo.envmap, bo.aomap, bo.lightmap, bo.emissivemap, bo.bumpmap, bo.normalmap, bo.displacementmap, bo.roughnessmap, bo.metalnessmap, bo.fog, bo.lights, {
                    emissive: {
                        value: new b(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: go.meshphysical_vert,
                fragmentShader: go.meshphysical_frag
            },
            matcap: {
                uniforms: y([bo.common, bo.bumpmap, bo.normalmap, bo.displacementmap, bo.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: go.meshmatcap_vert,
                fragmentShader: go.meshmatcap_frag
            },
            points: {
                uniforms: y([bo.points, bo.fog]),
                vertexShader: go.points_vert,
                fragmentShader: go.points_frag
            },
            dashed: {
                uniforms: y([bo.common, bo.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: go.linedashed_vert,
                fragmentShader: go.linedashed_frag
            },
            depth: {
                uniforms: y([bo.common, bo.displacementmap]),
                vertexShader: go.depth_vert,
                fragmentShader: go.depth_frag
            },
            normal: {
                uniforms: y([bo.common, bo.bumpmap, bo.normalmap, bo.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: go.normal_vert,
                fragmentShader: go.normal_frag
            },
            sprite: {
                uniforms: y([bo.sprite, bo.fog]),
                vertexShader: go.sprite_vert,
                fragmentShader: go.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new o
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: go.background_vert,
                fragmentShader: go.background_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: go.cube_vert,
                fragmentShader: go.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: go.equirect_vert,
                fragmentShader: go.equirect_frag
            },
            distanceRGBA: {
                uniforms: y([bo.common, bo.displacementmap, {
                    referencePosition: {
                        value: new r
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: go.distanceRGBA_vert,
                fragmentShader: go.distanceRGBA_frag
            },
            shadow: {
                uniforms: y([bo.lights, bo.fog, {
                    color: {
                        value: new b(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: go.shadow_vert,
                fragmentShader: go.shadow_frag
            }
        };
    xo.physical = {
        uniforms: y([xo.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: go.meshphysical_vert,
        fragmentShader: go.meshphysical_frag
    }, Object.assign(_.prototype, {
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
            for (var t = 0, i = e.vertexNormals.length; t < i; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0, i = e.vertexColors.length; t < i; t++) this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    }), E.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), E.DefaultOrder = "XYZ", Object.defineProperties(E.prototype, {
        x: {
            get: function () {
                return this._x
            },
            set: function (e) {
                this._x = e, this.onChangeCallback()
            }
        },
        y: {
            get: function () {
                return this._y
            },
            set: function (e) {
                this._y = e, this.onChangeCallback()
            }
        },
        z: {
            get: function () {
                return this._z
            },
            set: function (e) {
                this._z = e, this.onChangeCallback()
            }
        },
        order: {
            get: function () {
                return this._order
            },
            set: function (e) {
                this._order = e, this.onChangeCallback()
            }
        }
    }), Object.assign(E.prototype, {
        isEuler: !0,
        set: function (e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function (e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function (e, t, i) {
            var n = ho.clamp,
                r = e.elements;
            e = r[0];
            var o = r[4],
                s = r[8],
                a = r[1],
                l = r[5],
                c = r[9],
                u = r[2],
                h = r[6];
            return r = r[10], "XYZ" === (t = t || this._order) ? (this._y = Math.asin(n(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(-c, r), this._z = Math.atan2(-o, e)) : (this._x = Math.atan2(h, l), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(c, -1, 1)), .99999 > Math.abs(c) ? (this._y = Math.atan2(s, r), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-u, e), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(h, -1, 1)), .99999 > Math.abs(h) ? (this._y = Math.atan2(-u, r), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, e))) : "ZYX" === t ? (this._y = Math.asin(-n(u, -1, 1)), .99999 > Math.abs(u) ? (this._x = Math.atan2(h, r), this._z = Math.atan2(a, e)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === t ? (this._z = Math.asin(n(a, -1, 1)), .99999 > Math.abs(a) ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, e)) : (this._x = 0, this._y = Math.atan2(s, r))) : "XZY" === t ? (this._z = Math.asin(-n(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(h, l), this._y = Math.atan2(s, e)) : (this._x = Math.atan2(-c, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== i && this.onChangeCallback(), this
        },
        setFromQuaternion: function () {
            var e = new g;
            return function (t, i, n) {
                return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, i, n)
            }
        }(),
        setFromVector3: function (e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: function () {
            var e = new n;
            return function (t) {
                return e.setFromEuler(this), this.setFromQuaternion(e, t)
            }
        }(),
        equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function (e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        },
        toVector3: function (e) {
            return e ? e.set(this._x, this._y, this._z) : new r(this._x, this._y, this._z)
        },
        onChange: function (e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function () {}
    }), Object.assign(M.prototype, {
        set: function (e) {
            this.mask = 1 << e | 0
        },
        enable: function (e) {
            this.mask = this.mask | 1 << e | 0
        },
        toggle: function (e) {
            this.mask ^= 1 << e | 0
        },
        disable: function (e) {
            this.mask &= ~(1 << e | 0)
        },
        test: function (e) {
            return 0 != (this.mask & e.mask)
        }
    });
    var wo = 0;
    S.DefaultUp = new r(0, 1, 0), S.DefaultMatrixAutoUpdate = !0, S.prototype = Object.assign(Object.create(t.prototype), {
        constructor: S,
        isObject3D: !0,
        onBeforeRender: function () {},
        onAfterRender: function () {},
        applyMatrix: function (e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function (e) {
            return this.quaternion.premultiply(e), this
        },
        setRotationFromAxisAngle: function (e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function (e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function (e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function (e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function () {
            var e = new n;
            return function (t, i) {
                return e.setFromAxisAngle(t, i), this.quaternion.multiply(e), this
            }
        }(),
        rotateOnWorldAxis: function () {
            var e = new n;
            return function (t, i) {
                return e.setFromAxisAngle(t, i), this.quaternion.premultiply(e), this
            }
        }(),
        rotateX: function () {
            var e = new r(1, 0, 0);
            return function (t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateY: function () {
            var e = new r(0, 1, 0);
            return function (t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateZ: function () {
            var e = new r(0, 0, 1);
            return function (t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        translateOnAxis: function () {
            var e = new r;
            return function (t, i) {
                return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(i)), this
            }
        }(),
        translateX: function () {
            var e = new r(1, 0, 0);
            return function (t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateY: function () {
            var e = new r(0, 1, 0);
            return function (t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateZ: function () {
            var e = new r(0, 0, 1);
            return function (t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        localToWorld: function (e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function () {
            var e = new g;
            return function (t) {
                return t.applyMatrix4(e.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function () {
            var e = new n,
                t = new g,
                i = new r,
                o = new r;
            return function (n, r, s) {
                n.isVector3 ? i.copy(n) : i.set(n, r, s), n = this.parent, this.updateWorldMatrix(!0, !1), o.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? t.lookAt(o, i, this.up) : t.lookAt(i, o, this.up), this.quaternion.setFromRotationMatrix(t), n && (t.extractRotation(n.matrixWorld), e.setFromRotationMatrix(t), this.quaternion.premultiply(e.inverse()))
            }
        }(),
        add: function (e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                type: "added"
            }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
        },
        remove: function (e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                return this
            }
            return -1 !== (t = this.children.indexOf(e)) && (e.parent = null, e.dispatchEvent({
                type: "removed"
            }), this.children.splice(t, 1)), this
        },
        attach: function () {
            var e = new g;
            return function (t) {
                return this.updateWorldMatrix(!0, !1), e.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), e.multiply(t.parent.matrixWorld)), t.applyMatrix(e), t.updateWorldMatrix(!1, !1), this.add(t), this
            }
        }(),
        getObjectById: function (e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function (e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function (e, t) {
            if (this[e] === t) return this;
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i].getObjectByProperty(e, t);
                if (void 0 !== r) return r
            }
        },
        getWorldPosition: function (e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new r), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function () {
            var e = new r,
                t = new r;
            return function (i) {
                return void 0 === i && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), i = new n), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, i, t), i
            }
        }(),
        getWorldScale: function () {
            var e = new r,
                t = new n;
            return function (i) {
                return void 0 === i && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), i = new r), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, i), i
            }
        }(),
        getWorldDirection: function (e) {
            void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new r), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        raycast: function () {},
        traverse: function (e) {
            e(this);
            for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverse(e)
        },
        traverseVisible: function (e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e)
            }
        },
        traverseAncestors: function (e) {
            var t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        },
        updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function (e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
            for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e)
        },
        updateWorldMatrix: function (e, t) {
            var i = this.parent;
            if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                for (t = 0, i = (e = this.children).length; t < i; t++) e[t].updateWorldMatrix(!1, !0)
        },
        toJSON: function (e) {
            function t(t, i) {
                return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid
            }

            function i(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    delete n.metadata, i.push(n)
                }
                return i
            }
            var n = void 0 === e || "string" == typeof e,
                r = {};
            n && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, r.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var o = {};
            if (o.uuid = this.uuid, o.type = this.type, "" !== this.name && (o.name = this.name), !0 === this.castShadow && (o.castShadow = !0), !0 === this.receiveShadow && (o.receiveShadow = !0), !1 === this.visible && (o.visible = !1), !1 === this.frustumCulled && (o.frustumCulled = !1), 0 !== this.renderOrder && (o.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData), o.layers = this.layers.mask, o.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (o.matrixAutoUpdate = !1), this.isMesh && 0 !== this.drawMode && (o.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
                o.geometry = t(e.geometries, this.geometry);
                var s = this.geometry.parameters;
                if (void 0 !== s && void 0 !== s.shapes)
                    if (s = s.shapes, Array.isArray(s))
                        for (var a = 0, l = s.length; a < l; a++) t(e.shapes, s[a]);
                    else t(e.shapes, s)
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (s = [], a = 0, l = this.material.length; a < l; a++) s.push(t(e.materials, this.material[a]));
                    o.material = s
                } else o.material = t(e.materials, this.material);
            if (0 < this.children.length)
                for (o.children = [], a = 0; a < this.children.length; a++) o.children.push(this.children[a].toJSON(e).object);
            if (n) {
                n = i(e.geometries), a = i(e.materials), l = i(e.textures);
                var c = i(e.images);
                s = i(e.shapes), 0 < n.length && (r.geometries = n), 0 < a.length && (r.materials = a), 0 < l.length && (r.textures = l), 0 < c.length && (r.images = c), 0 < s.length && (r.shapes = s)
            }
            return r.object = o, r
        },
        clone: function (e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function (e, t) {
            if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                for (t = 0; t < e.children.length; t++) this.add(e.children[t].clone());
            return this
        }
    });
    var _o = 0;
    T.prototype = Object.assign(Object.create(t.prototype), {
        constructor: T,
        isGeometry: !0,
        applyMatrix: function (e) {
            for (var t = (new o).getNormalMatrix(e), i = 0, n = this.vertices.length; i < n; i++) this.vertices[i].applyMatrix4(e);
            for (i = 0, n = this.faces.length; i < n; i++) {
                (e = this.faces[i]).normal.applyMatrix3(t).normalize();
                for (var r = 0, s = e.vertexNormals.length; r < s; r++) e.vertexNormals[r].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
        },
        rotateX: function () {
            var e = new g;
            return function (t) {
                return e.makeRotationX(t), this.applyMatrix(e), this
            }
        }(),
        rotateY: function () {
            var e = new g;
            return function (t) {
                return e.makeRotationY(t), this.applyMatrix(e), this
            }
        }(),
        rotateZ: function () {
            var e = new g;
            return function (t) {
                return e.makeRotationZ(t), this.applyMatrix(e), this
            }
        }(),
        translate: function () {
            var e = new g;
            return function (t, i, n) {
                return e.makeTranslation(t, i, n), this.applyMatrix(e), this
            }
        }(),
        scale: function () {
            var e = new g;
            return function (t, i, n) {
                return e.makeScale(t, i, n), this.applyMatrix(e), this
            }
        }(),
        lookAt: function () {
            var e = new S;
            return function (t) {
                e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
            }
        }(),
        fromBufferGeometry: function (e) {
            function t(e, t, o, s) {
                var a = void 0 === c ? [] : [n.colors[e].clone(), n.colors[t].clone(), n.colors[o].clone()];
                s = new _(e, t, o, void 0 === l ? [] : [(new r).fromArray(l, 3 * e), (new r).fromArray(l, 3 * t), (new r).fromArray(l, 3 * o)], a, s), n.faces.push(s), void 0 !== u && n.faceVertexUvs[0].push([(new i).fromArray(u, 2 * e), (new i).fromArray(u, 2 * t), (new i).fromArray(u, 2 * o)]), void 0 !== h && n.faceVertexUvs[1].push([(new i).fromArray(h, 2 * e), (new i).fromArray(h, 2 * t), (new i).fromArray(h, 2 * o)])
            }
            var n = this,
                o = null !== e.index ? e.index.array : void 0,
                s = e.attributes,
                a = s.position.array,
                l = void 0 !== s.normal ? s.normal.array : void 0,
                c = void 0 !== s.color ? s.color.array : void 0,
                u = void 0 !== s.uv ? s.uv.array : void 0,
                h = void 0 !== s.uv2 ? s.uv2.array : void 0;
            for (void 0 !== h && (this.faceVertexUvs[1] = []), s = 0; s < a.length; s += 3) n.vertices.push((new r).fromArray(a, s)), void 0 !== c && n.colors.push((new b).fromArray(c, s));
            var d = e.groups;
            if (0 < d.length)
                for (s = 0; s < d.length; s++) {
                    var p = (a = d[s]).start,
                        f = p;
                    for (p += a.count; f < p; f += 3) void 0 !== o ? t(o[f], o[f + 1], o[f + 2], a.materialIndex) : t(f, f + 1, f + 2, a.materialIndex)
                } else if (void 0 !== o)
                    for (s = 0; s < o.length; s += 3) t(o[s], o[s + 1], o[s + 2]);
                else
                    for (s = 0; s < a.length / 3; s += 3) t(s, s + 1, s + 2);
            return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        },
        center: function () {
            var e = new r;
            return function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
            }
        }(),
        normalize: function () {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center,
                t = this.boundingSphere.radius;
            t = 0 === t ? 1 : 1 / t;
            var i = new g;
            return i.set(t, 0, 0, -t * e.x, 0, t, 0, -t * e.y, 0, 0, t, -t * e.z, 0, 0, 0, 1), this.applyMatrix(i), this
        },
        computeFaceNormals: function () {
            for (var e = new r, t = new r, i = 0, n = this.faces.length; i < n; i++) {
                var o = this.faces[i],
                    s = this.vertices[o.a],
                    a = this.vertices[o.b];
                e.subVectors(this.vertices[o.c], a), t.subVectors(s, a), e.cross(t), e.normalize(), o.normal.copy(e)
            }
        },
        computeVertexNormals: function (e) {
            var t;
            void 0 === e && (e = !0);
            var i = Array(this.vertices.length),
                n = 0;
            for (t = this.vertices.length; n < t; n++) i[n] = new r;
            if (e) {
                var o = new r,
                    s = new r;
                for (e = 0, n = this.faces.length; e < n; e++) {
                    t = this.faces[e];
                    var a = this.vertices[t.a],
                        l = this.vertices[t.b],
                        c = this.vertices[t.c];
                    o.subVectors(c, l), s.subVectors(a, l), o.cross(s), i[t.a].add(o), i[t.b].add(o), i[t.c].add(o)
                }
            } else
                for (this.computeFaceNormals(), e = 0, n = this.faces.length; e < n; e++) i[(t = this.faces[e]).a].add(t.normal), i[t.b].add(t.normal), i[t.c].add(t.normal);
            for (n = 0, t = this.vertices.length; n < t; n++) i[n].normalize();
            for (e = 0, n = this.faces.length; e < n; e++) 3 === (a = (t = this.faces[e]).vertexNormals).length ? (a[0].copy(i[t.a]), a[1].copy(i[t.b]), a[2].copy(i[t.c])) : (a[0] = i[t.a].clone(), a[1] = i[t.b].clone(), a[2] = i[t.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function () {
            var e;
            this.computeFaceNormals();
            var t = 0;
            for (e = this.faces.length; t < e; t++) {
                var i = this.faces[t],
                    n = i.vertexNormals;
                3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function () {
            var e, t, i = 0;
            for (t = this.faces.length; i < t; i++) {
                var n = this.faces[i];
                n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
                var o = 0;
                for (e = n.vertexNormals.length; o < e; o++) n.__originalVertexNormals[o] ? n.__originalVertexNormals[o].copy(n.vertexNormals[o]) : n.__originalVertexNormals[o] = n.vertexNormals[o].clone()
            }
            var s = new T;
            for (s.faces = this.faces, o = 0, e = this.morphTargets.length; o < e; o++) {
                if (!this.morphNormals[o]) {
                    this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = [], n = this.morphNormals[o].faceNormals;
                    var a = this.morphNormals[o].vertexNormals;
                    for (i = 0, t = this.faces.length; i < t; i++) {
                        var l = new r,
                            c = {
                                a: new r,
                                b: new r,
                                c: new r
                            };
                        n.push(l), a.push(c)
                    }
                }
                for (a = this.morphNormals[o], s.vertices = this.morphTargets[o].vertices, s.computeFaceNormals(), s.computeVertexNormals(), i = 0, t = this.faces.length; i < t; i++) n = this.faces[i], l = a.faceNormals[i], c = a.vertexNormals[i], l.copy(n.normal), c.a.copy(n.vertexNormals[0]), c.b.copy(n.vertexNormals[1]), c.c.copy(n.vertexNormals[2])
            }
            for (i = 0, t = this.faces.length; i < t; i++)(n = this.faces[i]).normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals
        },
        computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new d), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new p), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function (e, t, i) {
            if (e && e.isGeometry) {
                var n, r = this.vertices.length,
                    s = this.vertices,
                    a = e.vertices,
                    l = this.faces,
                    c = e.faces,
                    u = this.faceVertexUvs[0],
                    h = e.faceVertexUvs[0],
                    d = this.colors,
                    p = e.colors;
                void 0 === i && (i = 0), void 0 !== t && (n = (new o).getNormalMatrix(t)), e = 0;
                for (var f = a.length; e < f; e++) {
                    var m = a[e].clone();
                    void 0 !== t && m.applyMatrix4(t), s.push(m)
                }
                for (e = 0, f = p.length; e < f; e++) d.push(p[e].clone());
                for (e = 0, f = c.length; e < f; e++) {
                    var g = (a = c[e]).vertexNormals;
                    for (p = a.vertexColors, (d = new _(a.a + r, a.b + r, a.c + r)).normal.copy(a.normal), void 0 !== n && d.normal.applyMatrix3(n).normalize(), t = 0, s = g.length; t < s; t++) m = g[t].clone(), void 0 !== n && m.applyMatrix3(n).normalize(), d.vertexNormals.push(m);
                    for (d.color.copy(a.color), t = 0, s = p.length; t < s; t++) m = p[t], d.vertexColors.push(m.clone());
                    d.materialIndex = a.materialIndex + i, l.push(d)
                }
                for (e = 0, f = h.length; e < f; e++)
                    if (n = [], void 0 !== (i = h[e])) {
                        for (t = 0, s = i.length; t < s; t++) n.push(i[t].clone());
                        u.push(n)
                    }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
        },
        mergeMesh: function (e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
        },
        mergeVertices: function () {
            var e, t = {},
                i = [],
                n = [],
                r = Math.pow(10, 4),
                o = 0;
            for (e = this.vertices.length; o < e; o++) {
                var s = this.vertices[o];
                void 0 === t[s = Math.round(s.x * r) + "_" + Math.round(s.y * r) + "_" + Math.round(s.z * r)] ? (t[s] = o, i.push(this.vertices[o]), n[o] = i.length - 1) : n[o] = n[t[s]]
            }
            for (t = [], o = 0, e = this.faces.length; o < e; o++)
                for ((r = this.faces[o]).a = n[r.a], r.b = n[r.b], r.c = n[r.c], r = [r.a, r.b, r.c], s = 0; 3 > s; s++)
                    if (r[s] === r[(s + 1) % 3]) {
                        t.push(o);
                        break
                    } for (o = t.length - 1; 0 <= o; o--)
                for (r = t[o], this.faces.splice(r, 1), n = 0, e = this.faceVertexUvs.length; n < e; n++) this.faceVertexUvs[n].splice(r, 1);
            return o = this.vertices.length - i.length, this.vertices = i, o
        },
        setFromPoints: function (e) {
            this.vertices = [];
            for (var t = 0, i = e.length; t < i; t++) {
                var n = e[t];
                this.vertices.push(new r(n.x, n.y, n.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function () {
            for (var e = this.faces, t = e.length, i = 0; i < t; i++) e[i]._id = i;
            e.sort((function (e, t) {
                return e.materialIndex - t.materialIndex
            }));
            var n, r, o = this.faceVertexUvs[0],
                s = this.faceVertexUvs[1];
            for (o && o.length === t && (n = []), s && s.length === t && (r = []), i = 0; i < t; i++) {
                var a = e[i]._id;
                n && n.push(o[a]), r && r.push(s[a])
            }
            n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function () {
            function e(e, t, i) {
                return i ? e | 1 << t : e & ~(1 << t)
            }

            function t(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== c[t] || (c[t] = l.length / 3, l.push(e.x, e.y, e.z)), c[t]
            }

            function i(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== h[t] || (h[t] = u.length, u.push(e.getHex())), h[t]
            }

            function n(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== p[t] || (p[t] = d.length / 2, d.push(e.x, e.y)), p[t]
            }
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                var o, s = this.parameters;
                for (o in s) void 0 !== s[o] && (r[o] = s[o]);
                return r
            }
            for (s = [], o = 0; o < this.vertices.length; o++) {
                var a = this.vertices[o];
                s.push(a.x, a.y, a.z)
            }
            a = [];
            var l = [],
                c = {},
                u = [],
                h = {},
                d = [],
                p = {};
            for (o = 0; o < this.faces.length; o++) {
                var f = this.faces[o],
                    m = void 0 !== this.faceVertexUvs[0][o],
                    g = 0 < f.normal.length(),
                    v = 0 < f.vertexNormals.length,
                    y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                    b = 0 < f.vertexColors.length,
                    x = 0;
                x = e(x, 0, 0), x = e(x, 1, !0), x = e(x, 2, !1), x = e(x, 3, m), x = e(x, 4, g), x = e(x, 5, v), x = e(x, 6, y), x = e(x, 7, b), a.push(x), a.push(f.a, f.b, f.c), a.push(f.materialIndex), m && (m = this.faceVertexUvs[0][o], a.push(n(m[0]), n(m[1]), n(m[2]))), g && a.push(t(f.normal)), v && (g = f.vertexNormals, a.push(t(g[0]), t(g[1]), t(g[2]))), y && a.push(i(f.color)), b && (f = f.vertexColors, a.push(i(f[0]), i(f[1]), i(f[2])))
            }
            return r.data = {}, r.data.vertices = s, r.data.normals = l, 0 < u.length && (r.data.colors = u), 0 < d.length && (r.data.uvs = [d]), r.data.faces = a, r
        },
        clone: function () {
            return (new T).copy(this)
        },
        copy: function (e) {
            var t, i, n;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = e.name;
            var r = e.vertices,
                o = 0;
            for (t = r.length; o < t; o++) this.vertices.push(r[o].clone());
            for (o = 0, t = (r = e.colors).length; o < t; o++) this.colors.push(r[o].clone());
            for (o = 0, t = (r = e.faces).length; o < t; o++) this.faces.push(r[o].clone());
            for (o = 0, t = e.faceVertexUvs.length; o < t; o++) {
                var s = e.faceVertexUvs[o];
                for (void 0 === this.faceVertexUvs[o] && (this.faceVertexUvs[o] = []), r = 0, i = s.length; r < i; r++) {
                    var a = s[r],
                        l = [],
                        c = 0;
                    for (n = a.length; c < n; c++) l.push(a[c].clone());
                    this.faceVertexUvs[o].push(l)
                }
            }
            for (o = 0, t = (c = e.morphTargets).length; o < t; o++) {
                if ((n = {}).name = c[o].name, void 0 !== c[o].vertices)
                    for (n.vertices = [], r = 0, i = c[o].vertices.length; r < i; r++) n.vertices.push(c[o].vertices[r].clone());
                if (void 0 !== c[o].normals)
                    for (n.normals = [], r = 0, i = c[o].normals.length; r < i; r++) n.normals.push(c[o].normals[r].clone());
                this.morphTargets.push(n)
            }
            for (o = 0, t = (c = e.morphNormals).length; o < t; o++) {
                if (n = {}, void 0 !== c[o].vertexNormals)
                    for (n.vertexNormals = [], r = 0, i = c[o].vertexNormals.length; r < i; r++) s = c[o].vertexNormals[r], (a = {}).a = s.a.clone(), a.b = s.b.clone(), a.c = s.c.clone(), n.vertexNormals.push(a);
                if (void 0 !== c[o].faceNormals)
                    for (n.faceNormals = [], r = 0, i = c[o].faceNormals.length; r < i; r++) n.faceNormals.push(c[o].faceNormals[r].clone());
                this.morphNormals.push(n)
            }
            for (o = 0, t = (r = e.skinWeights).length; o < t; o++) this.skinWeights.push(r[o].clone());
            for (o = 0, t = (r = e.skinIndices).length; o < t; o++) this.skinIndices.push(r[o].clone());
            for (o = 0, t = (r = e.lineDistances).length; o < t; o++) this.lineDistances.push(r[o]);
            return null !== (o = e.boundingBox) && (this.boundingBox = o.clone()), null !== (o = e.boundingSphere) && (this.boundingSphere = o.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(A.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.assign(A.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function () {},
        setArray: function (e) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this
        },
        setDynamic: function (e) {
            return this.dynamic = e, this
        },
        copy: function (e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
        },
        copyAt: function (e, t, i) {
            e *= this.itemSize, i *= t.itemSize;
            for (var n = 0, r = this.itemSize; n < r; n++) this.array[e + n] = t.array[i + n];
            return this
        },
        copyArray: function (e) {
            return this.array.set(e), this
        },
        copyColorsArray: function (e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var o = e[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new b), t[i++] = o.r, t[i++] = o.g, t[i++] = o.b
            }
            return this
        },
        copyVector2sArray: function (e) {
            for (var t = this.array, n = 0, r = 0, o = e.length; r < o; r++) {
                var s = e[r];
                void 0 === s && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), s = new i), t[n++] = s.x, t[n++] = s.y
            }
            return this
        },
        copyVector3sArray: function (e) {
            for (var t = this.array, i = 0, n = 0, o = e.length; n < o; n++) {
                var s = e[n];
                void 0 === s && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), s = new r), t[i++] = s.x, t[i++] = s.y, t[i++] = s.z
            }
            return this
        },
        copyVector4sArray: function (e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var o = e[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new a), t[i++] = o.x, t[i++] = o.y, t[i++] = o.z, t[i++] = o.w
            }
            return this
        },
        set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        getX: function (e) {
            return this.array[e * this.itemSize]
        },
        setX: function (e, t) {
            return this.array[e * this.itemSize] = t, this
        },
        getY: function (e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function (e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        },
        getZ: function (e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function (e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        },
        getW: function (e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function (e, t) {
            return this.array[e * this.itemSize + 3] = t, this
        },
        setXY: function (e, t, i) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this
        },
        setXYZ: function (e, t, i, n) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this
        },
        setXYZW: function (e, t, i, n, r) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this
        },
        onUpload: function (e) {
            return this.onUploadCallback = e, this
        },
        clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this)
        },
        toJSON: function () {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }), C.prototype = Object.create(A.prototype), C.prototype.constructor = C, L.prototype = Object.create(A.prototype), L.prototype.constructor = L, P.prototype = Object.create(A.prototype), P.prototype.constructor = P, I.prototype = Object.create(A.prototype), I.prototype.constructor = I, O.prototype = Object.create(A.prototype), O.prototype.constructor = O, R.prototype = Object.create(A.prototype), R.prototype.constructor = R, D.prototype = Object.create(A.prototype), D.prototype.constructor = D, k.prototype = Object.create(A.prototype), k.prototype.constructor = k, z.prototype = Object.create(A.prototype), z.prototype.constructor = z, Object.assign(B.prototype, {
        computeGroups: function (e) {
            var t = [],
                i = void 0;
            e = e.faces;
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                if (r.materialIndex !== i) {
                    i = r.materialIndex, void 0 !== o && (o.count = 3 * n - o.start, t.push(o));
                    var o = {
                        start: 3 * n,
                        materialIndex: i
                    }
                }
            }
            void 0 !== o && (o.count = 3 * n - o.start, t.push(o)), this.groups = t
        },
        fromGeometry: function (e) {
            var t = e.faces,
                n = e.vertices,
                r = e.faceVertexUvs,
                o = r[0] && 0 < r[0].length,
                s = r[1] && 0 < r[1].length,
                a = e.morphTargets,
                l = a.length;
            if (0 < l) {
                for (var c = [], u = 0; u < l; u++) c[u] = {
                    name: a[u].name,
                    data: []
                };
                this.morphTargets.position = c
            }
            var h = e.morphNormals,
                d = h.length;
            if (0 < d) {
                var p = [];
                for (u = 0; u < d; u++) p[u] = {
                    name: h[u].name,
                    data: []
                };
                this.morphTargets.normal = p
            }
            var f = e.skinIndices,
                m = e.skinWeights,
                g = f.length === n.length,
                v = m.length === n.length;
            for (0 < n.length && 0 === t.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), u = 0; u < t.length; u++) {
                var y = t[u];
                this.vertices.push(n[y.a], n[y.b], n[y.c]);
                var b = y.vertexNormals;
                for (3 === b.length ? this.normals.push(b[0], b[1], b[2]) : (b = y.normal, this.normals.push(b, b, b)), 3 === (b = y.vertexColors).length ? this.colors.push(b[0], b[1], b[2]) : (b = y.color, this.colors.push(b, b, b)), !0 === o && (void 0 !== (b = r[0][u]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u), this.uvs.push(new i, new i, new i))), !0 === s && (void 0 !== (b = r[1][u]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u), this.uvs2.push(new i, new i, new i))), b = 0; b < l; b++) {
                    var x = a[b].vertices;
                    c[b].data.push(x[y.a], x[y.b], x[y.c])
                }
                for (b = 0; b < d; b++) x = h[b].vertexNormals[u], p[b].data.push(x.a, x.b, x.c);
                g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
            }
            return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        }
    });
    var Eo = 1;
    F.prototype = Object.assign(Object.create(t.prototype), {
        constructor: F,
        isBufferGeometry: !0,
        getIndex: function () {
            return this.index
        },
        setIndex: function (e) {
            Array.isArray(e) ? this.index = new(65535 < N(e) ? D : O)(e, 1) : this.index = e
        },
        addAttribute: function (e, t, i) {
            return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : (this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new A(t, i)))
        },
        getAttribute: function (e) {
            return this.attributes[e]
        },
        removeAttribute: function (e) {
            return delete this.attributes[e], this
        },
        addGroup: function (e, t, i) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== i ? i : 0
            })
        },
        clearGroups: function () {
            this.groups = []
        },
        setDrawRange: function (e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        },
        applyMatrix: function (e) {
            var t = this.attributes.position;
            void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
            var i = this.attributes.normal;
            return void 0 !== i && ((t = (new o).getNormalMatrix(e)).applyToBufferAttribute(i), i.needsUpdate = !0), void 0 !== (i = this.attributes.tangent) && ((t = (new o).getNormalMatrix(e)).applyToBufferAttribute(i), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function () {
            var e = new g;
            return function (t) {
                return e.makeRotationX(t), this.applyMatrix(e), this
            }
        }(),
        rotateY: function () {
            var e = new g;
            return function (t) {
                return e.makeRotationY(t), this.applyMatrix(e), this
            }
        }(),
        rotateZ: function () {
            var e = new g;
            return function (t) {
                return e.makeRotationZ(t), this.applyMatrix(e), this
            }
        }(),
        translate: function () {
            var e = new g;
            return function (t, i, n) {
                return e.makeTranslation(t, i, n), this.applyMatrix(e), this
            }
        }(),
        scale: function () {
            var e = new g;
            return function (t, i, n) {
                return e.makeScale(t, i, n), this.applyMatrix(e), this
            }
        }(),
        lookAt: function () {
            var e = new S;
            return function (t) {
                e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
            }
        }(),
        center: function () {
            var e = new r;
            return function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
            }
        }(),
        setFromObject: function (e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                e = new k(3 * t.vertices.length, 3);
                var i = new k(3 * t.colors.length, 3);
                this.addAttribute("position", e.copyVector3sArray(t.vertices)), this.addAttribute("color", i.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length && (e = new k(t.lineDistances.length, 1), this.addAttribute("lineDistance", e.copyArray(t.lineDistances))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        },
        setFromPoints: function (e) {
            for (var t = [], i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.push(r.x, r.y, r.z || 0)
            }
            return this.addAttribute("position", new k(t, 3)), this
        },
        updateFromObject: function (e) {
            var t = e.geometry;
            if (e.isMesh) {
                var i = t.__directGeometry;
                if (!0 === t.elementsNeedUpdate && (i = void 0, t.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(t);
                i.verticesNeedUpdate = t.verticesNeedUpdate, i.normalsNeedUpdate = t.normalsNeedUpdate, i.colorsNeedUpdate = t.colorsNeedUpdate, i.uvsNeedUpdate = t.uvsNeedUpdate, i.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = i
            }
            return !0 === t.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(t.vertices), i.needsUpdate = !0), t.verticesNeedUpdate = !1), !0 === t.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(t.normals), i.needsUpdate = !0), t.normalsNeedUpdate = !1), !0 === t.colorsNeedUpdate && (void 0 !== (i = this.attributes.color) && (i.copyColorsArray(t.colors), i.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (void 0 !== (i = this.attributes.uv) && (i.copyVector2sArray(t.uvs), i.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (void 0 !== (i = this.attributes.lineDistance) && (i.copyArray(t.lineDistances), i.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this
        },
        fromGeometry: function (e) {
            return e.__directGeometry = (new B).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function (e) {
            var t = new Float32Array(3 * e.vertices.length);
            for (var i in this.addAttribute("position", new A(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length && (t = new Float32Array(3 * e.normals.length), this.addAttribute("normal", new A(t, 3).copyVector3sArray(e.normals))), 0 < e.colors.length && (t = new Float32Array(3 * e.colors.length), this.addAttribute("color", new A(t, 3).copyColorsArray(e.colors))), 0 < e.uvs.length && (t = new Float32Array(2 * e.uvs.length), this.addAttribute("uv", new A(t, 2).copyVector2sArray(e.uvs))), 0 < e.uvs2.length && (t = new Float32Array(2 * e.uvs2.length), this.addAttribute("uv2", new A(t, 2).copyVector2sArray(e.uvs2))), this.groups = e.groups, e.morphTargets) {
                t = [];
                for (var n = e.morphTargets[i], r = 0, o = n.length; r < o; r++) {
                    var s = n[r],
                        a = new k(3 * s.data.length, 3);
                    a.name = s.name, t.push(a.copyVector3sArray(s.data))
                }
                this.morphAttributes[i] = t
            }
            return 0 < e.skinIndices.length && (i = new k(4 * e.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(e.skinIndices))), 0 < e.skinWeights.length && (i = new k(4 * e.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(e.skinWeights))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
        },
        computeBoundingBox: function () {
            var e = new d;
            return function () {
                null === this.boundingBox && (this.boundingBox = new d);
                var t = this.attributes.position,
                    i = this.morphAttributes.position;
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t), i) {
                        t = 0;
                        for (var n = i.length; t < n; t++) e.setFromBufferAttribute(i[t]), this.boundingBox.expandByPoint(e.min), this.boundingBox.expandByPoint(e.max)
                    }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
        }(),
        computeBoundingSphere: function () {
            var e = new d,
                t = new d,
                i = new r;
            return function () {
                null === this.boundingSphere && (this.boundingSphere = new p);
                var n = this.attributes.position,
                    r = this.morphAttributes.position;
                if (n) {
                    var o = this.boundingSphere.center;
                    if (e.setFromBufferAttribute(n), r)
                        for (var s = 0, a = r.length; s < a; s++) {
                            var l = r[s];
                            t.setFromBufferAttribute(l), e.expandByPoint(t.min), e.expandByPoint(t.max)
                        }
                    e.getCenter(o);
                    var c = 0;
                    for (s = 0, a = n.count; s < a; s++) i.fromBufferAttribute(n, s), c = Math.max(c, o.distanceToSquared(i));
                    if (r)
                        for (s = 0, a = r.length; s < a; s++) {
                            n = 0;
                            for (var u = (l = r[s]).count; n < u; n++) i.fromBufferAttribute(l, n), c = Math.max(c, o.distanceToSquared(i))
                        }
                    this.boundingSphere.radius = Math.sqrt(c), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function () {},
        computeVertexNormals: function () {
            var e = this.index,
                t = this.attributes;
            if (t.position) {
                var i = t.position.array;
                if (void 0 === t.normal) this.addAttribute("normal", new A(new Float32Array(i.length), 3));
                else
                    for (var n = t.normal.array, o = 0, s = n.length; o < s; o++) n[o] = 0;
                n = t.normal.array;
                var a = new r,
                    l = new r,
                    c = new r,
                    u = new r,
                    h = new r;
                if (e) {
                    var d = e.array;
                    for (o = 0, s = e.count; o < s; o += 3) {
                        e = 3 * d[o + 0];
                        var p = 3 * d[o + 1],
                            f = 3 * d[o + 2];
                        a.fromArray(i, e), l.fromArray(i, p), c.fromArray(i, f), u.subVectors(c, l), h.subVectors(a, l), u.cross(h), n[e] += u.x, n[e + 1] += u.y, n[e + 2] += u.z, n[p] += u.x, n[p + 1] += u.y, n[p + 2] += u.z, n[f] += u.x, n[f + 1] += u.y, n[f + 2] += u.z
                    }
                } else
                    for (o = 0, s = i.length; o < s; o += 9) a.fromArray(i, o), l.fromArray(i, o + 3), c.fromArray(i, o + 6), u.subVectors(c, l), h.subVectors(a, l), u.cross(h), n[o] = u.x, n[o + 1] = u.y, n[o + 2] = u.z, n[o + 3] = u.x, n[o + 4] = u.y, n[o + 5] = u.z, n[o + 6] = u.x, n[o + 7] = u.y, n[o + 8] = u.z;
                this.normalizeNormals(), t.normal.needsUpdate = !0
            }
        },
        merge: function (e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var i, n = this.attributes;
                for (i in n)
                    if (void 0 !== e.attributes[i]) {
                        var r = n[i].array,
                            o = e.attributes[i],
                            s = o.array,
                            a = o.itemSize * t;
                        o = Math.min(s.length, r.length - a);
                        for (var l = 0; l < o; l++, a++) r[a] = s[l]
                    } return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        },
        normalizeNormals: function () {
            var e = new r;
            return function () {
                for (var t = this.attributes.normal, i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.normalize(), t.setXYZ(i, e.x, e.y, e.z)
            }
        }(),
        toNonIndexed: function () {
            function e(e, t) {
                var i = e.array;
                e = e.itemSize;
                for (var n, r = new i.constructor(t.length * e), o = 0, s = 0, a = t.length; s < a; s++) {
                    n = t[s] * e;
                    for (var l = 0; l < e; l++) r[o++] = i[n++]
                }
                return new A(r, e)
            }
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var t, i = new F,
                n = this.index.array,
                r = this.attributes;
            for (t in r) {
                var o = r[t];
                o = e(o, n), i.addAttribute(t, o)
            }
            var s = this.morphAttributes;
            for (t in s) {
                var a = [],
                    l = s[t];
                r = 0;
                for (var c = l.length; r < c; r++) o = e(o = l[r], n), a.push(o);
                i.morphAttributes[t] = a
            }
            for (r = 0, t = (n = this.groups).length; r < t; r++) o = n[r], i.addGroup(o.start, o.count, o.materialIndex);
            return i
        },
        toJSON: function () {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 0 < Object.keys(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) {
                var t = this.parameters;
                for (c in t) void 0 !== t[c] && (e[c] = t[c]);
                return e
            }
            e.data = {
                attributes: {}
            }, null !== (t = this.index) && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            var i = this.attributes;
            for (c in i) {
                var n = (t = i[c]).toJSON();
                "" !== t.name && (n.name = t.name), e.data.attributes[c] = n
            }
            i = {};
            var r = !1;
            for (c in this.morphAttributes) {
                for (var o = this.morphAttributes[c], s = [], a = 0, l = o.length; a < l; a++) n = (t = o[a]).toJSON(), "" !== t.name && (n.name = t.name), s.push(n);
                0 < s.length && (i[c] = s, r = !0)
            }
            r && (e.data.morphAttributes = i);
            var c = this.groups;
            return 0 < c.length && (e.data.groups = JSON.parse(JSON.stringify(c))), null !== (c = this.boundingSphere) && (e.data.boundingSphere = {
                center: c.center.toArray(),
                radius: c.radius
            }), e
        },
        clone: function () {
            return (new F).copy(this)
        },
        copy: function (e) {
            var t;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = e.name;
            var i = e.index;
            for (s in null !== i && this.setIndex(i.clone()), i = e.attributes) this.addAttribute(s, i[s].clone());
            var n = e.morphAttributes;
            for (s in n) {
                var r = [],
                    o = n[s];
                for (i = 0, t = o.length; i < t; i++) r.push(o[i].clone());
                this.morphAttributes[s] = r
            }
            var s = e.groups;
            for (i = 0, t = s.length; i < t; i++) n = s[i], this.addGroup(n.start, n.count, n.materialIndex);
            return null !== (s = e.boundingBox) && (this.boundingBox = s.clone()), null !== (s = e.boundingSphere) && (this.boundingSphere = s.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), H.prototype = Object.create(T.prototype), H.prototype.constructor = H, U.prototype = Object.create(F.prototype), U.prototype.constructor = U, j.prototype = Object.create(T.prototype), j.prototype.constructor = j, G.prototype = Object.create(F.prototype), G.prototype.constructor = G;
    var Mo = 0;
    V.prototype = Object.assign(Object.create(t.prototype), {
        constructor: V,
        isMaterial: !0,
        onBeforeCompile: function () {},
        setValues: function (e) {
            if (void 0 !== e)
                for (var t in e) {
                    var i = e[t];
                    if (void 0 === i) console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    else if ("shading" === t) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
                    else {
                        var n = this[t];
                        void 0 === n ? console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i
                    }
                }
        },
        toJSON: function (e) {
            function t(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    delete n.metadata, i.push(n)
                }
                return i
            }
            var i = void 0 === e || "string" == typeof e;
            i && (e = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), 0 !== this.vertexColors && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), i && (i = t(e.textures), e = t(e.images), 0 < i.length && (n.textures = i), 0 < e.length && (n.images = e)), n
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
            var t = e.clippingPlanes,
                i = null;
            if (null !== t) {
                var n = t.length;
                i = Array(n);
                for (var r = 0; r !== n; ++r) i[r] = t[r].clone()
            }
            return this.clippingPlanes = i, this.shadowSide = e.shadowSide, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), W.prototype = Object.create(V.prototype), W.prototype.constructor = W, W.prototype.isShaderMaterial = !0, W.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = v(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
    }, W.prototype.toJSON = function (e) {
        var t = V.prototype.toJSON.call(this, e);
        for (var i in t.uniforms = {}, this.uniforms) {
            var n = this.uniforms[i].value;
            t.uniforms[i] = n && n.isTexture ? {
                type: "t",
                value: n.toJSON(e).uuid
            } : n && n.isColor ? {
                type: "c",
                value: n.getHex()
            } : n && n.isVector2 ? {
                type: "v2",
                value: n.toArray()
            } : n && n.isVector3 ? {
                type: "v3",
                value: n.toArray()
            } : n && n.isVector4 ? {
                type: "v4",
                value: n.toArray()
            } : n && n.isMatrix3 ? {
                type: "m3",
                value: n.toArray()
            } : n && n.isMatrix4 ? {
                type: "m4",
                value: n.toArray()
            } : {
                value: n
            }
        }
        for (var r in 0 < Object.keys(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, e = {}, this.extensions) !0 === this.extensions[r] && (e[r] = !0);
        return 0 < Object.keys(e).length && (t.extensions = e), t
    }, Object.assign(q.prototype, {
        set: function (e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        },
        at: function (e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new r), t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function (e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        },
        recast: function () {
            var e = new r;
            return function (t) {
                return this.origin.copy(this.at(t, e)), this
            }
        }(),
        closestPointToPoint: function (e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new r), t.subVectors(e, this.origin), 0 > (e = t.dot(this.direction)) ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        distanceToPoint: function (e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: function () {
            var e = new r;
            return function (t) {
                var i = e.subVectors(t, this.origin).dot(this.direction);
                return 0 > i ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(i).add(this.origin), e.distanceToSquared(t))
            }
        }(),
        distanceSqToSegment: function () {
            var e = new r,
                t = new r,
                i = new r;
            return function (n, r, o, s) {
                e.copy(n).add(r).multiplyScalar(.5), t.copy(r).sub(n).normalize(), i.copy(this.origin).sub(e);
                var a = .5 * n.distanceTo(r),
                    l = -this.direction.dot(t),
                    c = i.dot(this.direction),
                    u = -i.dot(t),
                    h = i.lengthSq(),
                    d = Math.abs(1 - l * l);
                if (0 < d) {
                    r = l * c - u;
                    var p = a * d;
                    0 <= (n = l * u - c) ? r >= -p ? r <= p ? l = (n *= a = 1 / d) * (n + l * (r *= a) + 2 * c) + r * (l * n + r + 2 * u) + h : (r = a, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * u) + h) : (r = -a, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * u) + h) : r <= -p ? l = -(n = Math.max(0, -(-l * a + c))) * n + (r = 0 < n ? -a : Math.min(Math.max(-a, -u), a)) * (r + 2 * u) + h : r <= p ? (n = 0, l = (r = Math.min(Math.max(-a, -u), a)) * (r + 2 * u) + h) : l = -(n = Math.max(0, -(l * a + c))) * n + (r = 0 < n ? a : Math.min(Math.max(-a, -u), a)) * (r + 2 * u) + h
                } else r = 0 < l ? -a : a, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * u) + h;
                return o && o.copy(this.direction).multiplyScalar(n).add(this.origin), s && s.copy(t).multiplyScalar(r).add(e), l
            }
        }(),
        intersectSphere: function () {
            var e = new r;
            return function (t, i) {
                e.subVectors(t.center, this.origin);
                var n = e.dot(this.direction),
                    r = e.dot(e) - n * n;
                return r > (t = t.radius * t.radius) ? null : (r = n - (t = Math.sqrt(t - r)), n += t, 0 > r && 0 > n ? null : 0 > r ? this.at(n, i) : this.at(r, i))
            }
        }(),
        intersectsSphere: function (e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        },
        distanceToPlane: function (e) {
            var t = e.normal.dot(this.direction);
            return 0 === t ? 0 === e.distanceToPoint(this.origin) ? 0 : null : 0 <= (e = -(this.origin.dot(e.normal) + e.constant) / t) ? e : null
        },
        intersectPlane: function (e, t) {
            return null === (e = this.distanceToPlane(e)) ? null : this.at(e, t)
        },
        intersectsPlane: function (e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || 0 > e.normal.dot(this.direction) * t
        },
        intersectBox: function (e, t) {
            var i = 1 / this.direction.x,
                n = 1 / this.direction.y,
                r = 1 / this.direction.z,
                o = this.origin;
            if (0 <= i) {
                var s = (e.min.x - o.x) * i;
                i *= e.max.x - o.x
            } else s = (e.max.x - o.x) * i, i *= e.min.x - o.x;
            if (0 <= n) {
                var a = (e.min.y - o.y) * n;
                n *= e.max.y - o.y
            } else a = (e.max.y - o.y) * n, n *= e.min.y - o.y;
            return s > n || a > i ? null : ((a > s || s != s) && (s = a), (n < i || i != i) && (i = n), 0 <= r ? (a = (e.min.z - o.z) * r, e = (e.max.z - o.z) * r) : (a = (e.max.z - o.z) * r, e = (e.min.z - o.z) * r), s > e || a > i ? null : ((a > s || s != s) && (s = a), (e < i || i != i) && (i = e), 0 > i ? null : this.at(0 <= s ? s : i, t)))
        },
        intersectsBox: function () {
            var e = new r;
            return function (t) {
                return null !== this.intersectBox(t, e)
            }
        }(),
        intersectTriangle: function () {
            var e = new r,
                t = new r,
                i = new r,
                n = new r;
            return function (r, o, s, a, l) {
                if (t.subVectors(o, r), i.subVectors(s, r), n.crossVectors(t, i), 0 < (o = this.direction.dot(n))) {
                    if (a) return null;
                    a = 1
                } else {
                    if (!(0 > o)) return null;
                    a = -1, o = -o
                }
                return e.subVectors(this.origin, r), 0 > (r = a * this.direction.dot(i.crossVectors(e, i))) || 0 > (s = a * this.direction.dot(t.cross(e))) || r + s > o || 0 > (r = -a * e.dot(n)) ? null : this.at(r / o, l)
            }
        }(),
        applyMatrix4: function (e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        },
        equals: function (e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    }), Object.assign(X, {
        getNormal: function () {
            var e = new r;
            return function (t, i, n, o) {
                return void 0 === o && (console.warn("THREE.Triangle: .getNormal() target is now required"), o = new r), o.subVectors(n, i), e.subVectors(t, i), o.cross(e), 0 < (t = o.lengthSq()) ? o.multiplyScalar(1 / Math.sqrt(t)) : o.set(0, 0, 0)
            }
        }(),
        getBarycoord: function () {
            var e = new r,
                t = new r,
                i = new r;
            return function (n, o, s, a, l) {
                e.subVectors(a, o), t.subVectors(s, o), i.subVectors(n, o), n = e.dot(e), o = e.dot(t), s = e.dot(i);
                var c = t.dot(t);
                a = t.dot(i);
                var u = n * c - o * o;
                return void 0 === l && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), l = new r), 0 === u ? l.set(-2, -1, -1) : (c = (c * s - o * a) * (u = 1 / u), n = (n * a - o * s) * u, l.set(1 - c - n, n, c))
            }
        }(),
        containsPoint: function () {
            var e = new r;
            return function (t, i, n, r) {
                return X.getBarycoord(t, i, n, r, e), 0 <= e.x && 0 <= e.y && 1 >= e.x + e.y
            }
        }(),
        getUV: function () {
            var e = new r;
            return function (t, i, n, r, o, s, a, l) {
                return this.getBarycoord(t, i, n, r, e), l.set(0, 0), l.addScaledVector(o, e.x), l.addScaledVector(s, e.y), l.addScaledVector(a, e.z), l
            }
        }(),
        isFrontFacing: function () {
            var e = new r,
                t = new r;
            return function (i, n, r, o) {
                return e.subVectors(r, n), t.subVectors(i, n), 0 > e.cross(t).dot(o)
            }
        }()
    }), Object.assign(X.prototype, {
        set: function (e, t, i) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
        },
        setFromPointsAndIndices: function (e, t, i, n) {
            return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        },
        getArea: function () {
            var e = new r,
                t = new r;
            return function () {
                return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
            }
        }(),
        getMidpoint: function (e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new r), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function (e) {
            return X.getNormal(this.a, this.b, this.c, e)
        },
        getPlane: function (e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new r), e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function (e, t) {
            return X.getBarycoord(e, this.a, this.b, this.c, t)
        },
        getUV: function (e, t, i, n, r) {
            return X.getUV(e, this.a, this.b, this.c, t, i, n, r)
        },
        containsPoint: function (e) {
            return X.containsPoint(e, this.a, this.b, this.c)
        },
        isFrontFacing: function (e) {
            return X.isFrontFacing(this.a, this.b, this.c, e)
        },
        intersectsBox: function (e) {
            return e.intersectsTriangle(this)
        },
        closestPointToPoint: function () {
            var e = new r,
                t = new r,
                i = new r,
                n = new r,
                o = new r,
                s = new r;
            return function (a, l) {
                void 0 === l && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), l = new r);
                var c = this.a,
                    u = this.b,
                    h = this.c;
                e.subVectors(u, c), t.subVectors(h, c), n.subVectors(a, c);
                var d = e.dot(n),
                    p = t.dot(n);
                if (0 >= d && 0 >= p) return l.copy(c);
                o.subVectors(a, u);
                var f = e.dot(o),
                    m = t.dot(o);
                if (0 <= f && m <= f) return l.copy(u);
                var g = d * m - f * p;
                if (0 >= g && 0 <= d && 0 >= f) return u = d / (d - f), l.copy(c).addScaledVector(e, u);
                s.subVectors(a, h), a = e.dot(s);
                var v = t.dot(s);
                return 0 <= v && a <= v ? l.copy(h) : 0 >= (d = a * p - d * v) && 0 <= p && 0 >= v ? (g = p / (p - v), l.copy(c).addScaledVector(t, g)) : 0 >= (p = f * v - a * m) && 0 <= m - f && 0 <= a - v ? (i.subVectors(h, u), g = (m - f) / (m - f + (a - v)), l.copy(u).addScaledVector(i, g)) : (u = d * (h = 1 / (p + d + g)), g *= h, l.copy(c).addScaledVector(e, u).addScaledVector(t, g))
            }
        }(),
        equals: function (e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }), Y.prototype = Object.create(V.prototype), Y.prototype.constructor = Y, Y.prototype.isMeshBasicMaterial = !0, Y.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
    }, Z.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Z,
        isMesh: !0,
        setDrawMode: function (e) {
            this.drawMode = e
        },
        copy: function (e) {
            return S.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
        },
        updateMorphTargets: function () {
            var e = this.geometry;
            if (e.isBufferGeometry) {
                e = e.morphAttributes;
                var t = Object.keys(e);
                if (0 < t.length) {
                    var i = e[t[0]];
                    if (void 0 !== i)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = i.length; e < t; e++) {
                            var n = i[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                }
            } else void 0 !== (e = e.morphTargets) && 0 < e.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        },
        raycast: function () {
            function e(e, t, i, n, r, o, s, a) {
                return null === (1 === t.side ? n.intersectTriangle(s, o, r, !0, a) : n.intersectTriangle(r, o, s, 2 !== t.side, a)) ? null : (E.copy(a), E.applyMatrix4(e.matrixWorld), (t = i.ray.origin.distanceTo(E)) < i.near || t > i.far ? null : {
                    distance: t,
                    point: E.clone(),
                    object: e
                })
            }

            function t(t, n, r, o, s, p, g, E, M, S) {
                if (a.fromBufferAttribute(s, E), l.fromBufferAttribute(s, M), c.fromBufferAttribute(s, S), s = t.morphTargetInfluences, n.morphTargets && p && s) {
                    f.set(0, 0, 0), m.set(0, 0, 0), v.set(0, 0, 0);
                    for (var T = 0, A = p.length; T < A; T++) {
                        var C = s[T],
                            L = p[T];
                        0 !== C && (u.fromBufferAttribute(L, E), h.fromBufferAttribute(L, M), d.fromBufferAttribute(L, S), f.addScaledVector(u.sub(a), C), m.addScaledVector(h.sub(l), C), v.addScaledVector(d.sub(c), C))
                    }
                    a.add(f), l.add(m), c.add(v)
                }
                return (t = e(t, n, r, o, a, l, c, w)) && (g && (y.fromBufferAttribute(g, E), b.fromBufferAttribute(g, M), x.fromBufferAttribute(g, S), t.uv = X.getUV(w, a, l, c, y, b, x, new i)), g = new _(E, M, S), X.getNormal(a, l, c, g.normal), t.face = g), t
            }
            var n = new g,
                o = new q,
                s = new p,
                a = new r,
                l = new r,
                c = new r,
                u = new r,
                h = new r,
                d = new r,
                f = new r,
                m = new r,
                v = new r,
                y = new i,
                b = new i,
                x = new i,
                w = new r,
                E = new r;
            return function (r, a) {
                var l = this.geometry,
                    c = this.material,
                    u = this.matrixWorld;
                if (void 0 !== c && (null === l.boundingSphere && l.computeBoundingSphere(), s.copy(l.boundingSphere), s.applyMatrix4(u), !1 !== r.ray.intersectsSphere(s) && (n.getInverse(u), o.copy(r.ray).applyMatrix4(n), null === l.boundingBox || !1 !== o.intersectsBox(l.boundingBox))))
                    if (l.isBufferGeometry) {
                        var h = l.index;
                        u = l.attributes.position;
                        var d, p, f = l.morphAttributes.position,
                            m = l.attributes.uv,
                            g = l.groups,
                            v = l.drawRange;
                        if (null !== h)
                            if (Array.isArray(c)) {
                                var _ = 0;
                                for (d = g.length; _ < d; _++) {
                                    var E = g[_],
                                        M = c[E.materialIndex],
                                        S = Math.max(E.start, v.start);
                                    for (p = l = Math.min(E.start + E.count, v.start + v.count); S < p; S += 3) {
                                        l = h.getX(S);
                                        var T = h.getX(S + 1),
                                            A = h.getX(S + 2);
                                        (l = t(this, M, r, o, u, f, m, l, T, A)) && (l.faceIndex = Math.floor(S / 3), l.face.materialIndex = E.materialIndex, a.push(l))
                                    }
                                }
                            } else
                                for (_ = S = Math.max(0, v.start), d = l = Math.min(h.count, v.start + v.count); _ < d; _ += 3) l = h.getX(_), T = h.getX(_ + 1), A = h.getX(_ + 2), (l = t(this, c, r, o, u, f, m, l, T, A)) && (l.faceIndex = Math.floor(_ / 3), a.push(l));
                        else if (void 0 !== u)
                            if (Array.isArray(c))
                                for (_ = 0, d = g.length; _ < d; _++)
                                    for (M = c[(E = g[_]).materialIndex], S = Math.max(E.start, v.start), p = l = Math.min(E.start + E.count, v.start + v.count); S < p; S += 3)(l = t(this, M, r, o, u, f, m, l = S, T = S + 1, A = S + 2)) && (l.faceIndex = Math.floor(S / 3), l.face.materialIndex = E.materialIndex, a.push(l));
                            else
                                for (_ = S = Math.max(0, v.start), d = l = Math.min(u.count, v.start + v.count); _ < d; _ += 3)(l = t(this, c, r, o, u, f, m, l = _, T = _ + 1, A = _ + 2)) && (l.faceIndex = Math.floor(_ / 3), a.push(l))
                    } else if (l.isGeometry)
                    for (u = Array.isArray(c), f = l.vertices, m = l.faces, 0 < (l = l.faceVertexUvs[0]).length && (h = l), d = 0, E = m.length; d < E; d++) M = m[d], void 0 !== (l = u ? c[M.materialIndex] : c) && (g = f[M.a], v = f[M.b], _ = f[M.c], l = e(this, l, r, o, g, v, _, w)) && (h && h[d] && (S = h[d], y.copy(S[0]), b.copy(S[1]), x.copy(S[2]), l.uv = X.getUV(w, g, v, _, y, b, x, new i)), l.face = M, l.faceIndex = d, a.push(l))
            }
        }(),
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), ae.prototype = Object.create(s.prototype), ae.prototype.constructor = ae, ae.prototype.isCubeTexture = !0, Object.defineProperty(ae.prototype, "images", {
        get: function () {
            return this.image
        },
        set: function (e) {
            this.image = e
        }
    }), le.prototype = Object.create(s.prototype), le.prototype.constructor = le, le.prototype.isDataTexture2DArray = !0, ce.prototype = Object.create(s.prototype), ce.prototype.constructor = ce, ce.prototype.isDataTexture3D = !0;
    var So = new s,
        To = new le,
        Ao = new ce,
        Co = new ae,
        Lo = [],
        Po = [],
        Io = new Float32Array(16),
        Oo = new Float32Array(9),
        Ro = new Float32Array(4);
    Ge.prototype.updateCache = function (e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), de(t, e)
    }, Ve.prototype.setValue = function (e, t, i) {
        for (var n = this.seq, r = 0, o = n.length; r !== o; ++r) {
            var s = n[r];
            s.setValue(e, t[s.id], i)
        }
    };
    var Do = /([\w\d_]+)(\])?(\[|\.)?/g;
    We.prototype.setValue = function (e, t, i, n) {
        void 0 !== (t = this.map[t]) && t.setValue(e, i, n)
    }, We.prototype.setOptional = function (e, t, i) {
        void 0 !== (t = t[i]) && this.setValue(e, i, t)
    }, We.upload = function (e, t, i, n) {
        for (var r = 0, o = t.length; r !== o; ++r) {
            var s = t[r],
                a = i[s.id];
            !1 !== a.needsUpdate && s.setValue(e, a.value, n)
        }
    }, We.seqWithValue = function (e, t) {
        for (var i = [], n = 0, r = e.length; n !== r; ++n) {
            var o = e[n];
            o.id in t && i.push(o)
        }
        return i
    };
    var ko = 0,
        zo = 0;
    pt.prototype = Object.create(V.prototype), pt.prototype.constructor = pt, pt.prototype.isMeshDepthMaterial = !0, pt.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }, ft.prototype = Object.create(V.prototype), ft.prototype.constructor = ft, ft.prototype.isMeshDistanceMaterial = !0, ft.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    }, bt.prototype = Object.assign(Object.create(S.prototype), {
        constructor: bt,
        isGroup: !0
    }), xt.prototype = Object.assign(Object.create(S.prototype), {
        constructor: xt,
        isCamera: !0,
        copy: function (e, t) {
            return S.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
        },
        getWorldDirection: function (e) {
            void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new r), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function (e) {
            S.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        }
    }), wt.prototype = Object.assign(Object.create(xt.prototype), {
        constructor: wt,
        isPerspectiveCamera: !0,
        copy: function (e, t) {
            return xt.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        },
        setFocalLength: function (e) {
            e = .5 * this.getFilmHeight() / e, this.fov = 2 * ho.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
        },
        getFocalLength: function () {
            var e = Math.tan(.5 * ho.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function () {
            return 2 * ho.RAD2DEG * Math.atan(Math.tan(.5 * ho.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function (e, t, i, n, r, o) {
            this.aspect = e / t, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function () {
            var e = this.near,
                t = e * Math.tan(.5 * ho.DEG2RAD * this.fov) / this.zoom,
                i = 2 * t,
                n = this.aspect * i,
                r = -.5 * n,
                o = this.view;
            if (null !== this.view && this.view.enabled) {
                var s = o.fullWidth,
                    a = o.fullHeight;
                r += o.offsetX * n / s, t -= o.offsetY * i / a, n *= o.width / s, i *= o.height / a
            }
            0 !== (o = this.filmOffset) && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function (e) {
            return (e = S.prototype.toJSON.call(this, e)).object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    }), _t.prototype = Object.assign(Object.create(wt.prototype), {
        constructor: _t,
        isArrayCamera: !0
    });
    var Bo, No = new r,
        Fo = new r;
    Object.assign(At.prototype, {
        isFogExp2: !0,
        clone: function () {
            return new At(this.color, this.density)
        },
        toJSON: function () {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }), Object.assign(Ct.prototype, {
        isFog: !0,
        clone: function () {
            return new Ct(this.color, this.near, this.far)
        },
        toJSON: function () {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }), Lt.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Lt,
        isScene: !0,
        copy: function (e, t) {
            return S.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
        },
        toJSON: function (e) {
            var t = S.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(Pt.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.assign(Pt.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function () {},
        setArray: function (e) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this
        },
        setDynamic: function (e) {
            return this.dynamic = e, this
        },
        copy: function (e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
        },
        copyAt: function (e, t, i) {
            e *= this.stride, i *= t.stride;
            for (var n = 0, r = this.stride; n < r; n++) this.array[e + n] = t.array[i + n];
            return this
        },
        set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        onUpload: function (e) {
            return this.onUploadCallback = e, this
        }
    }), Object.defineProperties(It.prototype, {
        count: {
            get: function () {
                return this.data.count
            }
        },
        array: {
            get: function () {
                return this.data.array
            }
        }
    }), Object.assign(It.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t, this
        },
        setY: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t, this
        },
        setZ: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t, this
        },
        setW: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t, this
        },
        getX: function (e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function (e, t, i) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
        },
        setXYZ: function (e, t, i, n) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this
        },
        setXYZW: function (e, t, i, n, r) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this
        }
    }), Ot.prototype = Object.create(V.prototype), Ot.prototype.constructor = Ot, Ot.prototype.isSpriteMaterial = !0, Ot.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
    }, Rt.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Rt,
        isSprite: !0,
        raycast: function () {
            function e(e, t, i, n, r, o) {
                s.subVectors(e, i).addScalar(.5).multiply(n), void 0 !== r ? (a.x = o * s.x - r * s.y, a.y = r * s.x + o * s.y) : a.copy(s), e.copy(t), e.x += a.x, e.y += a.y, e.applyMatrix4(l)
            }
            var t = new r,
                n = new r,
                o = new r,
                s = new i,
                a = new i,
                l = new g,
                c = new r,
                u = new r,
                h = new r,
                d = new i,
                p = new i,
                f = new i;
            return function (r, s) {
                n.setFromMatrixScale(this.matrixWorld), l.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), o.setFromMatrixPosition(this.modelViewMatrix);
                var a = this.material.rotation;
                if (0 !== a) var m = Math.cos(a),
                    g = Math.sin(a);
                a = this.center, e(c.set(-.5, -.5, 0), o, a, n, g, m), e(u.set(.5, -.5, 0), o, a, n, g, m), e(h.set(.5, .5, 0), o, a, n, g, m), d.set(0, 0), p.set(1, 0), f.set(1, 1);
                var v = r.ray.intersectTriangle(c, u, h, !1, t);
                null === v && (e(u.set(-.5, .5, 0), o, a, n, g, m), p.set(0, 1), null === (v = r.ray.intersectTriangle(c, h, u, !1, t))) || (g = r.ray.origin.distanceTo(t)) < r.near || g > r.far || s.push({
                    distance: g,
                    point: t.clone(),
                    uv: X.getUV(t, c, u, h, d, p, f, new i),
                    face: null,
                    object: this
                })
            }
        }(),
        clone: function () {
            return new this.constructor(this.material).copy(this)
        },
        copy: function (e) {
            return S.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
        }
    }), Dt.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Dt,
        isLOD: !0,
        copy: function (e) {
            S.prototype.copy.call(this, e, !1);
            for (var t = 0, i = (e = e.levels).length; t < i; t++) {
                var n = e[t];
                this.addLevel(n.object.clone(), n.distance)
            }
            return this
        },
        addLevel: function (e, t) {
            void 0 === t && (t = 0), t = Math.abs(t);
            for (var i = this.levels, n = 0; n < i.length && !(t < i[n].distance); n++);
            return i.splice(n, 0, {
                distance: t,
                object: e
            }), this.add(e), this
        },
        getObjectForDistance: function (e) {
            for (var t = this.levels, i = 1, n = t.length; i < n && !(e < t[i].distance); i++);
            return t[i - 1].object
        },
        raycast: function () {
            var e = new r;
            return function (t, i) {
                e.setFromMatrixPosition(this.matrixWorld);
                var n = t.ray.origin.distanceTo(e);
                this.getObjectForDistance(n).raycast(t, i)
            }
        }(),
        update: function () {
            var e = new r,
                t = new r;
            return function (i) {
                var n = this.levels;
                if (1 < n.length) {
                    e.setFromMatrixPosition(i.matrixWorld), t.setFromMatrixPosition(this.matrixWorld), i = e.distanceTo(t), n[0].object.visible = !0;
                    for (var r = 1, o = n.length; r < o && i >= n[r].distance; r++) n[r - 1].object.visible = !1, n[r].object.visible = !0;
                    for (; r < o; r++) n[r].object.visible = !1
                }
            }
        }(),
        toJSON: function (e) {
            (e = S.prototype.toJSON.call(this, e)).object.levels = [];
            for (var t = this.levels, i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.object.levels.push({
                    object: r.object.uuid,
                    distance: r.distance
                })
            }
            return e
        }
    }), kt.prototype = Object.assign(Object.create(Z.prototype), {
        constructor: kt,
        isSkinnedMesh: !0,
        bind: function (e, t) {
            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
        },
        pose: function () {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function () {
            for (var e = new a, t = this.geometry.attributes.skinWeight, i = 0, n = t.count; i < n; i++) {
                e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.w = t.getW(i);
                var r = 1 / e.manhattanLength();
                1 / 0 !== r ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function (e) {
            Z.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Object.assign(zt.prototype, {
        calculateInverses: function () {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var i = new g;
                this.bones[e] && i.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(i)
            }
        },
        pose: function () {
            var e, t, i = 0;
            for (t = this.bones.length; i < t; i++)(e = this.bones[i]) && e.matrixWorld.getInverse(this.boneInverses[i]);
            for (i = 0, t = this.bones.length; i < t; i++)(e = this.bones[i]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: function () {
            var e = new g,
                t = new g;
            return function () {
                for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, s = 0, a = i.length; s < a; s++) e.multiplyMatrices(i[s] ? i[s].matrixWorld : t, n[s]), e.toArray(r, 16 * s);
                void 0 !== o && (o.needsUpdate = !0)
            }
        }(),
        clone: function () {
            return new zt(this.bones, this.boneInverses)
        },
        getBoneByName: function (e) {
            for (var t = 0, i = this.bones.length; t < i; t++) {
                var n = this.bones[t];
                if (n.name === e) return n
            }
        }
    }), Bt.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Bt,
        isBone: !0
    }), Nt.prototype = Object.create(V.prototype), Nt.prototype.constructor = Nt, Nt.prototype.isLineBasicMaterial = !0, Nt.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
    }, Ft.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Ft,
        isLine: !0,
        computeLineDistances: function () {
            var e = new r,
                t = new r;
            return function () {
                var i = this.geometry;
                if (i.isBufferGeometry)
                    if (null === i.index) {
                        for (var n = i.attributes.position, r = [0], o = 1, s = n.count; o < s; o++) e.fromBufferAttribute(n, o - 1), t.fromBufferAttribute(n, o), r[o] = r[o - 1], r[o] += e.distanceTo(t);
                        i.addAttribute("lineDistance", new k(r, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (i.isGeometry)
                    for (n = i.vertices, (r = i.lineDistances)[0] = 0, o = 1, s = n.length; o < s; o++) r[o] = r[o - 1], r[o] += n[o - 1].distanceTo(n[o]);
                return this
            }
        }(),
        raycast: function () {
            var e = new g,
                t = new q,
                i = new p;
            return function (n, o) {
                var s = n.linePrecision,
                    a = this.geometry,
                    l = this.matrixWorld;
                if (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(l), i.radius += s, !1 !== n.ray.intersectsSphere(i)) {
                    e.getInverse(l), t.copy(n.ray).applyMatrix4(e), s /= (this.scale.x + this.scale.y + this.scale.z) / 3, s *= s;
                    var c = new r,
                        u = new r;
                    l = new r;
                    var h = new r,
                        d = this && this.isLineSegments ? 2 : 1;
                    if (a.isBufferGeometry) {
                        var p = a.index,
                            f = a.attributes.position.array;
                        if (null !== p) {
                            a = 0;
                            for (var m = (p = p.array).length - 1; a < m; a += d) {
                                var g = p[a + 1];
                                c.fromArray(f, 3 * p[a]), u.fromArray(f, 3 * g), (g = t.distanceSqToSegment(c, u, h, l)) > s || (h.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(h)) < n.near || g > n.far || o.push({
                                    distance: g,
                                    point: l.clone().applyMatrix4(this.matrixWorld),
                                    index: a,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                        } else
                            for (a = 0, m = f.length / 3 - 1; a < m; a += d) c.fromArray(f, 3 * a), u.fromArray(f, 3 * a + 3), (g = t.distanceSqToSegment(c, u, h, l)) > s || (h.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(h)) < n.near || g > n.far || o.push({
                                distance: g,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: a,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                    } else if (a.isGeometry)
                        for (u = (c = a.vertices).length, a = 0; a < u - 1; a += d)(g = t.distanceSqToSegment(c[a], c[a + 1], h, l)) > s || (h.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(h)) < n.near || g > n.far || o.push({
                            distance: g,
                            point: l.clone().applyMatrix4(this.matrixWorld),
                            index: a,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                }
            }
        }(),
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Ht.prototype = Object.assign(Object.create(Ft.prototype), {
        constructor: Ht,
        isLineSegments: !0,
        computeLineDistances: function () {
            var e = new r,
                t = new r;
            return function () {
                var i = this.geometry;
                if (i.isBufferGeometry)
                    if (null === i.index) {
                        for (var n = i.attributes.position, r = [], o = 0, s = n.count; o < s; o += 2) e.fromBufferAttribute(n, o), t.fromBufferAttribute(n, o + 1), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + e.distanceTo(t);
                        i.addAttribute("lineDistance", new k(r, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (i.isGeometry)
                    for (n = i.vertices, r = i.lineDistances, o = 0, s = n.length; o < s; o += 2) e.copy(n[o]), t.copy(n[o + 1]), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + e.distanceTo(t);
                return this
            }
        }()
    }), Ut.prototype = Object.assign(Object.create(Ft.prototype), {
        constructor: Ut,
        isLineLoop: !0
    }), jt.prototype = Object.create(V.prototype), jt.prototype.constructor = jt, jt.prototype.isPointsMaterial = !0, jt.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
    }, Gt.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Gt,
        isPoints: !0,
        raycast: function () {
            var e = new g,
                t = new q,
                i = new p;
            return function (n, o) {
                function s(e, i) {
                    var r = t.distanceSqToPoint(e);
                    r < h && (t.closestPointToPoint(e, d), d.applyMatrix4(c), (e = n.ray.origin.distanceTo(d)) < n.near || e > n.far || o.push({
                        distance: e,
                        distanceToRay: Math.sqrt(r),
                        point: d.clone(),
                        index: i,
                        face: null,
                        object: a
                    }))
                }
                var a = this,
                    l = this.geometry,
                    c = this.matrixWorld,
                    u = n.params.Points.threshold;
                if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(c), i.radius += u, !1 !== n.ray.intersectsSphere(i)) {
                    e.getInverse(c), t.copy(n.ray).applyMatrix4(e);
                    var h = (u /= (this.scale.x + this.scale.y + this.scale.z) / 3) * u;
                    u = new r;
                    var d = new r;
                    if (l.isBufferGeometry) {
                        var p = l.index;
                        if (l = l.attributes.position.array, null !== p) {
                            var f = p.array;
                            p = 0;
                            for (var m = f.length; p < m; p++) {
                                var g = f[p];
                                u.fromArray(l, 3 * g), s(u, g)
                            }
                        } else
                            for (p = 0, f = l.length / 3; p < f; p++) u.fromArray(l, 3 * p), s(u, p)
                    } else
                        for (p = 0, f = (u = l.vertices).length; p < f; p++) s(u[p], p)
                }
            }
        }(),
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Vt.prototype = Object.assign(Object.create(s.prototype), {
        constructor: Vt,
        isVideoTexture: !0,
        update: function () {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), Wt.prototype = Object.create(s.prototype), Wt.prototype.constructor = Wt, Wt.prototype.isCompressedTexture = !0, qt.prototype = Object.create(s.prototype), qt.prototype.constructor = qt, qt.prototype.isCanvasTexture = !0, Xt.prototype = Object.create(s.prototype), Xt.prototype.constructor = Xt, Xt.prototype.isDepthTexture = !0, Yt.prototype = Object.create(F.prototype), Yt.prototype.constructor = Yt, Zt.prototype = Object.create(T.prototype), Zt.prototype.constructor = Zt, Qt.prototype = Object.create(F.prototype), Qt.prototype.constructor = Qt, Jt.prototype = Object.create(T.prototype), Jt.prototype.constructor = Jt, Kt.prototype = Object.create(F.prototype), Kt.prototype.constructor = Kt, $t.prototype = Object.create(T.prototype), $t.prototype.constructor = $t, ei.prototype = Object.create(Kt.prototype), ei.prototype.constructor = ei, ti.prototype = Object.create(T.prototype), ti.prototype.constructor = ti, ii.prototype = Object.create(Kt.prototype), ii.prototype.constructor = ii, ni.prototype = Object.create(T.prototype), ni.prototype.constructor = ni, ri.prototype = Object.create(Kt.prototype), ri.prototype.constructor = ri, oi.prototype = Object.create(T.prototype), oi.prototype.constructor = oi, si.prototype = Object.create(Kt.prototype), si.prototype.constructor = si, ai.prototype = Object.create(T.prototype), ai.prototype.constructor = ai, li.prototype = Object.create(F.prototype), li.prototype.constructor = li, li.prototype.toJSON = function () {
        var e = F.prototype.toJSON.call(this);
        return e.path = this.parameters.path.toJSON(), e
    }, ci.prototype = Object.create(T.prototype), ci.prototype.constructor = ci, ui.prototype = Object.create(F.prototype), ui.prototype.constructor = ui, hi.prototype = Object.create(T.prototype), hi.prototype.constructor = hi, di.prototype = Object.create(F.prototype), di.prototype.constructor = di;
    var Ho = function (e, t, i) {
            i = i || 2;
            var n, r = t && t.length,
                o = r ? t[0] * i : e.length,
                s = pi(e, 0, o, i, !0),
                a = [];
            if (!s) return a;
            if (r) {
                var l, c = i;
                r = [];
                var u = 0;
                for (l = t.length; u < l; u++) {
                    var h = t[u] * c;
                    (h = pi(e, h, u < l - 1 ? t[u + 1] * c : e.length, c, !1)) === h.next && (h.steiner = !0), r.push(yi(h))
                }
                for (r.sort(mi), u = 0; u < r.length; u++)(c = gi(t = r[u], c = s)) && fi(t = Mi(c, t), t.next), s = fi(s, s.next)
            }
            if (e.length > 80 * i) {
                var d = n = e[0],
                    p = r = e[1];
                for (c = i; c < o; c += i)(u = e[c]) < d && (d = u), (t = e[c + 1]) < p && (p = t), u > n && (n = u), t > r && (r = t);
                n = 0 !== (n = Math.max(n - d, r - p)) ? 1 / n : 0
            }
            return function e(t, i, n, r, o, s, a) {
                if (t) {
                    if (!a && s) {
                        var l = t,
                            c = l;
                        do {
                            null === c.z && (c.z = vi(c.x, c.y, r, o, s)), c.prevZ = c.prev, c = c.nextZ = c.next
                        } while (c !== l);
                        c.prevZ.nextZ = null, c.prevZ = null, l = c;
                        var u, h, d, p, f = 1;
                        do {
                            c = l;
                            var m = l = null;
                            for (h = 0; c;) {
                                h++;
                                var g = c;
                                for (u = d = 0; u < f && (d++, g = g.nextZ); u++);
                                for (p = f; 0 < d || 0 < p && g;) 0 !== d && (0 === p || !g || c.z <= g.z) ? (u = c, c = c.nextZ, d--) : (u = g, g = g.nextZ, p--), m ? m.nextZ = u : l = u, u.prevZ = m, m = u;
                                c = g
                            }
                            m.nextZ = null, f *= 2
                        } while (1 < h)
                    }
                    for (l = t; t.prev !== t.next;) {
                        if (c = t.prev, g = t.next, s) e: {
                            p = r;
                            var v = o,
                                y = s;
                            if (0 <= xi(h = (m = t).prev, d = m, f = m.next)) m = !1;
                            else {
                                var b = h.x > d.x ? h.x > f.x ? h.x : f.x : d.x > f.x ? d.x : f.x,
                                    x = h.y > d.y ? h.y > f.y ? h.y : f.y : d.y > f.y ? d.y : f.y;
                                for (u = vi(h.x < d.x ? h.x < f.x ? h.x : f.x : d.x < f.x ? d.x : f.x, h.y < d.y ? h.y < f.y ? h.y : f.y : d.y < f.y ? d.y : f.y, p, v, y), p = vi(b, x, p, v, y), v = m.nextZ; v && v.z <= p;) {
                                    if (v !== m.prev && v !== m.next && bi(h.x, h.y, d.x, d.y, f.x, f.y, v.x, v.y) && 0 <= xi(v.prev, v, v.next)) {
                                        m = !1;
                                        break e
                                    }
                                    v = v.nextZ
                                }
                                for (v = m.prevZ; v && v.z >= u;) {
                                    if (v !== m.prev && v !== m.next && bi(h.x, h.y, d.x, d.y, f.x, f.y, v.x, v.y) && 0 <= xi(v.prev, v, v.next)) {
                                        m = !1;
                                        break e
                                    }
                                    v = v.prevZ
                                }
                                m = !0
                            }
                        }
                        else e: if (m = t, h = m.prev, d = m, f = m.next, 0 <= xi(h, d, f)) m = !1;
                            else {
                                for (u = m.next.next; u !== m.prev;) {
                                    if (bi(h.x, h.y, d.x, d.y, f.x, f.y, u.x, u.y) && 0 <= xi(u.prev, u, u.next)) {
                                        m = !1;
                                        break e
                                    }
                                    u = u.next
                                }
                                m = !0
                            } if (m) i.push(c.i / n), i.push(t.i / n), i.push(g.i / n), Ti(t), l = t = g.next;
                        else if ((t = g) === l) {
                            if (a) {
                                if (1 === a) {
                                    a = i, l = n, c = t;
                                    do {
                                        !wi(g = c.prev, m = c.next.next) && _i(g, c, c.next, m) && Ei(g, m) && Ei(m, g) && (a.push(g.i / l), a.push(c.i / l), a.push(m.i / l), Ti(c), Ti(c.next), c = t = m), c = c.next
                                    } while (c !== t);
                                    e(t = c, i, n, r, o, s, 2)
                                } else if (2 === a) e: {
                                    a = t;do {
                                        for (l = a.next.next; l !== a.prev;) {
                                            if (c = a.i !== l.i) {
                                                if (g = l, m = (c = a).next.i !== g.i && c.prev.i !== g.i) {
                                                    t: {
                                                        m = c;do {
                                                            if (m.i !== c.i && m.next.i !== c.i && m.i !== g.i && m.next.i !== g.i && _i(m, m.next, c, g)) {
                                                                m = !0;
                                                                break t
                                                            }
                                                            m = m.next
                                                        } while (m !== c);m = !1
                                                    }
                                                    m = !m
                                                }
                                                if (m = m && Ei(c, g) && Ei(g, c)) {
                                                    m = c, h = !1, d = (c.x + g.x) / 2, g = (c.y + g.y) / 2;
                                                    do {
                                                        m.y > g != m.next.y > g && m.next.y !== m.y && d < (m.next.x - m.x) * (g - m.y) / (m.next.y - m.y) + m.x && (h = !h), m = m.next
                                                    } while (m !== c);
                                                    m = h
                                                }
                                                c = m
                                            }
                                            if (c) {
                                                t = Mi(a, l), a = fi(a, a.next), t = fi(t, t.next), e(a, i, n, r, o, s), e(t, i, n, r, o, s);
                                                break e
                                            }
                                            l = l.next
                                        }
                                        a = a.next
                                    } while (a !== t)
                                }
                            } else e(fi(t), i, n, r, o, s, 1);
                            break
                        }
                    }
                }
            }(s, a, i, d, p, n), a
        },
        Uo = {
            area: function (e) {
                for (var t = e.length, i = 0, n = t - 1, r = 0; r < t; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y;
                return .5 * i
            },
            isClockWise: function (e) {
                return 0 > Uo.area(e)
            },
            triangulateShape: function (e, t) {
                var i = [],
                    n = [],
                    r = [];
                Ci(e), Li(i, e);
                var o = e.length;
                for (t.forEach(Ci), e = 0; e < t.length; e++) n.push(o), o += t[e].length, Li(i, t[e]);
                for (t = Ho(i, n), e = 0; e < t.length; e += 3) r.push(t.slice(e, e + 3));
                return r
            }
        };
    Pi.prototype = Object.create(T.prototype), Pi.prototype.constructor = Pi, Pi.prototype.toJSON = function () {
        var e = T.prototype.toJSON.call(this);
        return Oi(this.parameters.shapes, this.parameters.options, e)
    }, Ii.prototype = Object.create(F.prototype), Ii.prototype.constructor = Ii, Ii.prototype.toJSON = function () {
        var e = F.prototype.toJSON.call(this);
        return Oi(this.parameters.shapes, this.parameters.options, e)
    };
    var jo = {
        generateTopUV: function (e, t, n, r, o) {
            e = t[3 * r], r = t[3 * r + 1];
            var s = t[3 * o];
            return o = t[3 * o + 1], [new i(t[3 * n], t[3 * n + 1]), new i(e, r), new i(s, o)]
        },
        generateSideWallUV: function (e, t, n, r, o, s) {
            e = t[3 * n];
            var a = t[3 * n + 1];
            n = t[3 * n + 2];
            var l = t[3 * r],
                c = t[3 * r + 1];
            r = t[3 * r + 2];
            var u = t[3 * o],
                h = t[3 * o + 1];
            o = t[3 * o + 2];
            var d = t[3 * s],
                p = t[3 * s + 1];
            return t = t[3 * s + 2], .01 > Math.abs(a - c) ? [new i(e, 1 - n), new i(l, 1 - r), new i(u, 1 - o), new i(d, 1 - t)] : [new i(a, 1 - n), new i(c, 1 - r), new i(h, 1 - o), new i(p, 1 - t)]
        }
    };
    Ri.prototype = Object.create(T.prototype), Ri.prototype.constructor = Ri, Di.prototype = Object.create(Ii.prototype), Di.prototype.constructor = Di, ki.prototype = Object.create(T.prototype), ki.prototype.constructor = ki, zi.prototype = Object.create(F.prototype), zi.prototype.constructor = zi, Bi.prototype = Object.create(T.prototype), Bi.prototype.constructor = Bi, Ni.prototype = Object.create(F.prototype), Ni.prototype.constructor = Ni, Fi.prototype = Object.create(T.prototype), Fi.prototype.constructor = Fi, Hi.prototype = Object.create(F.prototype), Hi.prototype.constructor = Hi, Ui.prototype = Object.create(T.prototype), Ui.prototype.constructor = Ui, Ui.prototype.toJSON = function () {
        var e = T.prototype.toJSON.call(this);
        return Gi(this.parameters.shapes, e)
    }, ji.prototype = Object.create(F.prototype), ji.prototype.constructor = ji, ji.prototype.toJSON = function () {
        var e = F.prototype.toJSON.call(this);
        return Gi(this.parameters.shapes, e)
    }, Vi.prototype = Object.create(F.prototype), Vi.prototype.constructor = Vi, Wi.prototype = Object.create(T.prototype), Wi.prototype.constructor = Wi, qi.prototype = Object.create(F.prototype), qi.prototype.constructor = qi, Xi.prototype = Object.create(Wi.prototype), Xi.prototype.constructor = Xi, Yi.prototype = Object.create(qi.prototype), Yi.prototype.constructor = Yi, Zi.prototype = Object.create(T.prototype), Zi.prototype.constructor = Zi, Qi.prototype = Object.create(F.prototype), Qi.prototype.constructor = Qi;
    var Go = Object.freeze({
        WireframeGeometry: Yt,
        ParametricGeometry: Zt,
        ParametricBufferGeometry: Qt,
        TetrahedronGeometry: $t,
        TetrahedronBufferGeometry: ei,
        OctahedronGeometry: ti,
        OctahedronBufferGeometry: ii,
        IcosahedronGeometry: ni,
        IcosahedronBufferGeometry: ri,
        DodecahedronGeometry: oi,
        DodecahedronBufferGeometry: si,
        PolyhedronGeometry: Jt,
        PolyhedronBufferGeometry: Kt,
        TubeGeometry: ai,
        TubeBufferGeometry: li,
        TorusKnotGeometry: ci,
        TorusKnotBufferGeometry: ui,
        TorusGeometry: hi,
        TorusBufferGeometry: di,
        TextGeometry: Ri,
        TextBufferGeometry: Di,
        SphereGeometry: ki,
        SphereBufferGeometry: zi,
        RingGeometry: Bi,
        RingBufferGeometry: Ni,
        PlaneGeometry: j,
        PlaneBufferGeometry: G,
        LatheGeometry: Fi,
        LatheBufferGeometry: Hi,
        ShapeGeometry: Ui,
        ShapeBufferGeometry: ji,
        ExtrudeGeometry: Pi,
        ExtrudeBufferGeometry: Ii,
        EdgesGeometry: Vi,
        ConeGeometry: Xi,
        ConeBufferGeometry: Yi,
        CylinderGeometry: Wi,
        CylinderBufferGeometry: qi,
        CircleGeometry: Zi,
        CircleBufferGeometry: Qi,
        BoxGeometry: H,
        BoxBufferGeometry: U
    });
    Ji.prototype = Object.create(V.prototype), Ji.prototype.constructor = Ji, Ji.prototype.isShadowMaterial = !0, Ji.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this
    }, Ki.prototype = Object.create(W.prototype), Ki.prototype.constructor = Ki, Ki.prototype.isRawShaderMaterial = !0, $i.prototype = Object.create(V.prototype), $i.prototype.constructor = $i, $i.prototype.isMeshStandardMaterial = !0, $i.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, en.prototype = Object.create($i.prototype), en.prototype.constructor = en, en.prototype.isMeshPhysicalMaterial = !0, en.prototype.copy = function (e) {
        return $i.prototype.copy.call(this, e), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this
    }, tn.prototype = Object.create(V.prototype), tn.prototype.constructor = tn, tn.prototype.isMeshPhongMaterial = !0, tn.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, nn.prototype = Object.create(tn.prototype), nn.prototype.constructor = nn, nn.prototype.isMeshToonMaterial = !0, nn.prototype.copy = function (e) {
        return tn.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
    }, rn.prototype = Object.create(V.prototype), rn.prototype.constructor = rn, rn.prototype.isMeshNormalMaterial = !0, rn.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, on.prototype = Object.create(V.prototype), on.prototype.constructor = on, on.prototype.isMeshLambertMaterial = !0, on.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, sn.prototype = Object.create(V.prototype), sn.prototype.constructor = sn, sn.prototype.isMeshMatcapMaterial = !0, sn.prototype.copy = function (e) {
        return V.prototype.copy.call(this, e), this.defines = {
            MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, an.prototype = Object.create(Nt.prototype), an.prototype.constructor = an, an.prototype.isLineDashedMaterial = !0, an.prototype.copy = function (e) {
        return Nt.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    };
    var Vo = Object.freeze({
            ShadowMaterial: Ji,
            SpriteMaterial: Ot,
            RawShaderMaterial: Ki,
            ShaderMaterial: W,
            PointsMaterial: jt,
            MeshPhysicalMaterial: en,
            MeshStandardMaterial: $i,
            MeshPhongMaterial: tn,
            MeshToonMaterial: nn,
            MeshNormalMaterial: rn,
            MeshLambertMaterial: on,
            MeshDepthMaterial: pt,
            MeshDistanceMaterial: ft,
            MeshBasicMaterial: Y,
            MeshMatcapMaterial: sn,
            LineDashedMaterial: an,
            LineBasicMaterial: Nt,
            Material: V
        }),
        Wo = {
            arraySlice: function (e, t, i) {
                return Wo.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i)
            },
            convertArray: function (e, t, i) {
                return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
            },
            isTypedArray: function (e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            },
            getKeyframeOrder: function (e) {
                for (var t = e.length, i = Array(t), n = 0; n !== t; ++n) i[n] = n;
                return i.sort((function (t, i) {
                    return e[t] - e[i]
                })), i
            },
            sortedArray: function (e, t, i) {
                for (var n = e.length, r = new e.constructor(n), o = 0, s = 0; s !== n; ++o)
                    for (var a = i[o] * t, l = 0; l !== t; ++l) r[s++] = e[a + l];
                return r
            },
            flattenJSON: function (e, t, i, n) {
                for (var r = 1, o = e[0]; void 0 !== o && void 0 === o[n];) o = e[r++];
                if (void 0 !== o) {
                    var s = o[n];
                    if (void 0 !== s)
                        if (Array.isArray(s))
                            do {
                                void 0 !== (s = o[n]) && (t.push(o.time), i.push.apply(i, s)), o = e[r++]
                            } while (void 0 !== o);
                        else if (void 0 !== s.toArray)
                        do {
                            void 0 !== (s = o[n]) && (t.push(o.time), s.toArray(i, i.length)), o = e[r++]
                        } while (void 0 !== o);
                    else
                        do {
                            void 0 !== (s = o[n]) && (t.push(o.time), i.push(s)), o = e[r++]
                        } while (void 0 !== o)
                }
            }
        };
    Object.assign(ln.prototype, {
        evaluate: function (e) {
            var t = this.parameterPositions,
                i = this._cachedIndex,
                n = t[i],
                r = t[i - 1];
            e: {
                t: {
                    i: {
                        n: if (!(e < n)) {
                            for (var o = i + 2;;) {
                                if (void 0 === n) {
                                    if (e < r) break n;
                                    return this._cachedIndex = i = t.length, this.afterEnd_(i - 1, e, r)
                                }
                                if (i === o) break;
                                if (r = n, e < (n = t[++i])) break t
                            }
                            n = t.length;
                            break i
                        }if (e >= r) break e;
                        for (e < (o = t[1]) && (i = 2, r = o), o = i - 2;;) {
                            if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
                            if (i === o) break;
                            if (n = r, e >= (r = t[--i - 1])) break t
                        }
                        n = i,
                        i = 0
                    }
                    for (; i < n;) e < t[r = i + n >>> 1] ? n = r : i = r + 1;
                    if (n = t[i], void 0 === (r = t[i - 1])) return this._cachedIndex = 0,
                    this.beforeStart_(0, e, n);
                    if (void 0 === n) return this._cachedIndex = i = t.length,
                    this.afterEnd_(i - 1, r, e)
                }
                this._cachedIndex = i,
                this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, e, n)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function () {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function (e) {
            var t = this.resultBuffer,
                i = this.sampleValues,
                n = this.valueSize;
            e *= n;
            for (var r = 0; r !== n; ++r) t[r] = i[e + r];
            return t
        },
        interpolate_: function () {
            throw Error("call to abstract method")
        },
        intervalChanged_: function () {}
    }), Object.assign(ln.prototype, {
        beforeStart_: ln.prototype.copySampleValue_,
        afterEnd_: ln.prototype.copySampleValue_
    }), cn.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: cn,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function (e, t, i) {
            var n = this.parameterPositions,
                r = e - 2,
                o = e + 1,
                s = n[r],
                a = n[o];
            if (void 0 === s) switch (this.getSettings_().endingStart) {
                case 2401:
                    r = e, s = 2 * t - i;
                    break;
                case 2402:
                    s = t + n[r = n.length - 2] - n[r + 1];
                    break;
                default:
                    r = e, s = i
            }
            if (void 0 === a) switch (this.getSettings_().endingEnd) {
                case 2401:
                    o = e, a = 2 * i - t;
                    break;
                case 2402:
                    o = 1, a = i + n[1] - n[0];
                    break;
                default:
                    o = e - 1, a = t
            }
            e = .5 * (i - t), n = this.valueSize, this._weightPrev = e / (t - s), this._weightNext = e / (a - i), this._offsetPrev = r * n, this._offsetNext = o * n
        },
        interpolate_: function (e, t, i, n) {
            var r = this.resultBuffer,
                o = this.sampleValues,
                s = this.valueSize,
                a = (e *= s) - s,
                l = this._offsetPrev,
                c = this._offsetNext,
                u = this._weightPrev,
                h = this._weightNext,
                d = (i - t) / (n - t);
            for (t = -u * (n = (i = d * d) * d) + 2 * u * i - u * d, u = (1 + u) * n + (-1.5 - 2 * u) * i + (-.5 + u) * d + 1, d = (-1 - h) * n + (1.5 + h) * i + .5 * d, h = h * n - h * i, i = 0; i !== s; ++i) r[i] = t * o[l + i] + u * o[a + i] + d * o[e + i] + h * o[c + i];
            return r
        }
    }), un.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: un,
        interpolate_: function (e, t, i, n) {
            var r = this.resultBuffer,
                o = this.sampleValues,
                s = this.valueSize,
                a = (e *= s) - s;
            for (i = 1 - (t = (i - t) / (n - t)), n = 0; n !== s; ++n) r[n] = o[a + n] * i + o[e + n] * t;
            return r
        }
    }), hn.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: hn,
        interpolate_: function (e) {
            return this.copySampleValue_(e - 1)
        }
    }), Object.assign(dn, {
        toJSON: function (e) {
            var t = e.constructor;
            if (void 0 !== t.toJSON) t = t.toJSON(e);
            else {
                t = {
                    name: e.name,
                    times: Wo.convertArray(e.times, Array),
                    values: Wo.convertArray(e.values, Array)
                };
                var i = e.getInterpolation();
                i !== e.DefaultInterpolation && (t.interpolation = i)
            }
            return t.type = e.ValueTypeName, t
        }
    }), Object.assign(dn.prototype, {
        constructor: dn,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function (e) {
            return new hn(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodLinear: function (e) {
            return new un(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: function (e) {
            return new cn(this.times, this.values, this.getValueSize(), e)
        },
        setInterpolation: function (e) {
            switch (e) {
                case 2300:
                    var t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                if (t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation) throw Error(t);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", t), this
            }
            return this.createInterpolant = t, this
        },
        getInterpolation: function () {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        },
        getValueSize: function () {
            return this.values.length / this.times.length
        },
        shift: function (e) {
            if (0 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] += e;
            return this
        },
        scale: function (e) {
            if (1 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] *= e;
            return this
        },
        trim: function (e, t) {
            for (var i = this.times, n = i.length, r = 0, o = n - 1; r !== n && i[r] < e;) ++r;
            for (; - 1 !== o && i[o] > t;) --o;
            return ++o, 0 === r && o === n || (r >= o && (r = (o = Math.max(o, 1)) - 1), e = this.getValueSize(), this.times = Wo.arraySlice(i, r, o), this.values = Wo.arraySlice(this.values, r * e, o * e)), this
        },
        validate: function () {
            var e = !0,
                t = this.getValueSize();
            0 != t - Math.floor(t) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
            var i = this.times;
            t = this.values;
            var n = i.length;
            0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
            for (var r = null, o = 0; o !== n; o++) {
                var s = i[o];
                if ("number" == typeof s && isNaN(s)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1;
                    break
                }
                if (null !== r && r > s) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, r), e = !1;
                    break
                }
                r = s
            }
            if (void 0 !== t && Wo.isTypedArray(t))
                for (o = 0, i = t.length; o !== i; ++o)
                    if (n = t[o], isNaN(n)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, n), e = !1;
                        break
                    } return e
        },
        optimize: function () {
            for (var e = this.times, t = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, o = e.length - 1, s = 1; s < o; ++s) {
                var a = !1,
                    l = e[s];
                if (l !== e[s + 1] && (1 !== s || l !== l[0]))
                    if (n) a = !0;
                    else {
                        var c = s * i,
                            u = c - i,
                            h = c + i;
                        for (l = 0; l !== i; ++l) {
                            var d = t[c + l];
                            if (d !== t[u + l] || d !== t[h + l]) {
                                a = !0;
                                break
                            }
                        }
                    } if (a) {
                    if (s !== r)
                        for (e[r] = e[s], a = s * i, c = r * i, l = 0; l !== i; ++l) t[c + l] = t[a + l];
                    ++r
                }
            }
            if (0 < o) {
                for (e[r] = e[o], a = o * i, c = r * i, l = 0; l !== i; ++l) t[c + l] = t[a + l];
                ++r
            }
            return r !== e.length && (this.times = Wo.arraySlice(e, 0, r), this.values = Wo.arraySlice(t, 0, r * i)), this
        },
        clone: function () {
            var e = Wo.arraySlice(this.times, 0),
                t = Wo.arraySlice(this.values, 0);
            return (e = new this.constructor(this.name, e, t)).createInterpolant = this.createInterpolant, e
        }
    }), pn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: pn,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), fn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: fn,
        ValueTypeName: "color"
    }), mn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: mn,
        ValueTypeName: "number"
    }), gn.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: gn,
        interpolate_: function (e, t, i, r) {
            var o = this.resultBuffer,
                s = this.sampleValues,
                a = this.valueSize;
            for (t = (i - t) / (r - t), i = (e *= a) + a; e !== i; e += 4) n.slerpFlat(o, 0, s, e - a, s, e, t);
            return o
        }
    }), vn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: vn,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function (e) {
            return new gn(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), yn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: yn,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), bn.prototype = Object.assign(Object.create(dn.prototype), {
        constructor: bn,
        ValueTypeName: "vector"
    }), Object.assign(xn, {
        parse: function (e) {
            for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), r = 0, o = i.length; r !== o; ++r) t.push(wn(i[r]).scale(n));
            return new xn(e.name, e.duration, t)
        },
        toJSON: function (e) {
            var t = [],
                i = e.tracks;
            e = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid
            };
            for (var n = 0, r = i.length; n !== r; ++n) t.push(dn.toJSON(i[n]));
            return e
        },
        CreateFromMorphTargetSequence: function (e, t, i, n) {
            for (var r = t.length, o = [], s = 0; s < r; s++) {
                var a = [],
                    l = [];
                a.push((s + r - 1) % r, s, (s + 1) % r), l.push(0, 1, 0);
                var c = Wo.getKeyframeOrder(a);
                a = Wo.sortedArray(a, 1, c), l = Wo.sortedArray(l, 1, c), n || 0 !== a[0] || (a.push(r), l.push(l[0])), o.push(new mn(".morphTargetInfluences[" + t[s].name + "]", a, l).scale(1 / i))
            }
            return new xn(e, -1, o)
        },
        findByName: function (e, t) {
            var i = e;
            for (Array.isArray(e) || (i = e.geometry && e.geometry.animations || e.animations), e = 0; e < i.length; e++)
                if (i[e].name === t) return i[e];
            return null
        },
        CreateClipsFromMorphTargetSequences: function (e, t, i) {
            for (var n = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, s = e.length; o < s; o++) {
                var a = e[o],
                    l = a.name.match(r);
                if (l && 1 < l.length) {
                    var c = l[1];
                    (l = n[c]) || (n[c] = l = []), l.push(a)
                }
            }
            for (c in e = [], n) e.push(xn.CreateFromMorphTargetSequence(c, n[c], t, i));
            return e
        },
        parseAnimation: function (e, t) {
            if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            var i = function (e, t, i, n, r) {
                    if (0 !== i.length) {
                        var o = [],
                            s = [];
                        Wo.flattenJSON(i, o, s, n), 0 !== o.length && r.push(new e(t, o, s))
                    }
                },
                n = [],
                r = e.name || "default",
                o = e.length || -1,
                s = e.fps || 30;
            e = e.hierarchy || [];
            for (var a = 0; a < e.length; a++) {
                var l = e[a].keys;
                if (l && 0 !== l.length)
                    if (l[0].morphTargets) {
                        o = {};
                        for (var c = 0; c < l.length; c++)
                            if (l[c].morphTargets)
                                for (var u = 0; u < l[c].morphTargets.length; u++) o[l[c].morphTargets[u]] = -1;
                        for (var h in o) {
                            var d = [],
                                p = [];
                            for (u = 0; u !== l[c].morphTargets.length; ++u) {
                                var f = l[c];
                                d.push(f.time), p.push(f.morphTarget === h ? 1 : 0)
                            }
                            n.push(new mn(".morphTargetInfluence[" + h + "]", d, p))
                        }
                        o = o.length * (s || 1)
                    } else i(bn, (c = ".bones[" + t[a].name + "]") + ".position", l, "pos", n), i(vn, c + ".quaternion", l, "rot", n), i(bn, c + ".scale", l, "scl", n)
            }
            return 0 === n.length ? null : new xn(r, o, n)
        }
    }), Object.assign(xn.prototype, {
        resetDuration: function () {
            for (var e = 0, t = 0, i = this.tracks.length; t !== i; ++t) {
                var n = this.tracks[t];
                e = Math.max(e, n.times[n.times.length - 1])
            }
            return this.duration = e, this
        },
        trim: function () {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        },
        validate: function () {
            for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
            return e
        },
        optimize: function () {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        },
        clone: function () {
            for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
            return new xn(this.name, this.duration, e)
        }
    });
    var qo = {
            enabled: !1,
            files: {},
            add: function (e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function (e) {
                if (!1 !== this.enabled) return this.files[e]
            },
            remove: function (e) {
                delete this.files[e]
            },
            clear: function () {
                this.files = {}
            }
        },
        Xo = new _n,
        Yo = {};
    Object.assign(En.prototype, {
        load: function (e, t, i, n) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var r = this,
                o = qo.get(e);
            if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function () {
                t && t(o), r.manager.itemEnd(e)
            }), 0), o;
            if (void 0 === Yo[e]) {
                var s = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (s) {
                    i = s[1];
                    var a = !!s[2];
                    s = s[3], s = decodeURIComponent(s), a && (s = atob(s));
                    try {
                        var l = (this.responseType || "").toLowerCase();
                        switch (l) {
                            case "arraybuffer":
                            case "blob":
                                var c = new Uint8Array(s.length);
                                for (a = 0; a < s.length; a++) c[a] = s.charCodeAt(a);
                                var u = "blob" === l ? new Blob([c.buffer], {
                                    type: i
                                }) : c.buffer;
                                break;
                            case "document":
                                u = (new DOMParser).parseFromString(s, i);
                                break;
                            case "json":
                                u = JSON.parse(s);
                                break;
                            default:
                                u = s
                        }
                        setTimeout((function () {
                            t && t(u), r.manager.itemEnd(e)
                        }), 0)
                    } catch (t) {
                        setTimeout((function () {
                            n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
                        }), 0)
                    }
                } else {
                    Yo[e] = [], Yo[e].push({
                        onLoad: t,
                        onProgress: i,
                        onError: n
                    });
                    var h = new XMLHttpRequest;
                    for (a in h.open("GET", e, !0), h.addEventListener("load", (function (t) {
                            var i = this.response;
                            qo.add(e, i);
                            var n = Yo[e];
                            if (delete Yo[e], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                for (var o = 0, s = n.length; o < s; o++) {
                                    var a = n[o];
                                    a.onLoad && a.onLoad(i)
                                }
                            } else {
                                for (o = 0, s = n.length; o < s; o++)(a = n[o]).onError && a.onError(t);
                                r.manager.itemError(e)
                            }
                            r.manager.itemEnd(e)
                        }), !1), h.addEventListener("progress", (function (t) {
                            for (var i = Yo[e], n = 0, r = i.length; n < r; n++) {
                                var o = i[n];
                                o.onProgress && o.onProgress(t)
                            }
                        }), !1), h.addEventListener("error", (function (t) {
                            var i = Yo[e];
                            delete Yo[e];
                            for (var n = 0, o = i.length; n < o; n++) {
                                var s = i[n];
                                s.onError && s.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }), !1), h.addEventListener("abort", (function (t) {
                            var i = Yo[e];
                            delete Yo[e];
                            for (var n = 0, o = i.length; n < o; n++) {
                                var s = i[n];
                                s.onError && s.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }), !1), void 0 !== this.responseType && (h.responseType = this.responseType), void 0 !== this.withCredentials && (h.withCredentials = this.withCredentials), h.overrideMimeType && h.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) h.setRequestHeader(a, this.requestHeader[a]);
                    h.send(null)
                }
                return r.manager.itemStart(e), h
            }
            Yo[e].push({
                onLoad: t,
                onProgress: i,
                onError: n
            })
        },
        setPath: function (e) {
            return this.path = e, this
        },
        setResponseType: function (e) {
            return this.responseType = e, this
        },
        setWithCredentials: function (e) {
            return this.withCredentials = e, this
        },
        setMimeType: function (e) {
            return this.mimeType = e, this
        },
        setRequestHeader: function (e) {
            return this.requestHeader = e, this
        }
    }), Object.assign(Mn.prototype, {
        load: function (e, t, i, n) {
            var r = this,
                o = new En(r.manager);
            o.setPath(r.path), o.load(e, (function (e) {
                t(r.parse(JSON.parse(e)))
            }), i, n)
        },
        parse: function (e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = xn.parse(e[i]);
                t.push(n)
            }
            return t
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(Sn.prototype, {
        load: function (e, t, i, n) {
            function r(r) {
                l.load(e[r], (function (e) {
                    e = o._parser(e, !0), s[r] = {
                        width: e.width,
                        height: e.height,
                        format: e.format,
                        mipmaps: e.mipmaps
                    }, 6 === (c += 1) && (1 === e.mipmapCount && (a.minFilter = 1006), a.format = e.format, a.needsUpdate = !0, t && t(a))
                }), i, n)
            }
            var o = this,
                s = [],
                a = new Wt;
            a.image = s;
            var l = new En(this.manager);
            if (l.setPath(this.path), l.setResponseType("arraybuffer"), Array.isArray(e))
                for (var c = 0, u = 0, h = e.length; u < h; ++u) r(u);
            else l.load(e, (function (e) {
                if ((e = o._parser(e, !0)).isCubemap)
                    for (var i = e.mipmaps.length / e.mipmapCount, n = 0; n < i; n++) {
                        s[n] = {
                            mipmaps: []
                        };
                        for (var r = 0; r < e.mipmapCount; r++) s[n].mipmaps.push(e.mipmaps[n * e.mipmapCount + r]), s[n].format = e.format, s[n].width = e.width, s[n].height = e.height
                    } else a.image.width = e.width, a.image.height = e.height, a.mipmaps = e.mipmaps;
                1 === e.mipmapCount && (a.minFilter = 1006), a.format = e.format, a.needsUpdate = !0, t && t(a)
            }), i, n);
            return a
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(Tn.prototype, {
        load: function (e, t, i, n) {
            var r = this,
                o = new h,
                s = new En(this.manager);
            return s.setResponseType("arraybuffer"), s.setPath(this.path), s.load(e, (function (e) {
                (e = r._parser(e)) && (void 0 !== e.image ? o.image = e.image : void 0 !== e.data && (o.image.width = e.width, o.image.height = e.height, o.image.data = e.data), o.wrapS = void 0 !== e.wrapS ? e.wrapS : 1001, o.wrapT = void 0 !== e.wrapT ? e.wrapT : 1001, o.magFilter = void 0 !== e.magFilter ? e.magFilter : 1006, o.minFilter = void 0 !== e.minFilter ? e.minFilter : 1008, o.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.format && (o.format = e.format), void 0 !== e.type && (o.type = e.type), void 0 !== e.mipmaps && (o.mipmaps = e.mipmaps), 1 === e.mipmapCount && (o.minFilter = 1006), o.needsUpdate = !0, t && t(o, e))
            }), i, n), o
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(An.prototype, {
        crossOrigin: "anonymous",
        load: function (e, t, i, n) {
            function r() {
                l.removeEventListener("load", r, !1), l.removeEventListener("error", o, !1), qo.add(e, this), t && t(this), s.manager.itemEnd(e)
            }

            function o(t) {
                l.removeEventListener("load", r, !1), l.removeEventListener("error", o, !1), n && n(t), s.manager.itemError(e), s.manager.itemEnd(e)
            }
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var s = this,
                a = qo.get(e);
            if (void 0 !== a) return s.manager.itemStart(e), setTimeout((function () {
                t && t(a), s.manager.itemEnd(e)
            }), 0), a;
            var l = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return l.addEventListener("load", r, !1), l.addEventListener("error", o, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (l.crossOrigin = this.crossOrigin), s.manager.itemStart(e), l.src = e, l
        },
        setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(Cn.prototype, {
        crossOrigin: "anonymous",
        load: function (e, t, i, n) {
            function r(i) {
                s.load(e[i], (function (e) {
                    o.images[i] = e, 6 === ++a && (o.needsUpdate = !0, t && t(o))
                }), void 0, n)
            }
            var o = new ae,
                s = new An(this.manager);
            s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
            var a = 0;
            for (i = 0; i < e.length; ++i) r(i);
            return o
        },
        setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(Ln.prototype, {
        crossOrigin: "anonymous",
        load: function (e, t, i, n) {
            var r = new s,
                o = new An(this.manager);
            return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, (function (i) {
                r.image = i, i = 0 < e.search(/\.jpe?g($|\?)/i) || 0 === e.search(/^data:image\/jpeg/), r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== t && t(r)
            }), i, n), r
        },
        setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(Pn.prototype, {
        getPoint: function () {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function (e, t) {
            return e = this.getUtoTmapping(e), this.getPoint(e, t)
        },
        getPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e));
            return t
        },
        getSpacedPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
            return t
        },
        getLength: function () {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function (e) {
            if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, i = [],
                n = this.getPoint(0),
                r = 0;
            for (i.push(0), t = 1; t <= e; t++) {
                var o = this.getPoint(t / e);
                r += o.distanceTo(n), i.push(r), n = o
            }
            return this.cacheArcLengths = i
        },
        updateArcLengths: function () {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function (e, t) {
            var i = this.getLengths(),
                n = i.length;
            t = t || e * i[n - 1];
            for (var r, o = 0, s = n - 1; o <= s;)
                if (0 > (r = i[e = Math.floor(o + (s - o) / 2)] - t)) o = e + 1;
                else {
                    if (!(0 < r)) {
                        s = e;
                        break
                    }
                    s = e - 1
                } return i[e = s] === t ? e / (n - 1) : (e + (t - (o = i[e])) / (i[e + 1] - o)) / (n - 1)
        },
        getTangent: function (e) {
            var t = e - 1e-4;
            return 0 > t && (t = 0), 1 < (e += 1e-4) && (e = 1), t = this.getPoint(t), this.getPoint(e).clone().sub(t).normalize()
        },
        getTangentAt: function (e) {
            return e = this.getUtoTmapping(e), this.getTangent(e)
        },
        computeFrenetFrames: function (e, t) {
            var i, n = new r,
                o = [],
                s = [],
                a = [],
                l = new r,
                c = new g;
            for (i = 0; i <= e; i++) {
                var u = i / e;
                o[i] = this.getTangentAt(u), o[i].normalize()
            }
            s[0] = new r, a[0] = new r, i = Number.MAX_VALUE, u = Math.abs(o[0].x);
            var h = Math.abs(o[0].y),
                d = Math.abs(o[0].z);
            for (u <= i && (i = u, n.set(1, 0, 0)), h <= i && (i = h, n.set(0, 1, 0)), d <= i && n.set(0, 0, 1), l.crossVectors(o[0], n).normalize(), s[0].crossVectors(o[0], l), a[0].crossVectors(o[0], s[0]), i = 1; i <= e; i++) s[i] = s[i - 1].clone(), a[i] = a[i - 1].clone(), l.crossVectors(o[i - 1], o[i]), l.length() > Number.EPSILON && (l.normalize(), n = Math.acos(ho.clamp(o[i - 1].dot(o[i]), -1, 1)), s[i].applyMatrix4(c.makeRotationAxis(l, n))), a[i].crossVectors(o[i], s[i]);
            if (!0 === t)
                for (n = Math.acos(ho.clamp(s[0].dot(s[e]), -1, 1)), n /= e, 0 < o[0].dot(l.crossVectors(s[0], s[e])) && (n = -n), i = 1; i <= e; i++) s[i].applyMatrix4(c.makeRotationAxis(o[i], n * i)), a[i].crossVectors(o[i], s[i]);
            return {
                tangents: o,
                normals: s,
                binormals: a
            }
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        },
        toJSON: function () {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
        },
        fromJSON: function (e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        }
    }), In.prototype = Object.create(Pn.prototype), In.prototype.constructor = In, In.prototype.isEllipseCurve = !0, In.prototype.getPoint = function (e, t) {
        t = t || new i;
        for (var n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; 0 > r;) r += n;
        for (; r > n;) r -= n;
        r < Number.EPSILON && (r = o ? 0 : n), !0 !== this.aClockwise || o || (r = r === n ? -n : r - n), n = this.aStartAngle + e * r, e = this.aX + this.xRadius * Math.cos(n);
        var s = this.aY + this.yRadius * Math.sin(n);
        return 0 !== this.aRotation && (n = Math.cos(this.aRotation), r = Math.sin(this.aRotation), e = (o = e - this.aX) * n - (s -= this.aY) * r + this.aX, s = o * r + s * n + this.aY), t.set(e, s)
    }, In.prototype.copy = function (e) {
        return Pn.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, In.prototype.toJSON = function () {
        var e = Pn.prototype.toJSON.call(this);
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }, In.prototype.fromJSON = function (e) {
        return Pn.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, On.prototype = Object.create(In.prototype), On.prototype.constructor = On, On.prototype.isArcCurve = !0;
    var Zo = new r,
        Qo = new Rn,
        Jo = new Rn,
        Ko = new Rn;
    Dn.prototype = Object.create(Pn.prototype), Dn.prototype.constructor = Dn, Dn.prototype.isCatmullRomCurve3 = !0, Dn.prototype.getPoint = function (e, t) {
        t = t || new r;
        var i = this.points,
            n = i.length;
        e *= n - (this.closed ? 0 : 1);
        var o = Math.floor(e);
        if (e -= o, this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / n) + 1) * n : 0 === e && o === n - 1 && (o = n - 2, e = 1), this.closed || 0 < o) var s = i[(o - 1) % n];
        else Zo.subVectors(i[0], i[1]).add(i[0]), s = Zo;
        var a = i[o % n],
            l = i[(o + 1) % n];
        if (this.closed || o + 2 < n ? i = i[(o + 2) % n] : (Zo.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), i = Zo), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var c = "chordal" === this.curveType ? .5 : .25;
            n = Math.pow(s.distanceToSquared(a), c), 1e-4 > (o = Math.pow(a.distanceToSquared(l), c)) && (o = 1), 1e-4 > n && (n = o), 1e-4 > (c = Math.pow(l.distanceToSquared(i), c)) && (c = o), Qo.initNonuniformCatmullRom(s.x, a.x, l.x, i.x, n, o, c), Jo.initNonuniformCatmullRom(s.y, a.y, l.y, i.y, n, o, c), Ko.initNonuniformCatmullRom(s.z, a.z, l.z, i.z, n, o, c)
        } else "catmullrom" === this.curveType && (Qo.initCatmullRom(s.x, a.x, l.x, i.x, this.tension), Jo.initCatmullRom(s.y, a.y, l.y, i.y, this.tension), Ko.initCatmullRom(s.z, a.z, l.z, i.z, this.tension));
        return t.set(Qo.calc(e), Jo.calc(e), Ko.calc(e)), t
    }, Dn.prototype.copy = function (e) {
        Pn.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) this.points.push(e.points[t].clone());
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, Dn.prototype.toJSON = function () {
        var e = Pn.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++) e.points.push(this.points[t].toArray());
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }, Dn.prototype.fromJSON = function (e) {
        Pn.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push((new r).fromArray(n))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, Nn.prototype = Object.create(Pn.prototype), Nn.prototype.constructor = Nn, Nn.prototype.isCubicBezierCurve = !0, Nn.prototype.getPoint = function (e, t) {
        t = t || new i;
        var n = this.v0,
            r = this.v1,
            o = this.v2,
            s = this.v3;
        return t.set(Bn(e, n.x, r.x, o.x, s.x), Bn(e, n.y, r.y, o.y, s.y)), t
    }, Nn.prototype.copy = function (e) {
        return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, Nn.prototype.toJSON = function () {
        var e = Pn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, Nn.prototype.fromJSON = function (e) {
        return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, Fn.prototype = Object.create(Pn.prototype), Fn.prototype.constructor = Fn, Fn.prototype.isCubicBezierCurve3 = !0, Fn.prototype.getPoint = function (e, t) {
        t = t || new r;
        var i = this.v0,
            n = this.v1,
            o = this.v2,
            s = this.v3;
        return t.set(Bn(e, i.x, n.x, o.x, s.x), Bn(e, i.y, n.y, o.y, s.y), Bn(e, i.z, n.z, o.z, s.z)), t
    }, Fn.prototype.copy = function (e) {
        return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, Fn.prototype.toJSON = function () {
        var e = Pn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, Fn.prototype.fromJSON = function (e) {
        return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, Hn.prototype = Object.create(Pn.prototype), Hn.prototype.constructor = Hn, Hn.prototype.isLineCurve = !0, Hn.prototype.getPoint = function (e, t) {
        return t = t || new i, 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
    }, Hn.prototype.getPointAt = function (e, t) {
        return this.getPoint(e, t)
    }, Hn.prototype.getTangent = function () {
        return this.v2.clone().sub(this.v1).normalize()
    }, Hn.prototype.copy = function (e) {
        return Pn.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, Hn.prototype.toJSON = function () {
        var e = Pn.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, Hn.prototype.fromJSON = function (e) {
        return Pn.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, Un.prototype = Object.create(Pn.prototype), Un.prototype.constructor = Un, Un.prototype.isLineCurve3 = !0, Un.prototype.getPoint = function (e, t) {
        return t = t || new r, 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
    }, Un.prototype.getPointAt = function (e, t) {
        return this.getPoint(e, t)
    }, Un.prototype.copy = function (e) {
        return Pn.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, Un.prototype.toJSON = function () {
        var e = Pn.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, Un.prototype.fromJSON = function (e) {
        return Pn.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, jn.prototype = Object.create(Pn.prototype), jn.prototype.constructor = jn, jn.prototype.isQuadraticBezierCurve = !0, jn.prototype.getPoint = function (e, t) {
        t = t || new i;
        var n = this.v0,
            r = this.v1,
            o = this.v2;
        return t.set(zn(e, n.x, r.x, o.x), zn(e, n.y, r.y, o.y)), t
    }, jn.prototype.copy = function (e) {
        return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, jn.prototype.toJSON = function () {
        var e = Pn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, jn.prototype.fromJSON = function (e) {
        return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, Gn.prototype = Object.create(Pn.prototype), Gn.prototype.constructor = Gn, Gn.prototype.isQuadraticBezierCurve3 = !0, Gn.prototype.getPoint = function (e, t) {
        t = t || new r;
        var i = this.v0,
            n = this.v1,
            o = this.v2;
        return t.set(zn(e, i.x, n.x, o.x), zn(e, i.y, n.y, o.y), zn(e, i.z, n.z, o.z)), t
    }, Gn.prototype.copy = function (e) {
        return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, Gn.prototype.toJSON = function () {
        var e = Pn.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, Gn.prototype.fromJSON = function (e) {
        return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, Vn.prototype = Object.create(Pn.prototype), Vn.prototype.constructor = Vn, Vn.prototype.isSplineCurve = !0, Vn.prototype.getPoint = function (e, t) {
        t = t || new i;
        var n = this.points,
            r = (n.length - 1) * e;
        r -= e = Math.floor(r);
        var o = n[0 === e ? e : e - 1],
            s = n[e],
            a = n[e > n.length - 2 ? n.length - 1 : e + 1];
        return n = n[e > n.length - 3 ? n.length - 1 : e + 2], t.set(kn(r, o.x, s.x, a.x, n.x), kn(r, o.y, s.y, a.y, n.y)), t
    }, Vn.prototype.copy = function (e) {
        Pn.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) this.points.push(e.points[t].clone());
        return this
    }, Vn.prototype.toJSON = function () {
        var e = Pn.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++) e.points.push(this.points[t].toArray());
        return e
    }, Vn.prototype.fromJSON = function (e) {
        Pn.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push((new i).fromArray(r))
        }
        return this
    };
    var $o = Object.freeze({
        ArcCurve: On,
        CatmullRomCurve3: Dn,
        CubicBezierCurve: Nn,
        CubicBezierCurve3: Fn,
        EllipseCurve: In,
        LineCurve: Hn,
        LineCurve3: Un,
        QuadraticBezierCurve: jn,
        QuadraticBezierCurve3: Gn,
        SplineCurve: Vn
    });
    Wn.prototype = Object.assign(Object.create(Pn.prototype), {
        constructor: Wn,
        add: function (e) {
            this.curves.push(e)
        },
        closePath: function () {
            var e = this.curves[0].getPoint(0),
                t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new Hn(t, e))
        },
        getPoint: function (e) {
            var t = e * this.getLength(),
                i = this.getCurveLengths();
            for (e = 0; e < i.length;) {
                if (i[e] >= t) return t = i[e] - t, i = (e = this.curves[e]).getLength(), e.getPointAt(0 === i ? 0 : 1 - t / i);
                e++
            }
            return null
        },
        getLength: function () {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function () {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function () {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var e = [], t = 0, i = 0, n = this.curves.length; i < n; i++) t += this.curves[i].getLength(), e.push(t);
            return this.cacheLengths = e
        },
        getSpacedPoints: function (e) {
            void 0 === e && (e = 40);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e));
            return this.autoClose && t.push(t[0]), t
        },
        getPoints: function (e) {
            e = e || 12;
            for (var t, i = [], n = 0, r = this.curves; n < r.length; n++) {
                var o = r[n];
                o = o.getPoints(o && o.isEllipseCurve ? 2 * e : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? e * o.points.length : e);
                for (var s = 0; s < o.length; s++) {
                    var a = o[s];
                    t && t.equals(a) || (i.push(a), t = a)
                }
            }
            return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
        },
        copy: function (e) {
            Pn.prototype.copy.call(this, e), this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) this.curves.push(e.curves[t].clone());
            return this.autoClose = e.autoClose, this
        },
        toJSON: function () {
            var e = Pn.prototype.toJSON.call(this);
            e.autoClose = this.autoClose, e.curves = [];
            for (var t = 0, i = this.curves.length; t < i; t++) e.curves.push(this.curves[t].toJSON());
            return e
        },
        fromJSON: function (e) {
            Pn.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) {
                var n = e.curves[t];
                this.curves.push((new $o[n.type]).fromJSON(n))
            }
            return this
        }
    }), qn.prototype = Object.assign(Object.create(Wn.prototype), {
        constructor: qn,
        setFromPoints: function (e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y)
        },
        moveTo: function (e, t) {
            this.currentPoint.set(e, t)
        },
        lineTo: function (e, t) {
            var n = new Hn(this.currentPoint.clone(), new i(e, t));
            this.curves.push(n), this.currentPoint.set(e, t)
        },
        quadraticCurveTo: function (e, t, n, r) {
            e = new jn(this.currentPoint.clone(), new i(e, t), new i(n, r)), this.curves.push(e), this.currentPoint.set(n, r)
        },
        bezierCurveTo: function (e, t, n, r, o, s) {
            e = new Nn(this.currentPoint.clone(), new i(e, t), new i(n, r), new i(o, s)), this.curves.push(e), this.currentPoint.set(o, s)
        },
        splineThru: function (e) {
            var t = [this.currentPoint.clone()].concat(e);
            t = new Vn(t), this.curves.push(t), this.currentPoint.copy(e[e.length - 1])
        },
        arc: function (e, t, i, n, r, o) {
            this.absarc(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, o)
        },
        absarc: function (e, t, i, n, r, o) {
            this.absellipse(e, t, i, i, n, r, o)
        },
        ellipse: function (e, t, i, n, r, o, s, a) {
            this.absellipse(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, o, s, a)
        },
        absellipse: function (e, t, i, n, r, o, s, a) {
            e = new In(e, t, i, n, r, o, s, a), 0 < this.curves.length && ((t = e.getPoint(0)).equals(this.currentPoint) || this.lineTo(t.x, t.y)), this.curves.push(e), e = e.getPoint(1), this.currentPoint.copy(e)
        },
        copy: function (e) {
            return Wn.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
        },
        toJSON: function () {
            var e = Wn.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(), e
        },
        fromJSON: function (e) {
            return Wn.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
        }
    }), Xn.prototype = Object.assign(Object.create(qn.prototype), {
        constructor: Xn,
        getPointsHoles: function (e) {
            for (var t = [], i = 0, n = this.holes.length; i < n; i++) t[i] = this.holes[i].getPoints(e);
            return t
        },
        extractPoints: function (e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        copy: function (e) {
            qn.prototype.copy.call(this, e), this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) this.holes.push(e.holes[t].clone());
            return this
        },
        toJSON: function () {
            var e = qn.prototype.toJSON.call(this);
            e.uuid = this.uuid, e.holes = [];
            for (var t = 0, i = this.holes.length; t < i; t++) e.holes.push(this.holes[t].toJSON());
            return e
        },
        fromJSON: function (e) {
            qn.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) {
                var n = e.holes[t];
                this.holes.push((new qn).fromJSON(n))
            }
            return this
        }
    }), Yn.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Yn,
        isLight: !0,
        copy: function (e) {
            return S.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
        },
        toJSON: function (e) {
            return (e = S.prototype.toJSON.call(this, e)).object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
        }
    }), Zn.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: Zn,
        isHemisphereLight: !0,
        copy: function (e) {
            return Yn.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
        }
    }), Object.assign(Qn.prototype, {
        copy: function (e) {
            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        toJSON: function () {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }), Jn.prototype = Object.assign(Object.create(Qn.prototype), {
        constructor: Jn,
        isSpotLightShadow: !0,
        update: function (e) {
            var t = this.camera,
                i = 2 * ho.RAD2DEG * e.angle,
                n = this.mapSize.width / this.mapSize.height;
            e = e.distance || t.far, i === t.fov && n === t.aspect && e === t.far || (t.fov = i, t.aspect = n, t.far = e, t.updateProjectionMatrix())
        }
    }), Kn.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: Kn,
        isSpotLight: !0,
        copy: function (e) {
            return Yn.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), $n.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: $n,
        isPointLight: !0,
        copy: function (e) {
            return Yn.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }), er.prototype = Object.assign(Object.create(xt.prototype), {
        constructor: er,
        isOrthographicCamera: !0,
        copy: function (e, t) {
            return xt.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        },
        setViewOffset: function (e, t, i, n, r, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function () {
            var e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                i = (this.right + this.left) / 2,
                n = (this.top + this.bottom) / 2,
                r = i - e;
            if (i += e, e = n + t, t = n - t, null !== this.view && this.view.enabled) {
                i = this.zoom / (this.view.width / this.view.fullWidth), t = this.zoom / (this.view.height / this.view.fullHeight);
                var o = (this.right - this.left) / this.view.width;
                n = (this.top - this.bottom) / this.view.height, i = (r += this.view.offsetX / i * o) + this.view.width / i * o, t = (e -= this.view.offsetY / t * n) - this.view.height / t * n
            }
            this.projectionMatrix.makeOrthographic(r, i, e, t, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function (e) {
            return (e = S.prototype.toJSON.call(this, e)).object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    }), tr.prototype = Object.assign(Object.create(Qn.prototype), {
        constructor: tr
    }), ir.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: ir,
        isDirectionalLight: !0,
        copy: function (e) {
            return Yn.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), nr.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: nr,
        isAmbientLight: !0
    }), rr.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: rr,
        isRectAreaLight: !0,
        copy: function (e) {
            return Yn.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
        },
        toJSON: function (e) {
            return (e = Yn.prototype.toJSON.call(this, e)).object.width = this.width, e.object.height = this.height, e
        }
    }), Object.assign(or.prototype, {
        load: function (e, t, i, n) {
            var r = this,
                o = new En(r.manager);
            o.setPath(r.path), o.load(e, (function (e) {
                t(r.parse(JSON.parse(e)))
            }), i, n)
        },
        parse: function (e) {
            function t(e) {
                return void 0 === n[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), n[e]
            }
            var n = this.textures,
                s = new Vo[e.type];
            if (void 0 !== e.uuid && (s.uuid = e.uuid), void 0 !== e.name && (s.name = e.name), void 0 !== e.color && s.color.setHex(e.color), void 0 !== e.roughness && (s.roughness = e.roughness), void 0 !== e.metalness && (s.metalness = e.metalness), void 0 !== e.emissive && s.emissive.setHex(e.emissive), void 0 !== e.specular && s.specular.setHex(e.specular), void 0 !== e.shininess && (s.shininess = e.shininess), void 0 !== e.clearCoat && (s.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (s.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.vertexColors && (s.vertexColors = e.vertexColors), void 0 !== e.fog && (s.fog = e.fog), void 0 !== e.flatShading && (s.flatShading = e.flatShading), void 0 !== e.blending && (s.blending = e.blending), void 0 !== e.combine && (s.combine = e.combine), void 0 !== e.side && (s.side = e.side), void 0 !== e.opacity && (s.opacity = e.opacity), void 0 !== e.transparent && (s.transparent = e.transparent), void 0 !== e.alphaTest && (s.alphaTest = e.alphaTest), void 0 !== e.depthTest && (s.depthTest = e.depthTest), void 0 !== e.depthWrite && (s.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (s.colorWrite = e.colorWrite), void 0 !== e.wireframe && (s.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (s.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (s.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (s.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (s.rotation = e.rotation), 1 !== e.linewidth && (s.linewidth = e.linewidth), void 0 !== e.dashSize && (s.dashSize = e.dashSize), void 0 !== e.gapSize && (s.gapSize = e.gapSize), void 0 !== e.scale && (s.scale = e.scale), void 0 !== e.polygonOffset && (s.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (s.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (s.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (s.skinning = e.skinning), void 0 !== e.morphTargets && (s.morphTargets = e.morphTargets), void 0 !== e.dithering && (s.dithering = e.dithering), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.userData && (s.userData = e.userData), void 0 !== e.uniforms)
                for (var l in e.uniforms) {
                    var c = e.uniforms[l];
                    switch (s.uniforms[l] = {}, c.type) {
                        case "t":
                            s.uniforms[l].value = t(c.value);
                            break;
                        case "c":
                            s.uniforms[l].value = (new b).setHex(c.value);
                            break;
                        case "v2":
                            s.uniforms[l].value = (new i).fromArray(c.value);
                            break;
                        case "v3":
                            s.uniforms[l].value = (new r).fromArray(c.value);
                            break;
                        case "v4":
                            s.uniforms[l].value = (new a).fromArray(c.value);
                            break;
                        case "m3":
                            s.uniforms[l].value = (new o).fromArray(c.value);
                        case "m4":
                            s.uniforms[l].value = (new g).fromArray(c.value);
                            break;
                        default:
                            s.uniforms[l].value = c.value
                    }
                }
            if (void 0 !== e.defines && (s.defines = e.defines), void 0 !== e.vertexShader && (s.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (s.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                for (var u in e.extensions) s.extensions[u] = e.extensions[u];
            return void 0 !== e.shading && (s.flatShading = 1 === e.shading), void 0 !== e.size && (s.size = e.size), void 0 !== e.sizeAttenuation && (s.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (s.map = t(e.map)), void 0 !== e.matcap && (s.matcap = t(e.matcap)), void 0 !== e.alphaMap && (s.alphaMap = t(e.alphaMap), s.transparent = !0), void 0 !== e.bumpMap && (s.bumpMap = t(e.bumpMap)), void 0 !== e.bumpScale && (s.bumpScale = e.bumpScale), void 0 !== e.normalMap && (s.normalMap = t(e.normalMap)), void 0 !== e.normalMapType && (s.normalMapType = e.normalMapType), void 0 !== e.normalScale && (l = e.normalScale, !1 === Array.isArray(l) && (l = [l, l]), s.normalScale = (new i).fromArray(l)), void 0 !== e.displacementMap && (s.displacementMap = t(e.displacementMap)), void 0 !== e.displacementScale && (s.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (s.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (s.roughnessMap = t(e.roughnessMap)), void 0 !== e.metalnessMap && (s.metalnessMap = t(e.metalnessMap)), void 0 !== e.emissiveMap && (s.emissiveMap = t(e.emissiveMap)), void 0 !== e.emissiveIntensity && (s.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (s.specularMap = t(e.specularMap)), void 0 !== e.envMap && (s.envMap = t(e.envMap)), void 0 !== e.envMapIntensity && (s.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (s.reflectivity = e.reflectivity), void 0 !== e.lightMap && (s.lightMap = t(e.lightMap)), void 0 !== e.lightMapIntensity && (s.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (s.aoMap = t(e.aoMap)), void 0 !== e.aoMapIntensity && (s.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (s.gradientMap = t(e.gradientMap)), s
        },
        setPath: function (e) {
            return this.path = e, this
        },
        setTextures: function (e) {
            return this.textures = e, this
        }
    });
    var es = {
        decodeText: function (e) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
            for (var t = "", i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]);
            try {
                return decodeURIComponent(escape(t))
            } catch (e) {
                return t
            }
        },
        extractUrlBase: function (e) {
            var t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        }
    };
    sr.prototype = Object.assign(Object.create(F.prototype), {
        constructor: sr,
        isInstancedBufferGeometry: !0,
        copy: function (e) {
            return F.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        toJSON: function () {
            var e = F.prototype.toJSON.call(this);
            return e.maxInstancedCount = this.maxInstancedCount, e.isInstancedBufferGeometry = !0, e
        }
    }), ar.prototype = Object.assign(Object.create(A.prototype), {
        constructor: ar,
        isInstancedBufferAttribute: !0,
        copy: function (e) {
            return A.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        },
        toJSON: function () {
            var e = A.prototype.toJSON.call(this);
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
        }
    }), Object.assign(lr.prototype, {
        load: function (e, t, i, n) {
            var r = this,
                o = new En(r.manager);
            o.setPath(r.path), o.load(e, (function (e) {
                t(r.parse(JSON.parse(e)))
            }), i, n)
        },
        parse: function (e) {
            var t = e.isInstancedBufferGeometry ? new sr : new F,
                i = e.data.index;
            if (void 0 !== i) {
                var n = new ts[i.type](i.array);
                t.setIndex(new A(n, 1))
            }
            for (var o in i = e.data.attributes) {
                var s = i[o];
                n = new ts[s.type](s.array), n = new(s.isInstancedBufferAttribute ? ar : A)(n, s.itemSize, s.normalized), void 0 !== s.name && (n.name = s.name), t.addAttribute(o, n)
            }
            var a = e.data.morphAttributes;
            if (a)
                for (o in a) {
                    var l = a[o],
                        c = [];
                    i = 0;
                    for (var u = l.length; i < u; i++) s = l[i], n = new A(n = new ts[s.type](s.array), s.itemSize, s.normalized), void 0 !== s.name && (n.name = s.name), c.push(n);
                    t.morphAttributes[o] = c
                }
            if (void 0 !== (o = e.data.groups || e.data.drawcalls || e.data.offsets))
                for (i = 0, s = o.length; i !== s; ++i) n = o[i], t.addGroup(n.start, n.count, n.materialIndex);
            return void 0 !== (i = e.data.boundingSphere) && (o = new r, void 0 !== i.center && o.fromArray(i.center), t.boundingSphere = new p(o, i.radius)), e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t
        },
        setPath: function (e) {
            return this.path = e, this
        }
    });
    var ts = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    Object.assign(cr.prototype, {
        crossOrigin: "anonymous",
        load: function (e, t, i, n) {
            var r = this,
                o = void 0 === this.path ? es.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || o, (o = new En(r.manager)).setPath(this.path), o.load(e, (function (i) {
                var o = null;
                try {
                    o = JSON.parse(i)
                } catch (t) {
                    return void 0 !== n && n(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                }
                void 0 === (i = o.metadata) || void 0 === i.type || "geometry" === i.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + e) : r.parse(o, t)
            }), i, n)
        },
        setPath: function (e) {
            return this.path = e, this
        },
        setResourcePath: function (e) {
            return this.resourcePath = e, this
        },
        setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        },
        parse: function (e, t) {
            var i = this.parseShape(e.shapes);
            i = this.parseGeometries(e.geometries, i);
            var n = this.parseImages(e.images, (function () {
                void 0 !== t && t(r)
            }));
            n = this.parseTextures(e.textures, n), n = this.parseMaterials(e.materials, n);
            var r = this.parseObject(e.object, i, n);
            return e.animations && (r.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 === t || t(r), r
        },
        parseShape: function (e) {
            var t = {};
            if (void 0 !== e)
                for (var i = 0, n = e.length; i < n; i++) {
                    var r = (new Xn).fromJSON(e[i]);
                    t[r.uuid] = r
                }
            return t
        },
        parseGeometries: function (e, t) {
            var i = {};
            if (void 0 !== e)
                for (var n = new lr, r = 0, o = e.length; r < o; r++) {
                    var s = e[r];
                    switch (s.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            var a = new Go[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            a = new Go[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            a = new Go[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            a = new Go[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            a = new Go[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            a = new Go[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                            a = new Go[s.type](s.radius, s.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            a = new Go[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            a = new Go[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            a = new Go[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                            break;
                        case "TubeGeometry":
                        case "TubeBufferGeometry":
                            a = new Go[s.type]((new $o[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            a = new Go[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                            break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                            a = new Go[s.type](s.vertices, s.indices, s.radius, s.details);
                            break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                            a = [];
                            for (var l = 0, c = s.shapes.length; l < c; l++) {
                                var u = t[s.shapes[l]];
                                a.push(u)
                            }
                            a = new Go[s.type](a, s.curveSegments);
                            break;
                        case "ExtrudeGeometry":
                        case "ExtrudeBufferGeometry":
                            for (a = [], l = 0, c = s.shapes.length; l < c; l++) u = t[s.shapes[l]], a.push(u);
                            void 0 !== (l = s.options.extrudePath) && (s.options.extrudePath = (new $o[l.type]).fromJSON(l)), a = new Go[s.type](a, s.options);
                            break;
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            a = n.parse(s);
                            break;
                        case "Geometry":
                            "THREE" in window && "LegacyJSONLoader" in THREE ? a = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                            continue
                    }
                    a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), i[s.uuid] = a
                }
            return i
        },
        parseMaterials: function (e, t) {
            var i = {},
                n = {};
            if (void 0 !== e) {
                var r = new or;
                r.setTextures(t), t = 0;
                for (var o = e.length; t < o; t++) {
                    var s = e[t];
                    if ("MultiMaterial" === s.type) {
                        for (var a = [], l = 0; l < s.materials.length; l++) {
                            var c = s.materials[l];
                            void 0 === i[c.uuid] && (i[c.uuid] = r.parse(c)), a.push(i[c.uuid])
                        }
                        n[s.uuid] = a
                    } else void 0 === i[s.uuid] && (i[s.uuid] = r.parse(s)), n[s.uuid] = i[s.uuid]
                }
            }
            return n
        },
        parseAnimations: function (e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = e[i],
                    r = xn.parse(n);
                void 0 !== n.uuid && (r.uuid = n.uuid), t.push(r)
            }
            return t
        },
        parseImages: function (e, t) {
            function i(e) {
                return n.manager.itemStart(e), o.load(e, (function () {
                    n.manager.itemEnd(e)
                }), void 0, (function () {
                    n.manager.itemError(e), n.manager.itemEnd(e)
                }))
            }
            var n = this,
                r = {};
            if (void 0 !== e && 0 < e.length) {
                var o = new An(t = new _n(t));
                o.setCrossOrigin(this.crossOrigin), t = 0;
                for (var s = e.length; t < s; t++) {
                    var a = e[t],
                        l = a.url;
                    if (Array.isArray(l)) {
                        r[a.uuid] = [];
                        for (var c = 0, u = l.length; c < u; c++) {
                            var h = l[c];
                            h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h) ? h : n.resourcePath + h, r[a.uuid].push(i(h))
                        }
                    } else h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a.url) ? a.url : n.resourcePath + a.url, r[a.uuid] = i(h)
                }
            }
            return r
        },
        parseTextures: function (e, t) {
            function i(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
            }
            var n = {};
            if (void 0 !== e)
                for (var r = 0, o = e.length; r < o; r++) {
                    var a = e[r];
                    void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === t[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                    var l = Array.isArray(t[a.image]) ? new ae(t[a.image]) : new s(t[a.image]);
                    l.needsUpdate = !0, l.uuid = a.uuid, void 0 !== a.name && (l.name = a.name), void 0 !== a.mapping && (l.mapping = i(a.mapping, is)), void 0 !== a.offset && l.offset.fromArray(a.offset), void 0 !== a.repeat && l.repeat.fromArray(a.repeat), void 0 !== a.center && l.center.fromArray(a.center), void 0 !== a.rotation && (l.rotation = a.rotation), void 0 !== a.wrap && (l.wrapS = i(a.wrap[0], ns), l.wrapT = i(a.wrap[1], ns)), void 0 !== a.format && (l.format = a.format), void 0 !== a.type && (l.type = a.type), void 0 !== a.encoding && (l.encoding = a.encoding), void 0 !== a.minFilter && (l.minFilter = i(a.minFilter, rs)), void 0 !== a.magFilter && (l.magFilter = i(a.magFilter, rs)), void 0 !== a.anisotropy && (l.anisotropy = a.anisotropy), void 0 !== a.flipY && (l.flipY = a.flipY), void 0 !== a.premultiplyAlpha && (l.premultiplyAlpha = a.premultiplyAlpha), void 0 !== a.unpackAlignment && (l.unpackAlignment = a.unpackAlignment), n[a.uuid] = l
                }
            return n
        },
        parseObject: function (e, t, i) {
            function n(e) {
                return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
            }

            function r(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        for (var t = [], n = 0, r = e.length; n < r; n++) {
                            var o = e[n];
                            void 0 === i[o] && console.warn("THREE.ObjectLoader: Undefined material", o), t.push(i[o])
                        }
                        return t
                    }
                    return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined material", e), i[e]
                }
            }
            switch (e.type) {
                case "Scene":
                    var o = new Lt;
                    void 0 !== e.background && Number.isInteger(e.background) && (o.background = new b(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? o.fog = new Ct(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (o.fog = new At(e.fog.color, e.fog.density)));
                    break;
                case "PerspectiveCamera":
                    o = new wt(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (o.focus = e.focus), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.filmGauge && (o.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (o.filmOffset = e.filmOffset), void 0 !== e.view && (o.view = Object.assign({}, e.view));
                    break;
                case "OrthographicCamera":
                    o = new er(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.view && (o.view = Object.assign({}, e.view));
                    break;
                case "AmbientLight":
                    o = new nr(e.color, e.intensity);
                    break;
                case "DirectionalLight":
                    o = new ir(e.color, e.intensity);
                    break;
                case "PointLight":
                    o = new $n(e.color, e.intensity, e.distance, e.decay);
                    break;
                case "RectAreaLight":
                    o = new rr(e.color, e.intensity, e.width, e.height);
                    break;
                case "SpotLight":
                    o = new Kn(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                    break;
                case "HemisphereLight":
                    o = new Zn(e.color, e.groundColor, e.intensity);
                    break;
                case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case "Mesh":
                    o = n(e.geometry);
                    var s = r(e.material);
                    o = o.bones && 0 < o.bones.length ? new kt(o, s) : new Z(o, s), void 0 !== e.drawMode && o.setDrawMode(e.drawMode);
                    break;
                case "LOD":
                    o = new Dt;
                    break;
                case "Line":
                    o = new Ft(n(e.geometry), r(e.material), e.mode);
                    break;
                case "LineLoop":
                    o = new Ut(n(e.geometry), r(e.material));
                    break;
                case "LineSegments":
                    o = new Ht(n(e.geometry), r(e.material));
                    break;
                case "PointCloud":
                case "Points":
                    o = new Gt(n(e.geometry), r(e.material));
                    break;
                case "Sprite":
                    o = new Rt(r(e.material));
                    break;
                case "Group":
                    o = new bt;
                    break;
                default:
                    o = new S
            }
            if (o.uuid = e.uuid, void 0 !== e.name && (o.name = e.name), void 0 !== e.matrix ? (o.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== e.position && o.position.fromArray(e.position), void 0 !== e.rotation && o.rotation.fromArray(e.rotation), void 0 !== e.quaternion && o.quaternion.fromArray(e.quaternion), void 0 !== e.scale && o.scale.fromArray(e.scale)), void 0 !== e.castShadow && (o.castShadow = e.castShadow), void 0 !== e.receiveShadow && (o.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (o.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (o.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && o.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (o.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (o.visible = e.visible), void 0 !== e.frustumCulled && (o.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (o.renderOrder = e.renderOrder), void 0 !== e.userData && (o.userData = e.userData), void 0 !== e.layers && (o.layers.mask = e.layers), void 0 !== e.children) {
                s = e.children;
                for (var a = 0; a < s.length; a++) o.add(this.parseObject(s[a], t, i))
            }
            if ("LOD" === e.type)
                for (e = e.levels, s = 0; s < e.length; s++) {
                    a = e[s];
                    var l = o.getObjectByProperty("uuid", a.object);
                    void 0 !== l && o.addLevel(l, a.distance)
                }
            return o
        }
    });
    var is = {
            UVMapping: 300,
            CubeReflectionMapping: 301,
            CubeRefractionMapping: 302,
            EquirectangularReflectionMapping: 303,
            EquirectangularRefractionMapping: 304,
            SphericalReflectionMapping: 305,
            CubeUVReflectionMapping: 306,
            CubeUVRefractionMapping: 307
        },
        ns = {
            RepeatWrapping: 1e3,
            ClampToEdgeWrapping: 1001,
            MirroredRepeatWrapping: 1002
        },
        rs = {
            NearestFilter: 1003,
            NearestMipMapNearestFilter: 1004,
            NearestMipMapLinearFilter: 1005,
            LinearFilter: 1006,
            LinearMipMapNearestFilter: 1007,
            LinearMipMapLinearFilter: 1008
        };
    ur.prototype = {
        constructor: ur,
        setOptions: function (e) {
            return this.options = e, this
        },
        load: function (e, t, i, n) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var r = this,
                o = qo.get(e);
            if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function () {
                t && t(o), r.manager.itemEnd(e)
            }), 0), o;
            fetch(e).then((function (e) {
                return e.blob()
            })).then((function (e) {
                return void 0 === r.options ? createImageBitmap(e) : createImageBitmap(e, r.options)
            })).then((function (i) {
                qo.add(e, i), t && t(i), r.manager.itemEnd(e)
            })).catch((function (t) {
                n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
            })), r.manager.itemStart(e)
        },
        setCrossOrigin: function () {
            return this
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }, Object.assign(hr.prototype, {
        moveTo: function (e, t) {
            this.currentPath = new qn, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
        },
        lineTo: function (e, t) {
            this.currentPath.lineTo(e, t)
        },
        quadraticCurveTo: function (e, t, i, n) {
            this.currentPath.quadraticCurveTo(e, t, i, n)
        },
        bezierCurveTo: function (e, t, i, n, r, o) {
            this.currentPath.bezierCurveTo(e, t, i, n, r, o)
        },
        splineThru: function (e) {
            this.currentPath.splineThru(e)
        },
        toShapes: function (e, t) {
            function i(e) {
                for (var t = [], i = 0, n = e.length; i < n; i++) {
                    var r = e[i],
                        o = new Xn;
                    o.curves = r.curves, t.push(o)
                }
                return t
            }

            function n(e, t) {
                for (var i = t.length, n = !1, r = i - 1, o = 0; o < i; r = o++) {
                    var s = t[r],
                        a = t[o],
                        l = a.x - s.x,
                        c = a.y - s.y;
                    if (Math.abs(c) > Number.EPSILON) {
                        if (0 > c && (s = t[o], l = -l, a = t[r], c = -c), !(e.y < s.y || e.y > a.y))
                            if (e.y === s.y) {
                                if (e.x === s.x) return !0
                            } else {
                                if (0 === (r = c * (e.x - s.x) - l * (e.y - s.y))) return !0;
                                0 > r || (n = !n)
                            }
                    } else if (e.y === s.y && (a.x <= e.x && e.x <= s.x || s.x <= e.x && e.x <= a.x)) return !0
                }
                return n
            }
            var r = Uo.isClockWise,
                o = this.subPaths;
            if (0 === o.length) return [];
            if (!0 === t) return i(o);
            if (t = [], 1 === o.length) {
                var s = o[0],
                    a = new Xn;
                return a.curves = s.curves, t.push(a), t
            }
            var l = !r(o[0].getPoints());
            l = e ? !l : l, a = [];
            var c = [],
                u = [],
                h = 0;
            c[h] = void 0, u[h] = [];
            for (var d = 0, p = o.length; d < p; d++) {
                var f = (s = o[d]).getPoints(),
                    m = r(f);
                (m = e ? !m : m) ? (!l && c[h] && h++, c[h] = {
                    s: new Xn,
                    p: f
                }, c[h].s.curves = s.curves, l && h++, u[h] = []) : u[h].push({
                    h: s,
                    p: f[0]
                })
            }
            if (!c[0]) return i(o);
            if (1 < c.length) {
                for (d = !1, e = [], r = 0, o = c.length; r < o; r++) a[r] = [];
                for (r = 0, o = c.length; r < o; r++)
                    for (s = u[r], m = 0; m < s.length; m++) {
                        for (l = s[m], h = !0, f = 0; f < c.length; f++) n(l.p, c[f].p) && (r !== f && e.push({
                            froms: r,
                            tos: f,
                            hole: m
                        }), h ? (h = !1, a[f].push(l)) : d = !0);
                        h && a[r].push(l)
                    }
                0 < e.length && (d || (u = a))
            }
            for (d = 0, r = c.length; d < r; d++)
                for (a = c[d].s, t.push(a), o = 0, s = (e = u[d]).length; o < s; o++) a.holes.push(e[o].h);
            return t
        }
    }), Object.assign(dr.prototype, {
        isFont: !0,
        generateShapes: function (e, t) {
            void 0 === t && (t = 100);
            var i = [],
                n = t;
            t = this.data;
            var r = Array.from ? Array.from(e) : String(e).split("");
            n /= t.resolution;
            var o = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * n;
            e = [];
            for (var s = 0, a = 0, l = 0; l < r.length; l++) {
                var c = r[l];
                if ("\n" === c) s = 0, a -= o;
                else {
                    var u = n,
                        h = s,
                        d = a;
                    if (c = t.glyphs[c] || t.glyphs["?"]) {
                        var p = new hr;
                        if (c.o)
                            for (var f = c._cachedOutline || (c._cachedOutline = c.o.split(" ")), m = 0, g = f.length; m < g;) switch (f[m++]) {
                                case "m":
                                    var v = f[m++] * u + h,
                                        y = f[m++] * u + d;
                                    p.moveTo(v, y);
                                    break;
                                case "l":
                                    v = f[m++] * u + h, y = f[m++] * u + d, p.lineTo(v, y);
                                    break;
                                case "q":
                                    var b = f[m++] * u + h,
                                        x = f[m++] * u + d,
                                        w = f[m++] * u + h,
                                        _ = f[m++] * u + d;
                                    p.quadraticCurveTo(w, _, b, x);
                                    break;
                                case "b":
                                    b = f[m++] * u + h, x = f[m++] * u + d, w = f[m++] * u + h, _ = f[m++] * u + d, v = f[m++] * u + h, y = f[m++] * u + d, p.bezierCurveTo(w, _, v, y, b, x)
                            }
                        u = {
                            offsetX: c.ha * u,
                            path: p
                        }
                    } else u = void 0;
                    s += u.offsetX, e.push(u.path)
                }
            }
            for (t = 0, r = e.length; t < r; t++) Array.prototype.push.apply(i, e[t].toShapes());
            return i
        }
    }), Object.assign(pr.prototype, {
        load: function (e, t, i, n) {
            var r = this,
                o = new En(this.manager);
            o.setPath(this.path), o.load(e, (function (e) {
                try {
                    var i = JSON.parse(e)
                } catch (t) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(e.substring(65, e.length - 2))
                }
                e = r.parse(i), t && t(e)
            }), i, n)
        },
        parse: function (e) {
            return new dr(e)
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), fr.Handlers = {
        handlers: [],
        add: function (e, t) {
            this.handlers.push(e, t)
        },
        get: function (e) {
            for (var t = this.handlers, i = 0, n = t.length; i < n; i += 2) {
                var r = t[i + 1];
                if (t[i].test(e)) return r
            }
            return null
        }
    }, Object.assign(fr.prototype, {
        crossOrigin: "anonymous",
        onLoadStart: function () {},
        onLoadProgress: function () {},
        onLoadComplete: function () {},
        initMaterials: function (e, t, i) {
            for (var n = [], r = 0; r < e.length; ++r) n[r] = this.createMaterial(e[r], t, i);
            return n
        },
        createMaterial: function () {
            var e = {
                    NoBlending: 0,
                    NormalBlending: 1,
                    AdditiveBlending: 2,
                    SubtractiveBlending: 3,
                    MultiplyBlending: 4,
                    CustomBlending: 5
                },
                t = new b,
                i = new Ln,
                n = new or;
            return function (r, o, s) {
                function a(e, t, n, r, a) {
                    e = o + e;
                    var l = fr.Handlers.get(e);
                    return null !== l ? e = l.load(e) : (i.setCrossOrigin(s), e = i.load(e)), void 0 !== t && (e.repeat.fromArray(t), 1 !== t[0] && (e.wrapS = 1e3), 1 !== t[1] && (e.wrapT = 1e3)), void 0 !== n && e.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (e.wrapS = 1e3), "mirror" === r[0] && (e.wrapS = 1002), "repeat" === r[1] && (e.wrapT = 1e3), "mirror" === r[1] && (e.wrapT = 1002)), void 0 !== a && (e.anisotropy = a), t = ho.generateUUID(), c[t] = e, t
                }
                var l, c = {},
                    u = {
                        uuid: ho.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                for (l in r) {
                    var h = r[l];
                    switch (l) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            u.name = h;
                            break;
                        case "blending":
                            u.blending = e[h];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                            break;
                        case "colorDiffuse":
                            u.color = t.fromArray(h).getHex();
                            break;
                        case "colorSpecular":
                            u.specular = t.fromArray(h).getHex();
                            break;
                        case "colorEmissive":
                            u.emissive = t.fromArray(h).getHex();
                            break;
                        case "specularCoef":
                            u.shininess = h;
                            break;
                        case "shading":
                            "basic" === h.toLowerCase() && (u.type = "MeshBasicMaterial"), "phong" === h.toLowerCase() && (u.type = "MeshPhongMaterial"), "standard" === h.toLowerCase() && (u.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            u.map = a(h, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapEmissive":
                            u.emissiveMap = a(h, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                            break;
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                            break;
                        case "mapLight":
                            u.lightMap = a(h, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            u.aoMap = a(h, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            u.bumpMap = a(h, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            u.bumpScale = h;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            u.normalMap = a(h, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            u.normalScale = h;
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            u.specularMap = a(h, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapMetalness":
                            u.metalnessMap = a(h, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                            break;
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                            break;
                        case "mapRoughness":
                            u.roughnessMap = a(h, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                            break;
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                            break;
                        case "mapAlpha":
                            u.alphaMap = a(h, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            u.side = 1;
                            break;
                        case "doubleSided":
                            u.side = 2;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), u.opacity = h;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            u[l] = h;
                            break;
                        case "vertexColors":
                            !0 === h && (u.vertexColors = 2), "face" === h && (u.vertexColors = 1);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", l, h)
                    }
                }
                return "MeshBasicMaterial" === u.type && delete u.emissive, "MeshPhongMaterial" !== u.type && delete u.specular, 1 > u.opacity && (u.transparent = !0), n.setTextures(c), n.parse(u)
            }
        }()
    });
    var os, ss, as, ls = {
        getContext: function () {
            return void 0 === os && (os = new(window.AudioContext || window.webkitAudioContext)), os
        },
        setContext: function (e) {
            os = e
        }
    };
    Object.assign(mr.prototype, {
        load: function (e, t, i, n) {
            var r = new En(this.manager);
            r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(e, (function (e) {
                e = e.slice(0), ls.getContext().decodeAudioData(e, (function (e) {
                    t(e)
                }))
            }), i, n)
        },
        setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(gr.prototype, {
        isSphericalHarmonics3: !0,
        set: function (e) {
            for (var t = 0; 9 > t; t++) this.coefficients[t].copy(e[t]);
            return this
        },
        zero: function () {
            for (var e = 0; 9 > e; e++) this.coefficients[e].set(0, 0, 0);
            return this
        },
        getAt: function (e, t) {
            var i = e.x,
                n = e.y;
            e = e.z;
            var r = this.coefficients;
            return t = .282095 * r[0], t += .488603 * r[1] * n, t += .488603 * r[2] * e, t += .488603 * r[3] * i, t += 1.092548 * r[4] * i * n, t += 1.092548 * r[5] * n * e, t += .315392 * r[6] * (3 * e * e - 1), (t += 1.092548 * r[7] * i * e) + .546274 * r[8] * (i * i - n * n)
        },
        getIrradianceAt: function (e, t) {
            var i = e.x,
                n = e.y;
            e = e.z;
            var r = this.coefficients;
            return t = .886227 * r[0], t += 1.023328 * r[1] * n, t += 1.023328 * r[2] * e, t += 1.023328 * r[3] * i, t += .858086 * r[4] * i * n, t += .858086 * r[5] * n * e, t += r[6] * (.743125 * e * e - .247708), (t += .858086 * r[7] * i * e) + .429043 * r[8] * (i * i - n * n)
        },
        add: function (e) {
            for (var t = 0; 9 > t; t++) this.coefficients[t].add(e.coefficients[t]);
            return this
        },
        scale: function (e) {
            for (var t = 0; 9 > t; t++) this.coefficients[t].multiplyScalar(e);
            return this
        },
        lerp: function (e, t) {
            for (var i = 0; 9 > i; i++) this.coefficients[i].lerp(e.coefficients[i], t);
            return this
        },
        equals: function (e) {
            for (var t = 0; 9 > t; t++)
                if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
            return !0
        },
        copy: function (e) {
            return this.set(e.coefficients)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        fromArray: function (e) {
            for (var t = this.coefficients, i = 0; 9 > i; i++) t[i].fromArray(e, 3 * i);
            return this
        },
        toArray: function () {
            for (var e = [], t = this.coefficients, i = 0; 9 > i; i++) t[i].toArray(e, 3 * i);
            return e
        }
    }), Object.assign(gr, {
        getBasisAt: function (e, t) {
            var i = e.x,
                n = e.y;
            e = e.z, t[0] = .282095, t[1] = .488603 * n, t[2] = .488603 * e, t[3] = .488603 * i, t[4] = 1.092548 * i * n, t[5] = 1.092548 * n * e, t[6] = .315392 * (3 * e * e - 1), t[7] = 1.092548 * i * e, t[8] = .546274 * (i * i - n * n)
        }
    }), vr.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: vr,
        isLightProbe: !0,
        copy: function (e) {
            return Yn.prototype.copy.call(this, e), this.sh.copy(e.sh), this.intensity = e.intensity, this
        },
        toJSON: function (e) {
            return Yn.prototype.toJSON.call(this, e)
        }
    }), yr.prototype = Object.assign(Object.create(vr.prototype), {
        constructor: yr,
        isHemisphereLightProbe: !0,
        copy: function (e) {
            return vr.prototype.copy.call(this, e), this
        },
        toJSON: function (e) {
            return vr.prototype.toJSON.call(this, e)
        }
    }), br.prototype = Object.assign(Object.create(vr.prototype), {
        constructor: br,
        isAmbientLightProbe: !0,
        copy: function (e) {
            return vr.prototype.copy.call(this, e), this
        },
        toJSON: function (e) {
            return vr.prototype.toJSON.call(this, e)
        }
    }), Object.assign(xr.prototype, {
        update: function () {
            var e, t, i, n, r, o, s, a, l = new g,
                c = new g;
            return function (u) {
                if (e !== this || t !== u.focus || i !== u.fov || n !== u.aspect * this.aspect || r !== u.near || o !== u.far || s !== u.zoom || a !== this.eyeSep) {
                    e = this, t = u.focus, i = u.fov, n = u.aspect * this.aspect, r = u.near, o = u.far, s = u.zoom;
                    var h = u.projectionMatrix.clone(),
                        d = (a = this.eyeSep / 2) * r / t,
                        p = r * Math.tan(ho.DEG2RAD * i * .5) / s;
                    c.elements[12] = -a, l.elements[12] = a;
                    var f = -p * n + d,
                        m = p * n + d;
                    h.elements[0] = 2 * r / (m - f), h.elements[8] = (m + f) / (m - f), this.cameraL.projectionMatrix.copy(h), f = -p * n - d, m = p * n - d, h.elements[0] = 2 * r / (m - f), h.elements[8] = (m + f) / (m - f), this.cameraR.projectionMatrix.copy(h)
                }
                this.cameraL.matrixWorld.copy(u.matrixWorld).multiply(c), this.cameraR.matrixWorld.copy(u.matrixWorld).multiply(l)
            }
        }()
    }), wr.prototype = Object.create(S.prototype), wr.prototype.constructor = wr, Object.assign(_r.prototype, {
        start: function () {
            this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0
        },
        stop: function () {
            this.getElapsedTime(), this.autoStart = this.running = !1
        },
        getElapsedTime: function () {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function () {
            var e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var t = ("undefined" == typeof performance ? Date : performance).now();
                e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
            }
            return e
        }
    }), Er.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Er,
        getInput: function () {
            return this.gain
        },
        removeFilter: function () {
            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
        },
        getFilter: function () {
            return this.filter
        },
        setFilter: function (e) {
            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
        },
        getMasterVolume: function () {
            return this.gain.gain.value
        },
        setMasterVolume: function (e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        },
        updateMatrixWorld: function () {
            var e = new r,
                t = new n,
                i = new r,
                o = new r,
                s = new _r;
            return function (n) {
                S.prototype.updateMatrixWorld.call(this, n), n = this.context.listener;
                var r = this.up;
                if (this.timeDelta = s.getDelta(), this.matrixWorld.decompose(e, t, i), o.set(0, 0, -1).applyQuaternion(t), n.positionX) {
                    var a = this.context.currentTime + this.timeDelta;
                    n.positionX.linearRampToValueAtTime(e.x, a), n.positionY.linearRampToValueAtTime(e.y, a), n.positionZ.linearRampToValueAtTime(e.z, a), n.forwardX.linearRampToValueAtTime(o.x, a), n.forwardY.linearRampToValueAtTime(o.y, a), n.forwardZ.linearRampToValueAtTime(o.z, a), n.upX.linearRampToValueAtTime(r.x, a), n.upY.linearRampToValueAtTime(r.y, a), n.upZ.linearRampToValueAtTime(r.z, a)
                } else n.setPosition(e.x, e.y, e.z), n.setOrientation(o.x, o.y, o.z, r.x, r.y, r.z)
            }
        }()
    }), Mr.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Mr,
        getOutput: function () {
            return this.gain
        },
        setNodeSource: function (e) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
        },
        setMediaElementSource: function (e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
        },
        setBuffer: function (e) {
            return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
        },
        play: function () {
            if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
            else {
                if (!1 !== this.hasPlaybackControl) {
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
        },
        pause: function () {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function () {
            if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function () {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        },
        disconnect: function () {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function () {
            return this.filters
        },
        setFilters: function (e) {
            return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
        },
        setDetune: function (e) {
            if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
        },
        getDetune: function () {
            return this.detune
        },
        getFilter: function () {
            return this.getFilters()[0]
        },
        setFilter: function (e) {
            return this.setFilters(e ? [e] : [])
        },
        setPlaybackRate: function (e) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function () {
            return this.playbackRate
        },
        onEnded: function () {
            this.isPlaying = !1
        },
        getLoop: function () {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        },
        setLoop: function (e) {
            if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getVolume: function () {
            return this.gain.gain.value
        },
        setVolume: function (e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        }
    }), Sr.prototype = Object.assign(Object.create(Mr.prototype), {
        constructor: Sr,
        getOutput: function () {
            return this.panner
        },
        getRefDistance: function () {
            return this.panner.refDistance
        },
        setRefDistance: function (e) {
            return this.panner.refDistance = e, this
        },
        getRolloffFactor: function () {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function (e) {
            return this.panner.rolloffFactor = e, this
        },
        getDistanceModel: function () {
            return this.panner.distanceModel
        },
        setDistanceModel: function (e) {
            return this.panner.distanceModel = e, this
        },
        getMaxDistance: function () {
            return this.panner.maxDistance
        },
        setMaxDistance: function (e) {
            return this.panner.maxDistance = e, this
        },
        setDirectionalCone: function (e, t, i) {
            return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this
        },
        updateMatrixWorld: function () {
            var e = new r,
                t = new n,
                i = new r,
                o = new r;
            return function (n) {
                if (S.prototype.updateMatrixWorld.call(this, n), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
                    if (this.matrixWorld.decompose(e, t, i), o.set(0, 0, 1).applyQuaternion(t), (n = this.panner).positionX) {
                        var r = this.context.currentTime + this.listener.timeDelta;
                        n.positionX.linearRampToValueAtTime(e.x, r), n.positionY.linearRampToValueAtTime(e.y, r), n.positionZ.linearRampToValueAtTime(e.z, r), n.orientationX.linearRampToValueAtTime(o.x, r), n.orientationY.linearRampToValueAtTime(o.y, r), n.orientationZ.linearRampToValueAtTime(o.z, r)
                    } else n.setPosition(e.x, e.y, e.z), n.setOrientation(o.x, o.y, o.z)
            }
        }()
    }), Object.assign(Tr.prototype, {
        getFrequencyData: function () {
            return this.analyser.getByteFrequencyData(this.data), this.data
        },
        getAverageFrequency: function () {
            for (var e = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++) e += t[i];
            return e / t.length
        }
    }), Object.assign(Ar.prototype, {
        accumulate: function (e, t) {
            var i = this.buffer,
                n = this.valueSize;
            e = e * n + n;
            var r = this.cumulativeWeight;
            if (0 === r) {
                for (r = 0; r !== n; ++r) i[e + r] = i[r];
                r = t
            } else r += t, this._mixBufferRegion(i, e, 0, t / r, n);
            this.cumulativeWeight = r
        },
        apply: function (e) {
            var t = this.valueSize,
                i = this.buffer;
            e = e * t + t;
            var n = this.cumulativeWeight,
                r = this.binding;
            this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, e, 3 * t, 1 - n, t), n = t;
            for (var o = t + t; n !== o; ++n)
                if (i[n] !== i[n + t]) {
                    r.setValue(i, e);
                    break
                }
        },
        saveOriginalState: function () {
            var e = this.buffer,
                t = this.valueSize,
                i = 3 * t;
            this.binding.getValue(e, i);
            for (var n = t; n !== i; ++n) e[n] = e[i + n % t];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function () {
            this.binding.setValue(this.buffer, 3 * this.valueSize)
        },
        _select: function (e, t, i, n, r) {
            if (.5 <= n)
                for (n = 0; n !== r; ++n) e[t + n] = e[i + n]
        },
        _slerp: function (e, t, i, r) {
            n.slerpFlat(e, t, e, t, e, i, r)
        },
        _lerp: function (e, t, i, n, r) {
            for (var o = 1 - n, s = 0; s !== r; ++s) {
                var a = t + s;
                e[a] = e[a] * o + e[i + s] * n
            }
        }
    }), Object.assign(Cr.prototype, {
        getValue: function (e, t) {
            this.bind();
            var i = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== i && i.getValue(e, t)
        },
        setValue: function (e, t) {
            for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(e, t)
        },
        bind: function () {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
        },
        unbind: function () {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
        }
    }), Object.assign(Lr, {
        Composite: Cr,
        create: function (e, t, i) {
            return e && e.isAnimationObjectGroup ? new Lr.Composite(e, t, i) : new Lr(e, t, i)
        },
        sanitizeNodeName: function () {
            var e = /[\[\]\.:\/]/g;
            return function (t) {
                return t.replace(/\s/g, "_").replace(e, "")
            }
        }(),
        parseTrackName: function () {
            var e = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                t = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
            e = /(WCOD+)?/.source.replace("WCOD", e);
            var i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                n = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                r = new RegExp("^" + t + e + i + n + "$"),
                o = ["material", "materials", "bones"];
            return function (e) {
                var t = r.exec(e);
                if (!t) throw Error("PropertyBinding: Cannot parse trackName: " + e);
                var i = (t = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                }).nodeName && t.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    var n = t.nodeName.substring(i + 1); - 1 !== o.indexOf(n) && (t.nodeName = t.nodeName.substring(0, i), t.objectName = n)
                }
                if (null === t.propertyName || 0 === t.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return t
            }
        }(),
        findNode: function (e, t) {
            if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
            if (e.skeleton) {
                var i = e.skeleton.getBoneByName(t);
                if (void 0 !== i) return i
            }
            if (e.children) {
                var n = function (e) {
                    for (var i = 0; i < e.length; i++) {
                        var r = e[i];
                        if (r.name === t || r.uuid === t || (r = n(r.children))) return r
                    }
                    return null
                };
                if (e = n(e.children)) return e
            }
            return null
        }
    }), Object.assign(Lr.prototype, {
        _getValue_unavailable: function () {},
        _setValue_unavailable: function () {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function (e, t) {
            e[t] = this.node[this.propertyName]
        }, function (e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) e[t++] = i[n]
        }, function (e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }, function (e, t) {
            this.resolvedProperty.toArray(e, t)
        }],
        SetterByBindingTypeAndVersioning: [
            [function (e, t) {
                this.targetObject[this.propertyName] = e[t]
            }, function (e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
            }, function (e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++]
            }, function (e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                this.targetObject.needsUpdate = !0
            }, function (e, t) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }, function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
            }, function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (e, t) {
                this.resolvedProperty.fromArray(e, t)
            }, function (e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
            }, function (e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
            }]
        ],
        getValue: function (e, t) {
            this.bind(), this.getValue(e, t)
        },
        setValue: function (e, t) {
            this.bind(), this.setValue(e, t)
        },
        bind: function () {
            var e = this.node,
                t = this.parsedPath,
                i = t.objectName,
                n = t.propertyName,
                r = t.propertyIndex;
            if (e || (this.node = e = Lr.findNode(this.rootNode, t.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                if (i) {
                    var o = t.objectIndex;
                    switch (i) {
                        case "materials":
                            if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            for (e = e.skeleton.bones, i = 0; i < e.length; i++)
                                if (e[i].name === o) {
                                    o = i;
                                    break
                                } break;
                        default:
                            if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[i]
                    }
                    if (void 0 !== o) {
                        if (void 0 === e[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[o]
                    }
                }
                if (void 0 === (o = e[n])) console.error("THREE.PropertyBinding: Trying to update property for track: " + t.nodeName + "." + n + " but it wasn't found.", e);
                else {
                    if (t = this.Versioning.None, this.targetObject = e, void 0 !== e.needsUpdate ? t = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (t = this.Versioning.MatrixWorldNeedsUpdate), i = this.BindingType.Direct, void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                                    if (e.geometry.morphAttributes.position[i].name === r) {
                                        r = i;
                                        break
                                    }
                            } else {
                                if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                                    if (e.geometry.morphTargets[i].name === r) {
                                        r = i;
                                        break
                                    }
                            }
                        }
                        i = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                    } else void 0 !== o.fromArray && void 0 !== o.toArray ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (i = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][t]
                }
            } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function () {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }), Object.assign(Lr.prototype, {
        _getValue_unbound: Lr.prototype.getValue,
        _setValue_unbound: Lr.prototype.setValue
    }), Object.assign(Pr.prototype, {
        isAnimationObjectGroup: !0,
        add: function () {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, o = this._parsedPaths, s = this._bindings, a = s.length, l = void 0, c = 0, u = arguments.length; c !== u; ++c) {
                var h = arguments[c],
                    d = h.uuid,
                    p = n[d];
                if (void 0 === p) {
                    p = t++, n[d] = p, e.push(h), d = 0;
                    for (var f = a; d !== f; ++d) s[d].push(new Lr(h, r[d], o[d]))
                } else if (p < i) {
                    l = e[p];
                    var m = --i;
                    for (n[(f = e[m]).uuid] = p, e[p] = f, n[d] = m, e[m] = h, d = 0, f = a; d !== f; ++d) {
                        var g = s[d],
                            v = g[p];
                        g[p] = g[m], void 0 === v && (v = new Lr(h, r[d], o[d])), g[m] = v
                    }
                } else e[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = i
        },
        remove: function () {
            for (var e = this._objects, t = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, o = 0, s = arguments.length; o !== s; ++o) {
                var a = arguments[o],
                    l = a.uuid,
                    c = i[l];
                if (void 0 !== c && c >= t) {
                    var u = t++,
                        h = e[u];
                    for (i[h.uuid] = c, e[c] = h, i[l] = u, e[u] = a, a = 0, l = r; a !== l; ++a) {
                        var d = (h = n[a])[c];
                        h[c] = h[u], h[u] = d
                    }
                }
            }
            this.nCachedObjects_ = t
        },
        uncache: function () {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, o = r.length, s = 0, a = arguments.length; s !== a; ++s) {
                var l = arguments[s].uuid,
                    c = n[l];
                if (void 0 !== c)
                    if (delete n[l], c < i) {
                        var u = e[l = --i],
                            h = --t,
                            d = e[h];
                        for (n[u.uuid] = c, e[c] = u, n[d.uuid] = l, e[l] = d, e.pop(), u = 0, d = o; u !== d; ++u) {
                            var p = r[u],
                                f = p[h];
                            p[c] = p[l], p[l] = f, p.pop()
                        }
                    } else
                        for (n[(d = e[h = --t]).uuid] = c, e[c] = d, e.pop(), u = 0, d = o; u !== d; ++u)(p = r[u])[c] = p[h], p.pop()
            }
            this.nCachedObjects_ = i
        },
        subscribe_: function (e, t) {
            var i = this._bindingsIndicesByPath,
                n = i[e],
                r = this._bindings;
            if (void 0 !== n) return r[n];
            var o = this._paths,
                s = this._parsedPaths,
                a = this._objects,
                l = this.nCachedObjects_,
                c = Array(a.length);
            for (n = r.length, i[e] = n, o.push(e), s.push(t), r.push(c), i = l, n = a.length; i !== n; ++i) c[i] = new Lr(a[i], e, t);
            return c
        },
        unsubscribe_: function (e) {
            var t = this._bindingsIndicesByPath,
                i = t[e];
            if (void 0 !== i) {
                var n = this._paths,
                    r = this._parsedPaths,
                    o = this._bindings,
                    s = o.length - 1,
                    a = o[s];
                t[e[s]] = i, o[i] = a, o.pop(), r[i] = r[s], r.pop(), n[i] = n[s], n.pop()
            }
        }
    }), Object.assign(Ir.prototype, {
        play: function () {
            return this._mixer._activateAction(this), this
        },
        stop: function () {
            return this._mixer._deactivateAction(this), this.reset()
        },
        reset: function () {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
        },
        isRunning: function () {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function () {
            return this._mixer._isActiveAction(this)
        },
        startAt: function (e) {
            return this._startTime = e, this
        },
        setLoop: function (e, t) {
            return this.loop = e, this.repetitions = t, this
        },
        setEffectiveWeight: function (e) {
            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
        },
        getEffectiveWeight: function () {
            return this._effectiveWeight
        },
        fadeIn: function (e) {
            return this._scheduleFading(e, 0, 1)
        },
        fadeOut: function (e) {
            return this._scheduleFading(e, 1, 0)
        },
        crossFadeFrom: function (e, t, i) {
            if (e.fadeOut(t), this.fadeIn(t), i) {
                i = this._clip.duration;
                var n = e._clip.duration,
                    r = i / n;
                e.warp(1, n / i, t), this.warp(r, 1, t)
            }
            return this
        },
        crossFadeTo: function (e, t, i) {
            return e.crossFadeFrom(this, t, i)
        },
        stopFading: function () {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        },
        setEffectiveTimeScale: function (e) {
            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
        },
        getEffectiveTimeScale: function () {
            return this._effectiveTimeScale
        },
        setDuration: function (e) {
            return this.timeScale = this._clip.duration / e, this.stopWarping()
        },
        syncWith: function (e) {
            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
        },
        halt: function (e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        },
        warp: function (e, t, i) {
            var n = this._mixer,
                r = n.time,
                o = this._timeScaleInterpolant,
                s = this.timeScale;
            return null === o && (this._timeScaleInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, n[1] = r + i, o[0] = e / s, o[1] = t / s, this
        },
        stopWarping: function () {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        },
        getMixer: function () {
            return this._mixer
        },
        getClip: function () {
            return this._clip
        },
        getRoot: function () {
            return this._localRoot || this._mixer._root
        },
        _update: function (e, t, i, n) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    if (0 > (t = (e - r) * i) || 0 === i) return;
                    this._startTime = null, t *= i
                }
                if (t *= this._updateTimeScale(e), i = this._updateTime(t), 0 < (e = this._updateWeight(e))) {
                    t = this._interpolants, r = this._propertyBindings;
                    for (var o = 0, s = t.length; o !== s; ++o) t[o].evaluate(i), r[o].accumulate(n, e)
                }
            } else this._updateWeight(e)
        },
        _updateWeight: function (e) {
            var t = 0;
            if (this.enabled) {
                t = this.weight;
                var i = this._weightInterpolant;
                if (null !== i) {
                    var n = i.evaluate(e)[0];
                    t *= n, e > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t
        },
        _updateTimeScale: function (e) {
            var t = 0;
            if (!this.paused) {
                t = this.timeScale;
                var i = this._timeScaleInterpolant;
                if (null !== i) t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
            }
            return this._effectiveTimeScale = t
        },
        _updateTime: function (e) {
            var t = this.time + e,
                i = this._clip.duration,
                n = this.loop,
                r = this._loopCount,
                o = 2202 === n;
            if (0 === e) return -1 === r ? t : o && 1 == (1 & r) ? i - t : t;
            if (2200 === n) e: {
                if (-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)), t >= i) t = i;
                else {
                    if (!(0 > t)) {
                        this.time = t;
                        break e
                    }
                    t = 0
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = t,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: 0 > e ? -1 : 1
                })
            }
            else {
                if (-1 === r && (0 <= e ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), t >= i || 0 > t) {
                    t -= i * (n = Math.floor(t / i)), r += Math.abs(n);
                    var s = this.repetitions - r;
                    0 >= s ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = t = 0 < e ? i : 0, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 < e ? 1 : -1
                    })) : (1 === s ? (e = 0 > e, this._setEndings(e, !e, o)) : this._setEndings(!1, !1, o), this._loopCount = r, this.time = t, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: n
                    }))
                } else this.time = t;
                if (o && 1 == (1 & r)) return i - t
            }
            return t
        },
        _setEndings: function (e, t, i) {
            var n = this._interpolantSettings;
            i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        },
        _scheduleFading: function (e, t, i) {
            var n = this._mixer,
                r = n.time,
                o = this._weightInterpolant;
            return null === o && (this._weightInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, o[0] = t, n[1] = r + e, o[1] = i, this
        }
    }), Or.prototype = Object.assign(Object.create(t.prototype), {
        constructor: Or,
        _bindAction: function (e, t) {
            var i = e._localRoot || this._root,
                n = e._clip.tracks,
                r = n.length,
                o = e._propertyBindings;
            e = e._interpolants;
            var s = i.uuid,
                a = this._bindingsByRootAndName,
                l = a[s];
            for (void 0 === l && (l = {}, a[s] = l), a = 0; a !== r; ++a) {
                var c = n[a],
                    u = c.name,
                    h = l[u];
                if (void 0 === h) {
                    if (void 0 !== (h = o[a])) {
                        null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, s, u));
                        continue
                    }++(h = new Ar(Lr.create(i, u, t && t._propertyBindings[a].binding.parsedPath), c.ValueTypeName, c.getValueSize())).referenceCount, this._addInactiveBinding(h, s, u)
                }
                o[a] = h, e[a].resultBuffer = h.buffer
            }
        },
        _activateAction: function (e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    var t = (e._localRoot || this._root).uuid,
                        i = e._clip.uuid,
                        n = this._actionsByClip[i];
                    this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, i, t)
                }
                for (i = 0, n = (t = e._propertyBindings).length; i !== n; ++i) {
                    var r = t[i];
                    0 == r.useCount++ && (this._lendBinding(r), r.saveOriginalState())
                }
                this._lendAction(e)
            }
        },
        _deactivateAction: function (e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
                    var r = t[i];
                    0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                }
                this._takeBackAction(e)
            }
        },
        _initMemoryManager: function () {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function (e) {
            return null !== (e = e._cacheIndex) && e < this._nActiveActions
        },
        _addInactiveAction: function (e, t, i) {
            var n = this._actions,
                r = this._actionsByClip,
                o = r[t];
            void 0 === o ? (o = {
                knownActions: [e],
                actionByRoot: {}
            }, e._byClipCacheIndex = 0, r[t] = o) : (t = o.knownActions, e._byClipCacheIndex = t.length, t.push(e)), e._cacheIndex = n.length, n.push(e), o.actionByRoot[i] = e
        },
        _removeInactiveAction: function (e) {
            var t = this._actions,
                i = t[t.length - 1],
                n = e._cacheIndex;
            i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null, t = e._clip.uuid;
            var r = (n = (i = this._actionsByClip)[t]).knownActions,
                o = r[r.length - 1],
                s = e._byClipCacheIndex;
            o._byClipCacheIndex = s, r[s] = o, r.pop(), e._byClipCacheIndex = null, delete n.actionByRoot[(e._localRoot || this._root).uuid], 0 === r.length && delete i[t], this._removeInactiveBindingsForAction(e)
        },
        _removeInactiveBindingsForAction: function (e) {
            for (var t = 0, i = (e = e._propertyBindings).length; t !== i; ++t) {
                var n = e[t];
                0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
        },
        _lendAction: function (e) {
            var t = this._actions,
                i = e._cacheIndex,
                n = this._nActiveActions++,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _takeBackAction: function (e) {
            var t = this._actions,
                i = e._cacheIndex,
                n = --this._nActiveActions,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _addInactiveBinding: function (e, t, i) {
            var n = this._bindingsByRootAndName,
                r = n[t],
                o = this._bindings;
            void 0 === r && (r = {}, n[t] = r), r[i] = e, e._cacheIndex = o.length, o.push(e)
        },
        _removeInactiveBinding: function (e) {
            var t = this._bindings,
                i = e.binding,
                n = i.rootNode.uuid;
            i = i.path;
            var r = this._bindingsByRootAndName,
                o = r[n],
                s = t[t.length - 1];
            e = e._cacheIndex, s._cacheIndex = e, t[e] = s, t.pop(), delete o[i];
            e: {
                for (var a in o) break e;delete r[n]
            }
        },
        _lendBinding: function (e) {
            var t = this._bindings,
                i = e._cacheIndex,
                n = this._nActiveBindings++,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _takeBackBinding: function (e) {
            var t = this._bindings,
                i = e._cacheIndex,
                n = --this._nActiveBindings,
                r = t[n];
            e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
        },
        _lendControlInterpolant: function () {
            var e = this._controlInterpolants,
                t = this._nActiveControlInterpolants++,
                i = e[t];
            return void 0 === i && ((i = new un(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = i), i
        },
        _takeBackControlInterpolant: function (e) {
            var t = this._controlInterpolants,
                i = e.__cacheIndex,
                n = --this._nActiveControlInterpolants,
                r = t[n];
            e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function (e, t) {
            var i = t || this._root,
                n = i.uuid;
            e = null !== (i = "string" == typeof e ? xn.findByName(i, e) : e) ? i.uuid : e;
            var r = this._actionsByClip[e],
                o = null;
            if (void 0 !== r) {
                if (void 0 !== (o = r.actionByRoot[n])) return o;
                o = r.knownActions[0], null === i && (i = o._clip)
            }
            return null === i ? null : (t = new Ir(this, i, t), this._bindAction(t, o), this._addInactiveAction(t, e, n), t)
        },
        existingAction: function (e, t) {
            var i = t || this._root;
            return t = i.uuid, i = "string" == typeof e ? xn.findByName(i, e) : e, void 0 !== (e = this._actionsByClip[i ? i.uuid : e]) && e.actionByRoot[t] || null
        },
        stopAllAction: function () {
            for (var e = this._actions, t = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== t; ++r) e[r].reset();
            for (r = 0; r !== n; ++r) i[r].useCount = 0;
            return this
        },
        update: function (e) {
            e *= this.timeScale;
            for (var t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), o = this._accuIndex ^= 1, s = 0; s !== i; ++s) t[s]._update(n, e, r, o);
            for (e = this._bindings, t = this._nActiveBindings, s = 0; s !== t; ++s) e[s].apply(o);
            return this
        },
        getRoot: function () {
            return this._root
        },
        uncacheClip: function (e) {
            var t = this._actions;
            e = e.uuid;
            var i = this._actionsByClip,
                n = i[e];
            if (void 0 !== n) {
                for (var r = 0, o = (n = n.knownActions).length; r !== o; ++r) {
                    var s = n[r];
                    this._deactivateAction(s);
                    var a = s._cacheIndex,
                        l = t[t.length - 1];
                    s._cacheIndex = null, s._byClipCacheIndex = null, l._cacheIndex = a, t[a] = l, t.pop(), this._removeInactiveBindingsForAction(s)
                }
                delete i[e]
            }
        },
        uncacheRoot: function (e) {
            e = e.uuid;
            var t = this._actionsByClip;
            for (n in t) {
                var i = t[n].actionByRoot[e];
                void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
            var n = this._bindingsByRootAndName[e];
            if (void 0 !== n)
                for (var r in n)(e = n[r]).restoreOriginalState(), this._removeInactiveBinding(e)
        },
        uncacheAction: function (e, t) {
            null !== (e = this.existingAction(e, t)) && (this._deactivateAction(e), this._removeInactiveAction(e))
        }
    }), Rr.prototype.clone = function () {
        return new Rr(void 0 === this.value.clone ? this.value : this.value.clone())
    }, Dr.prototype = Object.assign(Object.create(Pt.prototype), {
        constructor: Dr,
        isInstancedInterleavedBuffer: !0,
        copy: function (e) {
            return Pt.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        }
    }), Object.assign(kr.prototype, {
        linePrecision: 1,
        set: function (e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function (e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function (e, t, i) {
            return Br(e, this, i = i || [], t), i.sort(zr), i
        },
        intersectObjects: function (e, t, i) {
            if (i = i || [], !1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
            for (var n = 0, r = e.length; n < r; n++) Br(e[n], this, i, t);
            return i.sort(zr), i
        }
    }), Object.assign(Nr.prototype, {
        set: function (e, t, i) {
            return this.radius = e, this.phi = t, this.theta = i, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
        },
        makeSafe: function () {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
        },
        setFromVector3: function (e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function (e, t, i) {
            return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(e, i), this.phi = Math.acos(ho.clamp(t / this.radius, -1, 1))), this
        }
    }), Object.assign(Fr.prototype, {
        set: function (e, t, i) {
            return this.radius = e, this.theta = t, this.y = i, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
        },
        setFromVector3: function (e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function (e, t, i) {
            return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this
        }
    }), Object.assign(Hr.prototype, {
        set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromPoints: function (e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function () {
            var e = new i;
            return function (t, i) {
                return i = e.copy(i).multiplyScalar(.5), this.min.copy(t).sub(i), this.max.copy(t).add(i), this
            }
        }(),
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function () {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function (e) {
            return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new i), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function (e) {
            return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new i), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        containsPoint: function (e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function (e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new i), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function (e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function (e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new i), t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function () {
            var e = new i;
            return function (t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this
        },
        union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        translate: function (e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }), Object.assign(Ur.prototype, {
        set: function (e, t) {
            return this.start.copy(e), this.end.copy(t), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.start.copy(e.start), this.end.copy(e.end), this
        },
        getCenter: function (e) {
            return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new r), e.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function (e) {
            return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new r), e.subVectors(this.end, this.start)
        },
        distanceSq: function () {
            return this.start.distanceToSquared(this.end)
        },
        distance: function () {
            return this.start.distanceTo(this.end)
        },
        at: function (e, t) {
            return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new r), this.delta(t).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: function () {
            var e = new r,
                t = new r;
            return function (i, n) {
                return e.subVectors(i, this.start), t.subVectors(this.end, this.start), i = t.dot(t), i = t.dot(e) / i, n && (i = ho.clamp(i, 0, 1)), i
            }
        }(),
        closestPointToPoint: function (e, t, i) {
            return e = this.closestPointToPointParameter(e, t), void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new r), this.delta(i).multiplyScalar(e).add(this.start)
        },
        applyMatrix4: function (e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
        },
        equals: function (e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }), jr.prototype = Object.create(S.prototype), jr.prototype.constructor = jr, jr.prototype.isImmediateRenderObject = !0, Gr.prototype = Object.create(Ht.prototype), Gr.prototype.constructor = Gr, Gr.prototype.update = function () {
        var e = new r,
            t = new r,
            i = new o;
        return function () {
            var n = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            var r = this.object.matrixWorld,
                o = this.geometry.attributes.position,
                s = this.object.geometry;
            if (s && s.isGeometry)
                for (var a = s.vertices, l = s.faces, c = s = 0, u = l.length; c < u; c++)
                    for (var h = l[c], d = 0, p = h.vertexNormals.length; d < p; d++) {
                        var f = h.vertexNormals[d];
                        e.copy(a[h[n[d]]]).applyMatrix4(r), t.copy(f).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), o.setXYZ(s, e.x, e.y, e.z), s += 1, o.setXYZ(s, t.x, t.y, t.z), s += 1
                    } else if (s && s.isBufferGeometry)
                        for (n = s.attributes.position, a = s.attributes.normal, d = s = 0, p = n.count; d < p; d++) e.set(n.getX(d), n.getY(d), n.getZ(d)).applyMatrix4(r), t.set(a.getX(d), a.getY(d), a.getZ(d)), t.applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), o.setXYZ(s, e.x, e.y, e.z), s += 1, o.setXYZ(s, t.x, t.y, t.z), s += 1;
            o.needsUpdate = !0
        }
    }(), Vr.prototype = Object.create(S.prototype), Vr.prototype.constructor = Vr, Vr.prototype.dispose = function () {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, Vr.prototype.update = function () {
        var e = new r;
        return function () {
            this.light.updateMatrixWorld();
            var t = this.light.distance ? this.light.distance : 1e3,
                i = t * Math.tan(this.light.angle);
            this.cone.scale.set(i, i, t), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }(), Wr.prototype = Object.create(Ht.prototype), Wr.prototype.constructor = Wr, Wr.prototype.updateMatrixWorld = function () {
        var e = new r,
            t = new g,
            i = new g;
        return function (n) {
            var r = this.bones,
                o = this.geometry,
                s = o.getAttribute("position");
            i.getInverse(this.root.matrixWorld);
            for (var a = 0, l = 0; a < r.length; a++) {
                var c = r[a];
                c.parent && c.parent.isBone && (t.multiplyMatrices(i, c.matrixWorld), e.setFromMatrixPosition(t), s.setXYZ(l, e.x, e.y, e.z), t.multiplyMatrices(i, c.parent.matrixWorld), e.setFromMatrixPosition(t), s.setXYZ(l + 1, e.x, e.y, e.z), l += 2)
            }
            o.getAttribute("position").needsUpdate = !0, S.prototype.updateMatrixWorld.call(this, n)
        }
    }(), qr.prototype = Object.create(Z.prototype), qr.prototype.constructor = qr, qr.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose()
    }, qr.prototype.update = function () {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }, Xr.prototype = Object.create(Ft.prototype), Xr.prototype.constructor = Xr, Xr.prototype.update = function () {
        if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
        else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var e = this.material.color,
                t = Math.max(e.r, e.g, e.b);
            1 < t && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color)
        }
    }, Xr.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Yr.prototype = Object.create(S.prototype), Yr.prototype.constructor = Yr, Yr.prototype.dispose = function () {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Yr.prototype.update = function () {
        var e = new r,
            t = new b,
            i = new b;
        return function () {
            var n = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
                var r = n.geometry.getAttribute("color");
                t.copy(this.light.color), i.copy(this.light.groundColor);
                for (var o = 0, s = r.count; o < s; o++) {
                    var a = o < s / 2 ? t : i;
                    r.setXYZ(o, a.r, a.g, a.b)
                }
                r.needsUpdate = !0
            }
            n.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate())
        }
    }(), Zr.prototype = Object.create(Z.prototype), Zr.prototype.constructor = Zr, Zr.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose()
    }, Zr.prototype.onBeforeRender = function () {
        this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity
    }, Qr.prototype = Object.assign(Object.create(Ht.prototype), {
        constructor: Qr,
        copy: function (e) {
            return Ht.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        }
    }), Jr.prototype = Object.create(Ht.prototype), Jr.prototype.constructor = Jr, Kr.prototype = Object.create(Ft.prototype), Kr.prototype.constructor = Kr, Kr.prototype.update = function () {
        function e(e, n, o, s) {
            for (o = (n - e) / o, p.setXYZ(u, 0, 0, 0), h++, t = e; t < n; t += o) i = u + h, p.setXYZ(i, Math.sin(t) * r, 0, Math.cos(t) * r), p.setXYZ(i + 1, Math.sin(Math.min(t + o, n)) * r, 0, Math.cos(Math.min(t + o, n)) * r), p.setXYZ(i + 2, 0, 0, 0), h += 3;
            d.addGroup(u, h, s), u += h, h = 0
        }
        var t, i, n = this.audio,
            r = this.range,
            o = this.divisionsInnerAngle,
            s = this.divisionsOuterAngle,
            a = ho.degToRad(n.panner.coneInnerAngle),
            l = a / 2,
            c = (n = ho.degToRad(n.panner.coneOuterAngle)) / 2,
            u = 0,
            h = 0,
            d = this.geometry,
            p = d.attributes.position;
        d.clearGroups(), e(-c, -l, s, 0), e(-l, l, o, 1), e(l, c, s, 0), p.needsUpdate = !0, a === n && (this.material[0].visible = !1)
    }, Kr.prototype.dispose = function () {
        this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
    }, $r.prototype = Object.create(Ht.prototype), $r.prototype.constructor = $r, $r.prototype.update = function () {
        var e = new r,
            t = new r,
            i = new o;
        return function () {
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, s = o.vertices, a = 0, l = 0, c = (o = o.faces).length; l < c; l++) {
                var u = o[l],
                    h = u.normal;
                e.copy(s[u.a]).add(s[u.b]).add(s[u.c]).divideScalar(3).applyMatrix4(n), t.copy(h).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), r.setXYZ(a, e.x, e.y, e.z), a += 1, r.setXYZ(a, t.x, t.y, t.z), a += 1
            }
            r.needsUpdate = !0
        }
    }(), eo.prototype = Object.create(S.prototype), eo.prototype.constructor = eo, eo.prototype.dispose = function () {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, eo.prototype.update = function () {
        var e = new r,
            t = new r,
            i = new r;
        return function () {
            e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(t, e), this.lightPlane.lookAt(t), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(t), this.targetLine.scale.z = i.length()
        }
    }(), to.prototype = Object.create(Ht.prototype), to.prototype.constructor = to, to.prototype.update = function () {
        function e(e, r, s, a) {
            if (n.set(r, s, a).unproject(o), void 0 !== (e = i[e]))
                for (r = t.getAttribute("position"), s = 0, a = e.length; s < a; s++) r.setXYZ(e[s], n.x, n.y, n.z)
        }
        var t, i, n = new r,
            o = new xt;
        return function () {
            t = this.geometry, i = this.pointMap, o.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
        }
    }(), io.prototype = Object.create(Ht.prototype), io.prototype.constructor = io, io.prototype.update = function () {
        var e = new d;
        return function (t) {
            if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e.setFromObject(this.object), !e.isEmpty()) {
                t = e.min;
                var i = e.max,
                    n = this.geometry.attributes.position,
                    r = n.array;
                r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = t.x, r[4] = i.y, r[5] = i.z, r[6] = t.x, r[7] = t.y, r[8] = i.z, r[9] = i.x, r[10] = t.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = t.z, r[15] = t.x, r[16] = i.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = i.x, r[22] = t.y, r[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
        }
    }(), io.prototype.setFromObject = function (e) {
        return this.object = e, this.update(), this
    }, io.prototype.copy = function (e) {
        return Ht.prototype.copy.call(this, e), this.object = e.object, this
    }, io.prototype.clone = function () {
        return (new this.constructor).copy(this)
    }, no.prototype = Object.create(Ht.prototype), no.prototype.constructor = no, no.prototype.updateMatrixWorld = function (e) {
        var t = this.box;
        t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), S.prototype.updateMatrixWorld.call(this, e))
    }, ro.prototype = Object.create(Ft.prototype), ro.prototype.constructor = ro, ro.prototype.updateMatrixWorld = function (e) {
        var t = -this.plane.constant;
        1e-8 > Math.abs(t) && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = 0 > t ? 1 : 0, this.lookAt(this.plane.normal), S.prototype.updateMatrixWorld.call(this, e)
    }, oo.prototype = Object.create(S.prototype), oo.prototype.constructor = oo, oo.prototype.setDirection = function () {
        var e, t = new r;
        return function (i) {
            .99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (t.set(i.z, 0, -i.x).normalize(), e = Math.acos(i.y), this.quaternion.setFromAxisAngle(t, e))
        }
    }(), oo.prototype.setLength = function (e, t, i) {
        void 0 === t && (t = .2 * e), void 0 === i && (i = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix()
    }, oo.prototype.setColor = function (e) {
        this.line.material.color.copy(e), this.cone.material.color.copy(e)
    }, oo.prototype.copy = function (e) {
        return S.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    }, oo.prototype.clone = function () {
        return (new this.constructor).copy(this)
    }, so.prototype = Object.create(Ht.prototype), so.prototype.constructor = so, Pn.create = function (e, t) {
        return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Pn.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
    }, Object.assign(Wn.prototype, {
        createPointsGeometry: function (e) {
            return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), e = this.getPoints(e), this.createGeometry(e)
        },
        createSpacedPointsGeometry: function (e) {
            return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), e = this.getSpacedPoints(e), this.createGeometry(e)
        },
        createGeometry: function (e) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var t = new T, i = 0, n = e.length; i < n; i++) {
                var o = e[i];
                t.vertices.push(new r(o.x, o.y, o.z || 0))
            }
            return t
        }
    }), Object.assign(qn.prototype, {
        fromPoints: function (e) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
        }
    }), ao.prototype = Object.create(Dn.prototype), lo.prototype = Object.create(Dn.prototype), co.prototype = Object.create(Dn.prototype), Object.assign(co.prototype, {
        initFromArray: function () {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function () {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function () {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), Qr.prototype.setColors = function () {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, Wr.prototype.update = function () {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(fr.prototype, {
        extractUrlBase: function (e) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), es.extractUrlBase(e)
        }
    }), Object.assign(cr.prototype, {
        setTexturePath: function (e) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
        }
    }), Object.assign(Hr.prototype, {
        center: function (e) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function () {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function (e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        size: function (e) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Object.assign(d.prototype, {
        center: function (e) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function () {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function (e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionSphere: function (e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        },
        size: function (e) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Ur.prototype.center = function (e) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
    }, Object.assign(ho, {
        random16: function () {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        },
        nearestPowerOfTwo: function (e) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), ho.floorPowerOfTwo(e)
        },
        nextPowerOfTwo: function (e) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), ho.ceilPowerOfTwo(e)
        }
    }), Object.assign(o.prototype, {
        flattenToArrayOffset: function (e, t) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        multiplyVector3: function (e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
        },
        multiplyVector3Array: function () {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function (e) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function () {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(g.prototype, {
        extractPosition: function (e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
        },
        flattenToArrayOffset: function (e, t) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        getPosition: function () {
            var e;
            return function () {
                return void 0 === e && (e = new r), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function (e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function (e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector4: function (e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector3Array: function () {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function (e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
        },
        crossVector: function (e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        translate: function () {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function (e) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function () {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function (e, t, i, n, r, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, i, r, o)
        }
    }), f.prototype.isIntersectionLine = function (e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
    }, n.prototype.multiplyVector3 = function (e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
    }, Object.assign(q.prototype, {
        isIntersectionBox: function (e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionPlane: function (e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
        },
        isIntersectionSphere: function (e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        }
    }), Object.assign(X.prototype, {
        area: function () {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        },
        barycoordFromPoint: function (e, t) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
        },
        midpoint: function (e) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
        },
        normal: function (e) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
        },
        plane: function (e) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
        }
    }), Object.assign(X, {
        barycoordFromPoint: function (e, t, i, n, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), X.getBarycoord(e, t, i, n, r)
        },
        normal: function (e, t, i, n) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), X.getNormal(e, t, i, n)
        }
    }), Object.assign(Xn.prototype, {
        extractAllPoints: function (e) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
        },
        extrude: function (e) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Pi(this, e)
        },
        makeGeometry: function (e) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ui(this, e)
        }
    }), Object.assign(i.prototype, {
        fromAttribute: function (e, t, i) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        },
        distanceToManhattan: function (e) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function () {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(r.prototype, {
        setEulerFromRotationMatrix: function () {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function () {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function (e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function (e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function (e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
        },
        applyProjection: function (e) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
        },
        fromAttribute: function (e, t, i) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        },
        distanceToManhattan: function (e) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function () {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(a.prototype, {
        fromAttribute: function (e, t, i) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        },
        lengthManhattan: function () {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(T.prototype, {
        computeTangents: function () {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function () {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }), Object.assign(S.prototype, {
        getChildByName: function (e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
        },
        renderDepth: function () {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function (e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
        },
        getWorldRotation: function () {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }), Object.defineProperties(S.prototype, {
        eulerOrder: {
            get: function () {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function (e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.defineProperties(Dt.prototype, {
        objects: {
            get: function () {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(zt.prototype, "useVertexTexture", {
        get: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), kt.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }, Object.defineProperty(Pn.prototype, "__arcLengthDivisions", {
        get: function () {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function (e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
        }
    }), wt.prototype.setLens = function (e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
    }, Object.defineProperties(Yn.prototype, {
        onlyShadow: {
            set: function () {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function () {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function (e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function () {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function (e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function (e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
            }
        }
    }), Object.defineProperties(A.prototype, {
        length: {
            get: function () {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        },
        copyIndicesArray: function () {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    }), Object.assign(F.prototype, {
        addIndex: function (e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
        },
        addDrawCall: function (e, t, i) {
            void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
        },
        clearDrawCalls: function () {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function () {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function () {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }), Object.defineProperties(F.prototype, {
        drawcalls: {
            get: function () {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function () {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.assign(Ii.prototype, {
        getArrays: function () {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function () {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function () {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }), Object.defineProperties(Rr.prototype, {
        dynamic: {
            set: function () {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function () {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(V.prototype, {
        wrapAround: {
            get: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function () {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function () {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function () {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new b
            }
        },
        shading: {
            get: function () {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function (e) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
            }
        }
    }), Object.defineProperties(tn.prototype, {
        metal: {
            get: function () {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function () {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(W.prototype, {
        derivatives: {
            get: function () {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function (e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
            }
        }
    }), Object.assign(Tt.prototype, {
        clearTarget: function (e, t, i, n) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, i, n)
        },
        animate: function (e) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
        },
        getCurrentRenderTarget: function () {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        getMaxAnisotropy: function () {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function () {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },
        resetGLState: function () {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        },
        supportsFloatTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function () {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function () {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function () {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function (e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
        },
        initMaterial: function () {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function () {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function () {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function () {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function () {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function () {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function () {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }
    }), Object.defineProperties(Tt.prototype, {
        shadowMapEnabled: {
            get: function () {
                return this.shadowMap.enabled
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function () {
                return this.shadowMap.type
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(mt.prototype, {
        cullFace: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(u.prototype, {
        activeCubeFace: {
            set: function () {
                console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
            }
        },
        activeMipMapLevel: {
            set: function () {
                console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
            }
        }
    }), Object.defineProperties(l.prototype, {
        wrapS: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
            }
        },
        offset: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
            }
        },
        repeat: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
            }
        },
        format: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
            }
        },
        type: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
            }
        }
    }), Object.defineProperties(Mt.prototype, {
        standing: {
            set: function () {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        },
        userHeight: {
            set: function () {
                console.warn("THREE.WebVRManager: .userHeight has been removed.")
            }
        }
    }), Mr.prototype.load = function (e) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var t = this;
        return (new mr).load(e, (function (e) {
            t.setBuffer(e)
        })), this
    }, Tr.prototype.getData = function () {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, wr.prototype.updateCubeMap = function (e, t) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
    }, fo.crossOrigin = void 0, fo.loadTexture = function (e, t, i, n) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var r = new Ln;
        return r.setCrossOrigin(this.crossOrigin), e = r.load(e, i, void 0, n), t && (e.mapping = t), e
    }, fo.loadTextureCube = function (e, t, i, n) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var r = new Cn;
        return r.setCrossOrigin(this.crossOrigin), e = r.load(e, i, void 0, n), t && (e.mapping = t), e
    }, fo.loadCompressedTexture = function () {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }, fo.loadCompressedTextureCube = function () {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }, e.ACESFilmicToneMapping = 5, e.AddEquation = 100, e.AddOperation = 2, e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AmbientLight = nr, e.AmbientLightProbe = br, e.AnimationClip = xn, e.AnimationLoader = Mn, e.AnimationMixer = Or, e.AnimationObjectGroup = Pr, e.AnimationUtils = Wo, e.ArcCurve = On, e.ArrayCamera = _t, e.ArrowHelper = oo, e.Audio = Mr, e.AudioAnalyser = Tr, e.AudioContext = ls, e.AudioListener = Er, e.AudioLoader = mr, e.AxesHelper = so, e.AxisHelper = function (e) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new so(e)
    }, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function (e) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Tn(e)
    }, e.Bone = Bt, e.BooleanKeyframeTrack = pn, e.BoundingBoxHelper = function (e, t) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new io(e, t)
    }, e.Box2 = Hr, e.Box3 = d, e.Box3Helper = no, e.BoxBufferGeometry = U, e.BoxGeometry = H, e.BoxHelper = io, e.BufferAttribute = A, e.BufferGeometry = F, e.BufferGeometryLoader = lr, e.ByteType = 1010, e.Cache = qo, e.Camera = xt, e.CameraHelper = to, e.CanvasRenderer = function () {
        console.error("THREE.CanvasRenderer has been removed")
    }, e.CanvasTexture = qt, e.CatmullRomCurve3 = Dn, e.CineonToneMapping = 4, e.CircleBufferGeometry = Qi, e.CircleGeometry = Zi, e.ClampToEdgeWrapping = 1001, e.Clock = _r, e.ClosedSplineCurve3 = ao, e.Color = b, e.ColorKeyframeTrack = fn, e.CompressedTexture = Wt, e.CompressedTextureLoader = Sn, e.ConeBufferGeometry = Yi, e.ConeGeometry = Xi, e.CubeCamera = wr, e.CubeGeometry = H, e.CubeReflectionMapping = 301, e.CubeRefractionMapping = 302, e.CubeTexture = ae, e.CubeTextureLoader = Cn, e.CubeUVReflectionMapping = 306, e.CubeUVRefractionMapping = 307, e.CubicBezierCurve = Nn, e.CubicBezierCurve3 = Fn, e.CubicInterpolant = cn, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = Pn, e.CurvePath = Wn, e.CustomBlending = 5, e.CylinderBufferGeometry = qi, e.CylinderGeometry = Wi, e.Cylindrical = Fr, e.DataTexture = h, e.DataTexture2DArray = le, e.DataTexture3D = ce, e.DataTextureLoader = Tn, e.DefaultLoadingManager = Xo, e.DepthFormat = 1026, e.DepthStencilFormat = 1027, e.DepthTexture = Xt, e.DirectionalLight = ir, e.DirectionalLightHelper = eo, e.DirectionalLightShadow = tr, e.DiscreteInterpolant = hn, e.DodecahedronBufferGeometry = si, e.DodecahedronGeometry = oi, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicBufferAttribute = function (e, t) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new A(e, t).setDynamic(!0)
    }, e.EdgesGeometry = Vi, e.EdgesHelper = function (e, t) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ht(new Vi(e.geometry), new Nt({
            color: void 0 !== t ? t : 16777215
        }))
    }, e.EllipseCurve = In, e.EqualDepth = 4, e.EquirectangularReflectionMapping = 303, e.EquirectangularRefractionMapping = 304, e.Euler = E, e.EventDispatcher = t, e.ExtrudeBufferGeometry = Ii, e.ExtrudeGeometry = Pi, e.Face3 = _, e.Face4 = function (e, t, i, n, r, o, s) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new _(e, t, i, r, o, s)
    }, e.FaceColors = 1, e.FaceNormalsHelper = $r, e.FileLoader = En, e.FlatShading = 1, e.Float32Attribute = function (e, t) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new k(e, t)
    }, e.Float32BufferAttribute = k, e.Float64Attribute = function (e, t) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new z(e, t)
    }, e.Float64BufferAttribute = z, e.FloatType = 1015, e.Fog = Ct, e.FogExp2 = At, e.Font = dr, e.FontLoader = pr, e.FrontFaceDirectionCCW = 1, e.FrontFaceDirectionCW = 0, e.FrontSide = 0, e.Frustum = m, e.GammaEncoding = 3007, e.Geometry = T, e.GeometryUtils = {
        merge: function (e, t, i) {
            if (console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t.isMesh) {
                t.matrixAutoUpdate && t.updateMatrix();
                var n = t.matrix;
                t = t.geometry
            }
            e.merge(t, n, i)
        },
        center: function (e) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
        }
    }, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.GridHelper = Qr, e.Group = bt, e.HalfFloatType = 1016, e.HemisphereLight = Zn, e.HemisphereLightHelper = Yr, e.HemisphereLightProbe = yr, e.IcosahedronBufferGeometry = ri, e.IcosahedronGeometry = ni, e.ImageBitmapLoader = ur, e.ImageLoader = An, e.ImageUtils = fo, e.ImmediateRenderObject = jr, e.InstancedBufferAttribute = ar, e.InstancedBufferGeometry = sr, e.InstancedInterleavedBuffer = Dr, e.Int16Attribute = function (e, t) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new I(e, t)
    }, e.Int16BufferAttribute = I, e.Int32Attribute = function (e, t) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new R(e, t)
    }, e.Int32BufferAttribute = R, e.Int8Attribute = function (e, t) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new C(e, t)
    }, e.Int8BufferAttribute = C, e.IntType = 1013, e.InterleavedBuffer = Pt, e.InterleavedBufferAttribute = It, e.Interpolant = ln, e.InterpolateDiscrete = 2300, e.InterpolateLinear = 2301, e.InterpolateSmooth = 2302, e.JSONLoader = function () {
        console.error("THREE.JSONLoader has been removed.")
    }, e.KeyframeTrack = dn, e.LOD = Dt, e.LatheBufferGeometry = Hi, e.LatheGeometry = Fi, e.Layers = M, e.LensFlare = function () {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }, e.LessDepth = 2, e.LessEqualDepth = 3, e.Light = Yn, e.LightProbe = vr, e.LightProbeHelper = Zr, e.LightShadow = Qn, e.Line = Ft, e.Line3 = Ur, e.LineBasicMaterial = Nt, e.LineCurve = Hn, e.LineCurve3 = Un, e.LineDashedMaterial = an, e.LineLoop = Ut, e.LinePieces = 1, e.LineSegments = Ht, e.LineStrip = 0, e.LinearEncoding = 3e3, e.LinearFilter = 1006, e.LinearInterpolant = un, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearToneMapping = 1, e.Loader = fr, e.LoaderUtils = es, e.LoadingManager = _n, e.LogLuvEncoding = 3003, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, e.Material = V, e.MaterialLoader = or, e.Math = ho, e.Matrix3 = o, e.Matrix4 = g, e.MaxEquation = 104, e.Mesh = Z, e.MeshBasicMaterial = Y, e.MeshDepthMaterial = pt, e.MeshDistanceMaterial = ft, e.MeshFaceMaterial = function (e) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
    }, e.MeshLambertMaterial = on, e.MeshMatcapMaterial = sn, e.MeshNormalMaterial = rn, e.MeshPhongMaterial = tn, e.MeshPhysicalMaterial = en, e.MeshStandardMaterial = $i, e.MeshToonMaterial = nn, e.MinEquation = 103, e.MirroredRepeatWrapping = 1002, e.MixOperation = 1, e.MultiMaterial = function (e) {
        return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function () {
            return e.slice()
        }, e
    }, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = 1003, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NeverDepth = 0, e.NoBlending = 0, e.NoColors = 0, e.NoToneMapping = 0, e.NormalBlending = 1, e.NotEqualDepth = 7, e.NumberKeyframeTrack = mn, e.Object3D = S, e.ObjectLoader = cr, e.ObjectSpaceNormalMap = 1, e.OctahedronBufferGeometry = ii, e.OctahedronGeometry = ti, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = er, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.ParametricBufferGeometry = Qt, e.ParametricGeometry = Zt, e.Particle = function (e) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Rt(e)
    }, e.ParticleBasicMaterial = function (e) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new jt(e)
    }, e.ParticleSystem = function (e, t) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Gt(e, t)
    }, e.ParticleSystemMaterial = function (e) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new jt(e)
    }, e.Path = qn, e.PerspectiveCamera = wt, e.Plane = f, e.PlaneBufferGeometry = G, e.PlaneGeometry = j, e.PlaneHelper = ro, e.PointCloud = function (e, t) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Gt(e, t)
    }, e.PointCloudMaterial = function (e) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new jt(e)
    }, e.PointLight = $n, e.PointLightHelper = qr, e.Points = Gt, e.PointsMaterial = jt, e.PolarGridHelper = Jr, e.PolyhedronBufferGeometry = Kt, e.PolyhedronGeometry = Jt, e.PositionalAudio = Sr, e.PositionalAudioHelper = Kr, e.PropertyBinding = Lr, e.PropertyMixer = Ar, e.QuadraticBezierCurve = jn, e.QuadraticBezierCurve3 = Gn, e.Quaternion = n, e.QuaternionKeyframeTrack = vn, e.QuaternionLinearInterpolant = gn, e.REVISION = "105", e.RGBADepthPacking = 3201, e.RGBAFormat = 1023, e.RGBA_ASTC_10x10_Format = 37819, e.RGBA_ASTC_10x5_Format = 37816, e.RGBA_ASTC_10x6_Format = 37817, e.RGBA_ASTC_10x8_Format = 37818, e.RGBA_ASTC_12x10_Format = 37820, e.RGBA_ASTC_12x12_Format = 37821, e.RGBA_ASTC_4x4_Format = 37808, e.RGBA_ASTC_5x4_Format = 37809, e.RGBA_ASTC_5x5_Format = 37810, e.RGBA_ASTC_6x5_Format = 37811, e.RGBA_ASTC_6x6_Format = 37812, e.RGBA_ASTC_8x5_Format = 37813, e.RGBA_ASTC_8x6_Format = 37814, e.RGBA_ASTC_8x8_Format = 37815, e.RGBA_PVRTC_2BPPV1_Format = 35843, e.RGBA_PVRTC_4BPPV1_Format = 35842, e.RGBA_S3TC_DXT1_Format = 33777, e.RGBA_S3TC_DXT3_Format = 33778, e.RGBA_S3TC_DXT5_Format = 33779, e.RGBDEncoding = 3006, e.RGBEEncoding = 3002, e.RGBEFormat = 1023, e.RGBFormat = 1022, e.RGBM16Encoding = 3005, e.RGBM7Encoding = 3004, e.RGB_ETC1_Format = 36196, e.RGB_PVRTC_2BPPV1_Format = 35841, e.RGB_PVRTC_4BPPV1_Format = 35840, e.RGB_S3TC_DXT1_Format = 33776, e.RawShaderMaterial = Ki, e.Ray = q, e.Raycaster = kr, e.RectAreaLight = rr, e.RectAreaLightHelper = Xr, e.RedFormat = 1028, e.ReinhardToneMapping = 2, e.RepeatWrapping = 1e3, e.ReverseSubtractEquation = 102, e.RingBufferGeometry = Ni, e.RingGeometry = Bi, e.Scene = Lt, e.SceneUtils = {
        createMultiMaterialObject: function () {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function () {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function () {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    }, e.ShaderChunk = go, e.ShaderLib = xo, e.ShaderMaterial = W, e.ShadowMaterial = Ji, e.Shape = Xn, e.ShapeBufferGeometry = ji, e.ShapeGeometry = Ui, e.ShapePath = hr, e.ShapeUtils = Uo, e.ShortType = 1011, e.Skeleton = zt, e.SkeletonHelper = Wr, e.SkinnedMesh = kt, e.SmoothShading = 2, e.Sphere = p, e.SphereBufferGeometry = zi, e.SphereGeometry = ki, e.Spherical = Nr, e.SphericalHarmonics3 = gr, e.SphericalReflectionMapping = 305, e.Spline = co, e.SplineCurve = Vn, e.SplineCurve3 = lo, e.SpotLight = Kn, e.SpotLightHelper = Vr, e.SpotLightShadow = Jn, e.Sprite = Rt, e.SpriteMaterial = Ot, e.SrcAlphaFactor = 204, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StereoCamera = xr, e.StringKeyframeTrack = yn, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGeometry = ei, e.TetrahedronGeometry = $t, e.TextBufferGeometry = Di, e.TextGeometry = Ri, e.Texture = s, e.TextureLoader = Ln, e.TorusBufferGeometry = di, e.TorusGeometry = hi, e.TorusKnotBufferGeometry = ui, e.TorusKnotGeometry = ci, e.Triangle = X, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = li, e.TubeGeometry = ai, e.UVMapping = 300, e.Uint16Attribute = function (e, t) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new O(e, t)
    }, e.Uint16BufferAttribute = O, e.Uint32Attribute = function (e, t) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new D(e, t)
    }, e.Uint32BufferAttribute = D, e.Uint8Attribute = function (e, t) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new L(e, t)
    }, e.Uint8BufferAttribute = L, e.Uint8ClampedAttribute = function (e, t) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new P(e, t)
    }, e.Uint8ClampedBufferAttribute = P, e.Uncharted2ToneMapping = 3, e.Uniform = Rr, e.UniformsLib = bo, e.UniformsUtils = vo, e.UnsignedByteType = 1009, e.UnsignedInt248Type = 1020, e.UnsignedIntType = 1014, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShort565Type = 1019, e.UnsignedShortType = 1012, e.Vector2 = i, e.Vector3 = r, e.Vector4 = a, e.VectorKeyframeTrack = bn, e.Vertex = function (e, t, i) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new r(e, t, i)
    }, e.VertexColors = 2, e.VertexNormalsHelper = Gr, e.VideoTexture = Vt, e.WebGLMultisampleRenderTarget = c, e.WebGLRenderTarget = l, e.WebGLRenderTargetCube = u, e.WebGLRenderer = Tt, e.WebGLUtils = yt, e.WireframeGeometry = Yt, e.WireframeHelper = function (e, t) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ht(new Yt(e.geometry), new Nt({
            color: void 0 !== t ? t : 16777215
        }))
    }, e.WrapAroundEnding = 2402, e.XHRLoader = function (e) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new En(e)
    }, e.ZeroCurvatureEnding = 2400, e.ZeroFactor = 200, e.ZeroSlopeEnding = 2401, e.sRGBEncoding = 3001, Object.defineProperty(e, "__esModule", {
        value: !0
    })
})),
function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).bootstrap = t()
}(this, (function () {
    "use strict";

    function e(e, t) {
        for (var i = 0; i < t.length; i++) {
            var n = t[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
        }
    }

    function t(t, i, n) {
        return i && e(t.prototype, i), n && e(t, n), t
    }

    function i() {
        return (i = Object.assign || function (e) {
            for (var t = 1; t < arguments.length; t++) {
                var i = arguments[t];
                for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
            }
            return e
        }).apply(this, arguments)
    }

    function n(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
    }
    var r, o, s = function (e) {
            do {
                e += Math.floor(1e6 * Math.random())
            } while (document.getElementById(e));
            return e
        },
        a = function (e) {
            var t = e.getAttribute("data-bs-target");
            if (!t || "#" === t) {
                var i = e.getAttribute("href");
                t = i && "#" !== i ? i.trim() : null
            }
            return t
        },
        l = function (e) {
            var t = a(e);
            return t && document.querySelector(t) ? t : null
        },
        c = function (e) {
            var t = a(e);
            return t ? document.querySelector(t) : null
        },
        u = function (e) {
            if (!e) return 0;
            var t = window.getComputedStyle(e),
                i = t.transitionDuration,
                n = t.transitionDelay,
                r = Number.parseFloat(i),
                o = Number.parseFloat(n);
            return r || o ? (i = i.split(",")[0], n = n.split(",")[0], 1e3 * (Number.parseFloat(i) + Number.parseFloat(n))) : 0
        },
        h = function (e) {
            e.dispatchEvent(new Event("transitionend"))
        },
        d = function (e) {
            return (e[0] || e).nodeType
        },
        p = function (e, t) {
            var i = !1,
                n = t + 5;
            e.addEventListener("transitionend", (function t() {
                i = !0, e.removeEventListener("transitionend", t)
            })), setTimeout((function () {
                i || h(e)
            }), n)
        },
        f = function (e, t, i) {
            Object.keys(i).forEach((function (n) {
                var r, o = i[n],
                    s = t[n],
                    a = s && d(s) ? "element" : null == (r = s) ? "" + r : {}.toString.call(r).match(/\s([a-z]+)/i)[1].toLowerCase();
                if (!new RegExp(o).test(a)) throw new Error(e.toUpperCase() + ': Option "' + n + '" provided type "' + a + '" but expected type "' + o + '".')
            }))
        },
        m = function (e) {
            if (!e) return !1;
            if (e.style && e.parentNode && e.parentNode.style) {
                var t = getComputedStyle(e),
                    i = getComputedStyle(e.parentNode);
                return "none" !== t.display && "none" !== i.display && "hidden" !== t.visibility
            }
            return !1
        },
        g = function () {
            return function () {}
        },
        v = function (e) {
            return e.offsetHeight
        },
        y = function () {
            var e = window.jQuery;
            return e && !document.body.hasAttribute("data-bs-no-jquery") ? e : null
        },
        b = function (e) {
            "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", e) : e()
        },
        x = "rtl" === document.documentElement.dir,
        w = (r = {}, o = 1, {
            set: function (e, t, i) {
                void 0 === e.bsKey && (e.bsKey = {
                    key: t,
                    id: o
                }, o++), r[e.bsKey.id] = i
            },
            get: function (e, t) {
                if (!e || void 0 === e.bsKey) return null;
                var i = e.bsKey;
                return i.key === t ? r[i.id] : null
            },
            delete: function (e, t) {
                if (void 0 !== e.bsKey) {
                    var i = e.bsKey;
                    i.key === t && (delete r[i.id], delete e.bsKey)
                }
            }
        }),
        _ = function (e, t, i) {
            w.set(e, t, i)
        },
        E = function (e, t) {
            return w.get(e, t)
        },
        M = /[^.]*(?=\..*)\.|.*/,
        S = /\..*/,
        T = /::\d+$/,
        A = {},
        C = 1,
        L = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        },
        P = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

    function I(e, t) {
        return t && t + "::" + C++ || e.uidEvent || C++
    }

    function O(e) {
        var t = I(e);
        return e.uidEvent = t, A[t] = A[t] || {}, A[t]
    }

    function R(e, t, i) {
        void 0 === i && (i = null);
        for (var n = Object.keys(e), r = 0, o = n.length; r < o; r++) {
            var s = e[n[r]];
            if (s.originalHandler === t && s.delegationSelector === i) return s
        }
        return null
    }

    function D(e, t, i) {
        var n = "string" == typeof t,
            r = n ? i : t,
            o = e.replace(S, ""),
            s = L[o];
        return s && (o = s), P.has(o) || (o = e), [n, r, o]
    }

    function k(e, t, i, n, r) {
        if ("string" == typeof t && e) {
            i || (i = n, n = null);
            var o = D(t, i, n),
                s = o[0],
                a = o[1],
                l = o[2],
                c = O(e),
                u = c[l] || (c[l] = {}),
                h = R(u, a, s ? i : null);
            if (h) h.oneOff = h.oneOff && r;
            else {
                var d = I(a, t.replace(M, "")),
                    p = s ? function (e, t, i) {
                        return function n(r) {
                            for (var o = e.querySelectorAll(t), s = r.target; s && s !== this; s = s.parentNode)
                                for (var a = o.length; a--;)
                                    if (o[a] === s) return r.delegateTarget = s, n.oneOff && B.off(e, r.type, i), i.apply(s, [r]);
                            return null
                        }
                    }(e, i, n) : function (e, t) {
                        return function i(n) {
                            return n.delegateTarget = e, i.oneOff && B.off(e, n.type, t), t.apply(e, [n])
                        }
                    }(e, i);
                p.delegationSelector = s ? i : null, p.originalHandler = a, p.oneOff = r, p.uidEvent = d, u[d] = p, e.addEventListener(l, p, s)
            }
        }
    }

    function z(e, t, i, n, r) {
        var o = R(t[i], n, r);
        o && (e.removeEventListener(i, o, Boolean(r)), delete t[i][o.uidEvent])
    }
    var B = {
            on: function (e, t, i, n) {
                k(e, t, i, n, !1)
            },
            one: function (e, t, i, n) {
                k(e, t, i, n, !0)
            },
            off: function (e, t, i, n) {
                if ("string" == typeof t && e) {
                    var r = D(t, i, n),
                        o = r[0],
                        s = r[1],
                        a = r[2],
                        l = a !== t,
                        c = O(e),
                        u = t.startsWith(".");
                    if (void 0 === s) {
                        u && Object.keys(c).forEach((function (i) {
                            ! function (e, t, i, n) {
                                var r = t[i] || {};
                                Object.keys(r).forEach((function (o) {
                                    if (o.includes(n)) {
                                        var s = r[o];
                                        z(e, t, i, s.originalHandler, s.delegationSelector)
                                    }
                                }))
                            }(e, c, i, t.slice(1))
                        }));
                        var h = c[a] || {};
                        Object.keys(h).forEach((function (i) {
                            var n = i.replace(T, "");
                            if (!l || t.includes(n)) {
                                var r = h[i];
                                z(e, c, a, r.originalHandler, r.delegationSelector)
                            }
                        }))
                    } else {
                        if (!c || !c[a]) return;
                        z(e, c, a, s, o ? i : null)
                    }
                }
            },
            trigger: function (e, t, i) {
                if ("string" != typeof t || !e) return null;
                var n, r = y(),
                    o = t.replace(S, ""),
                    s = t !== o,
                    a = P.has(o),
                    l = !0,
                    c = !0,
                    u = !1,
                    h = null;
                return s && r && (n = r.Event(t, i), r(e).trigger(n), l = !n.isPropagationStopped(), c = !n.isImmediatePropagationStopped(), u = n.isDefaultPrevented()), a ? (h = document.createEvent("HTMLEvents")).initEvent(o, l, !0) : h = new CustomEvent(t, {
                    bubbles: l,
                    cancelable: !0
                }), void 0 !== i && Object.keys(i).forEach((function (e) {
                    Object.defineProperty(h, e, {
                        get: function () {
                            return i[e]
                        }
                    })
                })), u && h.preventDefault(), c && e.dispatchEvent(h), h.defaultPrevented && void 0 !== n && n.preventDefault(), h
            }
        },
        N = function () {
            function e(e) {
                e && (this._element = e, _(e, this.constructor.DATA_KEY, this))
            }
            return e.prototype.dispose = function () {
                (function (e, t) {
                    w.delete(e, t)
                })(this._element, this.constructor.DATA_KEY), this._element = null
            }, e.getInstance = function (e) {
                return E(e, this.DATA_KEY)
            }, t(e, null, [{
                key: "VERSION",
                get: function () {
                    return "5.0.0-beta1"
                }
            }]), e
        }(),
        F = "alert",
        H = function (e) {
            function i() {
                return e.apply(this, arguments) || this
            }
            n(i, e);
            var r = i.prototype;
            return r.close = function (e) {
                var t = e ? this._getRootElement(e) : this._element,
                    i = this._triggerCloseEvent(t);
                null === i || i.defaultPrevented || this._removeElement(t)
            }, r._getRootElement = function (e) {
                return c(e) || e.closest(".alert")
            }, r._triggerCloseEvent = function (e) {
                return B.trigger(e, "close.bs.alert")
            }, r._removeElement = function (e) {
                var t = this;
                if (e.classList.remove("show"), e.classList.contains("fade")) {
                    var i = u(e);
                    B.one(e, "transitionend", (function () {
                        return t._destroyElement(e)
                    })), p(e, i)
                } else this._destroyElement(e)
            }, r._destroyElement = function (e) {
                e.parentNode && e.parentNode.removeChild(e), B.trigger(e, "closed.bs.alert")
            }, i.jQueryInterface = function (e) {
                return this.each((function () {
                    var t = E(this, "bs.alert");
                    t || (t = new i(this)), "close" === e && t[e](this)
                }))
            }, i.handleDismiss = function (e) {
                return function (t) {
                    t && t.preventDefault(), e.close(this)
                }
            }, t(i, null, [{
                key: "DATA_KEY",
                get: function () {
                    return "bs.alert"
                }
            }]), i
        }(N);
    B.on(document, "click.bs.alert.data-api", '[data-bs-dismiss="alert"]', H.handleDismiss(new H)), b((function () {
        var e = y();
        if (e) {
            var t = e.fn[F];
            e.fn[F] = H.jQueryInterface, e.fn[F].Constructor = H, e.fn[F].noConflict = function () {
                return e.fn[F] = t, H.jQueryInterface
            }
        }
    }));
    var U = function (e) {
        function i() {
            return e.apply(this, arguments) || this
        }
        return n(i, e), i.prototype.toggle = function () {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
        }, i.jQueryInterface = function (e) {
            return this.each((function () {
                var t = E(this, "bs.button");
                t || (t = new i(this)), "toggle" === e && t[e]()
            }))
        }, t(i, null, [{
            key: "DATA_KEY",
            get: function () {
                return "bs.button"
            }
        }]), i
    }(N);

    function j(e) {
        return "true" === e || "false" !== e && (e === Number(e).toString() ? Number(e) : "" === e || "null" === e ? null : e)
    }

    function G(e) {
        return e.replace(/[A-Z]/g, (function (e) {
            return "-" + e.toLowerCase()
        }))
    }
    B.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', (function (e) {
        e.preventDefault();
        var t = e.target.closest('[data-bs-toggle="button"]'),
            i = E(t, "bs.button");
        i || (i = new U(t)), i.toggle()
    })), b((function () {
        var e = y();
        if (e) {
            var t = e.fn.button;
            e.fn.button = U.jQueryInterface, e.fn.button.Constructor = U, e.fn.button.noConflict = function () {
                return e.fn.button = t, U.jQueryInterface
            }
        }
    }));
    var V = {
            setDataAttribute: function (e, t, i) {
                e.setAttribute("data-bs-" + G(t), i)
            },
            removeDataAttribute: function (e, t) {
                e.removeAttribute("data-bs-" + G(t))
            },
            getDataAttributes: function (e) {
                if (!e) return {};
                var t = {};
                return Object.keys(e.dataset).filter((function (e) {
                    return e.startsWith("bs")
                })).forEach((function (i) {
                    var n = i.replace(/^bs/, "");
                    n = n.charAt(0).toLowerCase() + n.slice(1, n.length), t[n] = j(e.dataset[i])
                })), t
            },
            getDataAttribute: function (e, t) {
                return j(e.getAttribute("data-bs-" + G(t)))
            },
            offset: function (e) {
                var t = e.getBoundingClientRect();
                return {
                    top: t.top + document.body.scrollTop,
                    left: t.left + document.body.scrollLeft
                }
            },
            position: function (e) {
                return {
                    top: e.offsetTop,
                    left: e.offsetLeft
                }
            }
        },
        W = {
            matches: function (e, t) {
                return e.matches(t)
            },
            find: function (e, t) {
                var i;
                return void 0 === t && (t = document.documentElement), (i = []).concat.apply(i, Element.prototype.querySelectorAll.call(t, e))
            },
            findOne: function (e, t) {
                return void 0 === t && (t = document.documentElement), Element.prototype.querySelector.call(t, e)
            },
            children: function (e, t) {
                var i;
                return (i = []).concat.apply(i, e.children).filter((function (e) {
                    return e.matches(t)
                }))
            },
            parents: function (e, t) {
                for (var i = [], n = e.parentNode; n && n.nodeType === Node.ELEMENT_NODE && 3 !== n.nodeType;) this.matches(n, t) && i.push(n), n = n.parentNode;
                return i
            },
            prev: function (e, t) {
                for (var i = e.previousElementSibling; i;) {
                    if (i.matches(t)) return [i];
                    i = i.previousElementSibling
                }
                return []
            },
            next: function (e, t) {
                for (var i = e.nextElementSibling; i;) {
                    if (this.matches(i, t)) return [i];
                    i = i.nextElementSibling
                }
                return []
            }
        },
        q = "carousel",
        X = {
            interval: 5e3,
            keyboard: !0,
            slide: !1,
            pause: "hover",
            wrap: !0,
            touch: !0
        },
        Y = {
            interval: "(number|boolean)",
            keyboard: "boolean",
            slide: "(boolean|string)",
            pause: "(string|boolean)",
            wrap: "boolean",
            touch: "boolean"
        },
        Z = {
            TOUCH: "touch",
            PEN: "pen"
        },
        Q = function (e) {
            function r(t, i) {
                var n;
                return (n = e.call(this, t) || this)._items = null, n._interval = null, n._activeElement = null, n._isPaused = !1, n._isSliding = !1, n.touchTimeout = null, n.touchStartX = 0, n.touchDeltaX = 0, n._config = n._getConfig(i), n._indicatorsElement = W.findOne(".carousel-indicators", n._element), n._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, n._pointerEvent = Boolean(window.PointerEvent), n._addEventListeners(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.next = function () {
                this._isSliding || this._slide("next")
            }, o.nextWhenVisible = function () {
                !document.hidden && m(this._element) && this.next()
            }, o.prev = function () {
                this._isSliding || this._slide("prev")
            }, o.pause = function (e) {
                e || (this._isPaused = !0), W.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (h(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null
            }, o.cycle = function (e) {
                e || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
            }, o.to = function (e) {
                var t = this;
                this._activeElement = W.findOne(".active.carousel-item", this._element);
                var i = this._getItemIndex(this._activeElement);
                if (!(e > this._items.length - 1 || e < 0))
                    if (this._isSliding) B.one(this._element, "slid.bs.carousel", (function () {
                        return t.to(e)
                    }));
                    else {
                        if (i === e) return this.pause(), void this.cycle();
                        var n = e > i ? "next" : "prev";
                        this._slide(n, this._items[e])
                    }
            }, o.dispose = function () {
                e.prototype.dispose.call(this), B.off(this._element, ".bs.carousel"), this._items = null, this._config = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null
            }, o._getConfig = function (e) {
                return e = i({}, X, e), f(q, e, Y), e
            }, o._handleSwipe = function () {
                var e = Math.abs(this.touchDeltaX);
                if (!(e <= 40)) {
                    var t = e / this.touchDeltaX;
                    this.touchDeltaX = 0, t > 0 && this.prev(), t < 0 && this.next()
                }
            }, o._addEventListeners = function () {
                var e = this;
                this._config.keyboard && B.on(this._element, "keydown.bs.carousel", (function (t) {
                    return e._keydown(t)
                })), "hover" === this._config.pause && (B.on(this._element, "mouseenter.bs.carousel", (function (t) {
                    return e.pause(t)
                })), B.on(this._element, "mouseleave.bs.carousel", (function (t) {
                    return e.cycle(t)
                }))), this._config.touch && this._touchSupported && this._addTouchEventListeners()
            }, o._addTouchEventListeners = function () {
                var e = this,
                    t = function (t) {
                        e._pointerEvent && Z[t.pointerType.toUpperCase()] ? e.touchStartX = t.clientX : e._pointerEvent || (e.touchStartX = t.touches[0].clientX)
                    },
                    i = function (t) {
                        e._pointerEvent && Z[t.pointerType.toUpperCase()] && (e.touchDeltaX = t.clientX - e.touchStartX), e._handleSwipe(), "hover" === e._config.pause && (e.pause(), e.touchTimeout && clearTimeout(e.touchTimeout), e.touchTimeout = setTimeout((function (t) {
                            return e.cycle(t)
                        }), 500 + e._config.interval))
                    };
                W.find(".carousel-item img", this._element).forEach((function (e) {
                    B.on(e, "dragstart.bs.carousel", (function (e) {
                        return e.preventDefault()
                    }))
                })), this._pointerEvent ? (B.on(this._element, "pointerdown.bs.carousel", (function (e) {
                    return t(e)
                })), B.on(this._element, "pointerup.bs.carousel", (function (e) {
                    return i(e)
                })), this._element.classList.add("pointer-event")) : (B.on(this._element, "touchstart.bs.carousel", (function (e) {
                    return t(e)
                })), B.on(this._element, "touchmove.bs.carousel", (function (t) {
                    return function (t) {
                        t.touches && t.touches.length > 1 ? e.touchDeltaX = 0 : e.touchDeltaX = t.touches[0].clientX - e.touchStartX
                    }(t)
                })), B.on(this._element, "touchend.bs.carousel", (function (e) {
                    return i(e)
                })))
            }, o._keydown = function (e) {
                if (!/input|textarea/i.test(e.target.tagName)) switch (e.key) {
                    case "ArrowLeft":
                        e.preventDefault(), this.prev();
                        break;
                    case "ArrowRight":
                        e.preventDefault(), this.next()
                }
            }, o._getItemIndex = function (e) {
                return this._items = e && e.parentNode ? W.find(".carousel-item", e.parentNode) : [], this._items.indexOf(e)
            }, o._getItemByDirection = function (e, t) {
                var i = "next" === e,
                    n = "prev" === e,
                    r = this._getItemIndex(t),
                    o = this._items.length - 1;
                if ((n && 0 === r || i && r === o) && !this._config.wrap) return t;
                var s = (r + ("prev" === e ? -1 : 1)) % this._items.length;
                return -1 === s ? this._items[this._items.length - 1] : this._items[s]
            }, o._triggerSlideEvent = function (e, t) {
                var i = this._getItemIndex(e),
                    n = this._getItemIndex(W.findOne(".active.carousel-item", this._element));
                return B.trigger(this._element, "slide.bs.carousel", {
                    relatedTarget: e,
                    direction: t,
                    from: n,
                    to: i
                })
            }, o._setActiveIndicatorElement = function (e) {
                if (this._indicatorsElement) {
                    for (var t = W.find(".active", this._indicatorsElement), i = 0; i < t.length; i++) t[i].classList.remove("active");
                    var n = this._indicatorsElement.children[this._getItemIndex(e)];
                    n && n.classList.add("active")
                }
            }, o._updateInterval = function () {
                var e = this._activeElement || W.findOne(".active.carousel-item", this._element);
                if (e) {
                    var t = Number.parseInt(e.getAttribute("data-bs-interval"), 10);
                    t ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = t) : this._config.interval = this._config.defaultInterval || this._config.interval
                }
            }, o._slide = function (e, t) {
                var i, n, r, o = this,
                    s = W.findOne(".active.carousel-item", this._element),
                    a = this._getItemIndex(s),
                    l = t || s && this._getItemByDirection(e, s),
                    c = this._getItemIndex(l),
                    h = Boolean(this._interval);
                if ("next" === e ? (i = "carousel-item-start", n = "carousel-item-next", r = "left") : (i = "carousel-item-end", n = "carousel-item-prev", r = "right"), l && l.classList.contains("active")) this._isSliding = !1;
                else if (!this._triggerSlideEvent(l, r).defaultPrevented && s && l) {
                    if (this._isSliding = !0, h && this.pause(), this._setActiveIndicatorElement(l), this._activeElement = l, this._element.classList.contains("slide")) {
                        l.classList.add(n), v(l), s.classList.add(i), l.classList.add(i);
                        var d = u(s);
                        B.one(s, "transitionend", (function () {
                            l.classList.remove(i, n), l.classList.add("active"), s.classList.remove("active", n, i), o._isSliding = !1, setTimeout((function () {
                                B.trigger(o._element, "slid.bs.carousel", {
                                    relatedTarget: l,
                                    direction: r,
                                    from: a,
                                    to: c
                                })
                            }), 0)
                        })), p(s, d)
                    } else s.classList.remove("active"), l.classList.add("active"), this._isSliding = !1, B.trigger(this._element, "slid.bs.carousel", {
                        relatedTarget: l,
                        direction: r,
                        from: a,
                        to: c
                    });
                    h && this.cycle()
                }
            }, r.carouselInterface = function (e, t) {
                var n = E(e, "bs.carousel"),
                    o = i({}, X, V.getDataAttributes(e));
                "object" == typeof t && (o = i({}, o, t));
                var s = "string" == typeof t ? t : o.slide;
                if (n || (n = new r(e, o)), "number" == typeof t) n.to(t);
                else if ("string" == typeof s) {
                    if (void 0 === n[s]) throw new TypeError('No method named "' + s + '"');
                    n[s]()
                } else o.interval && o.ride && (n.pause(), n.cycle())
            }, r.jQueryInterface = function (e) {
                return this.each((function () {
                    r.carouselInterface(this, e)
                }))
            }, r.dataApiClickHandler = function (e) {
                var t = c(this);
                if (t && t.classList.contains("carousel")) {
                    var n = i({}, V.getDataAttributes(t), V.getDataAttributes(this)),
                        o = this.getAttribute("data-bs-slide-to");
                    o && (n.interval = !1), r.carouselInterface(t, n), o && E(t, "bs.carousel").to(o), e.preventDefault()
                }
            }, t(r, null, [{
                key: "Default",
                get: function () {
                    return X
                }
            }, {
                key: "DATA_KEY",
                get: function () {
                    return "bs.carousel"
                }
            }]), r
        }(N);
    B.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", Q.dataApiClickHandler), B.on(window, "load.bs.carousel.data-api", (function () {
        for (var e = W.find('[data-bs-ride="carousel"]'), t = 0, i = e.length; t < i; t++) Q.carouselInterface(e[t], E(e[t], "bs.carousel"))
    })), b((function () {
        var e = y();
        if (e) {
            var t = e.fn[q];
            e.fn[q] = Q.jQueryInterface, e.fn[q].Constructor = Q, e.fn[q].noConflict = function () {
                return e.fn[q] = t, Q.jQueryInterface
            }
        }
    }));
    var J = "collapse",
        K = {
            toggle: !0,
            parent: ""
        },
        $ = {
            toggle: "boolean",
            parent: "(string|element)"
        },
        ee = function (e) {
            function r(t, i) {
                var n;
                (n = e.call(this, t) || this)._isTransitioning = !1, n._config = n._getConfig(i), n._triggerArray = W.find('[data-bs-toggle="collapse"][href="#' + t.id + '"],[data-bs-toggle="collapse"][data-bs-target="#' + t.id + '"]');
                for (var r = W.find('[data-bs-toggle="collapse"]'), o = 0, s = r.length; o < s; o++) {
                    var a = r[o],
                        c = l(a),
                        u = W.find(c).filter((function (e) {
                            return e === t
                        }));
                    null !== c && u.length && (n._selector = c, n._triggerArray.push(a))
                }
                return n._parent = n._config.parent ? n._getParent() : null, n._config.parent || n._addAriaAndCollapsedClass(n._element, n._triggerArray), n._config.toggle && n.toggle(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.toggle = function () {
                this._element.classList.contains("show") ? this.hide() : this.show()
            }, o.show = function () {
                var e = this;
                if (!this._isTransitioning && !this._element.classList.contains("show")) {
                    var t, i;
                    this._parent && 0 === (t = W.find(".show, .collapsing", this._parent).filter((function (t) {
                        return "string" == typeof e._config.parent ? t.getAttribute("data-bs-parent") === e._config.parent : t.classList.contains("collapse")
                    }))).length && (t = null);
                    var n = W.findOne(this._selector);
                    if (t) {
                        var o = t.find((function (e) {
                            return n !== e
                        }));
                        if ((i = o ? E(o, "bs.collapse") : null) && i._isTransitioning) return
                    }
                    if (!B.trigger(this._element, "show.bs.collapse").defaultPrevented) {
                        t && t.forEach((function (e) {
                            n !== e && r.collapseInterface(e, "hide"), i || _(e, "bs.collapse", null)
                        }));
                        var s = this._getDimension();
                        this._element.classList.remove("collapse"), this._element.classList.add("collapsing"), this._element.style[s] = 0, this._triggerArray.length && this._triggerArray.forEach((function (e) {
                            e.classList.remove("collapsed"), e.setAttribute("aria-expanded", !0)
                        })), this.setTransitioning(!0);
                        var a = "scroll" + (s[0].toUpperCase() + s.slice(1)),
                            l = u(this._element);
                        B.one(this._element, "transitionend", (function () {
                            e._element.classList.remove("collapsing"), e._element.classList.add("collapse", "show"), e._element.style[s] = "", e.setTransitioning(!1), B.trigger(e._element, "shown.bs.collapse")
                        })), p(this._element, l), this._element.style[s] = this._element[a] + "px"
                    }
                }
            }, o.hide = function () {
                var e = this;
                if (!this._isTransitioning && this._element.classList.contains("show") && !B.trigger(this._element, "hide.bs.collapse").defaultPrevented) {
                    var t = this._getDimension();
                    this._element.style[t] = this._element.getBoundingClientRect()[t] + "px", v(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show");
                    var i = this._triggerArray.length;
                    if (i > 0)
                        for (var n = 0; n < i; n++) {
                            var r = this._triggerArray[n],
                                o = c(r);
                            o && !o.classList.contains("show") && (r.classList.add("collapsed"), r.setAttribute("aria-expanded", !1))
                        }
                    this.setTransitioning(!0), this._element.style[t] = "";
                    var s = u(this._element);
                    B.one(this._element, "transitionend", (function () {
                        e.setTransitioning(!1), e._element.classList.remove("collapsing"), e._element.classList.add("collapse"), B.trigger(e._element, "hidden.bs.collapse")
                    })), p(this._element, s)
                }
            }, o.setTransitioning = function (e) {
                this._isTransitioning = e
            }, o.dispose = function () {
                e.prototype.dispose.call(this), this._config = null, this._parent = null, this._triggerArray = null, this._isTransitioning = null
            }, o._getConfig = function (e) {
                return (e = i({}, K, e)).toggle = Boolean(e.toggle), f(J, e, $), e
            }, o._getDimension = function () {
                return this._element.classList.contains("width") ? "width" : "height"
            }, o._getParent = function () {
                var e = this,
                    t = this._config.parent;
                d(t) ? void 0 === t.jquery && void 0 === t[0] || (t = t[0]) : t = W.findOne(t);
                var i = '[data-bs-toggle="collapse"][data-bs-parent="' + t + '"]';
                return W.find(i, t).forEach((function (t) {
                    var i = c(t);
                    e._addAriaAndCollapsedClass(i, [t])
                })), t
            }, o._addAriaAndCollapsedClass = function (e, t) {
                if (e && t.length) {
                    var i = e.classList.contains("show");
                    t.forEach((function (e) {
                        i ? e.classList.remove("collapsed") : e.classList.add("collapsed"), e.setAttribute("aria-expanded", i)
                    }))
                }
            }, r.collapseInterface = function (e, t) {
                var n = E(e, "bs.collapse"),
                    o = i({}, K, V.getDataAttributes(e), "object" == typeof t && t ? t : {});
                if (!n && o.toggle && "string" == typeof t && /show|hide/.test(t) && (o.toggle = !1), n || (n = new r(e, o)), "string" == typeof t) {
                    if (void 0 === n[t]) throw new TypeError('No method named "' + t + '"');
                    n[t]()
                }
            }, r.jQueryInterface = function (e) {
                return this.each((function () {
                    r.collapseInterface(this, e)
                }))
            }, t(r, null, [{
                key: "Default",
                get: function () {
                    return K
                }
            }, {
                key: "DATA_KEY",
                get: function () {
                    return "bs.collapse"
                }
            }]), r
        }(N);
    B.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', (function (e) {
        "A" === e.target.tagName && e.preventDefault();
        var t = V.getDataAttributes(this),
            i = l(this);
        W.find(i).forEach((function (e) {
            var i, n = E(e, "bs.collapse");
            n ? (null === n._parent && "string" == typeof t.parent && (n._config.parent = t.parent, n._parent = n._getParent()), i = "toggle") : i = t, ee.collapseInterface(e, i)
        }))
    })), b((function () {
        var e = y();
        if (e) {
            var t = e.fn[J];
            e.fn[J] = ee.jQueryInterface, e.fn[J].Constructor = ee, e.fn[J].noConflict = function () {
                return e.fn[J] = t, ee.jQueryInterface
            }
        }
    }));
    var te = "top",
        ie = "bottom",
        ne = "right",
        re = "left",
        oe = [te, ie, ne, re],
        se = oe.reduce((function (e, t) {
            return e.concat([t + "-start", t + "-end"])
        }), []),
        ae = [].concat(oe, ["auto"]).reduce((function (e, t) {
            return e.concat([t, t + "-start", t + "-end"])
        }), []),
        le = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];

    function ce(e) {
        return e ? (e.nodeName || "").toLowerCase() : null
    }

    function ue(e) {
        if ("[object Window]" !== e.toString()) {
            var t = e.ownerDocument;
            return t && t.defaultView || window
        }
        return e
    }

    function he(e) {
        return e instanceof ue(e).Element || e instanceof Element
    }

    function de(e) {
        return e instanceof ue(e).HTMLElement || e instanceof HTMLElement
    }
    var pe = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: function (e) {
            var t = e.state;
            Object.keys(t.elements).forEach((function (e) {
                var i = t.styles[e] || {},
                    n = t.attributes[e] || {},
                    r = t.elements[e];
                de(r) && ce(r) && (Object.assign(r.style, i), Object.keys(n).forEach((function (e) {
                    var t = n[e];
                    !1 === t ? r.removeAttribute(e) : r.setAttribute(e, !0 === t ? "" : t)
                })))
            }))
        },
        effect: function (e) {
            var t = e.state,
                i = {
                    popper: {
                        position: t.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
            return Object.assign(t.elements.popper.style, i.popper), t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow),
                function () {
                    Object.keys(t.elements).forEach((function (e) {
                        var n = t.elements[e],
                            r = t.attributes[e] || {},
                            o = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : i[e]).reduce((function (e, t) {
                                return e[t] = "", e
                            }), {});
                        de(n) && ce(n) && (Object.assign(n.style, o), Object.keys(r).forEach((function (e) {
                            n.removeAttribute(e)
                        })))
                    }))
                }
        },
        requires: ["computeStyles"]
    };

    function fe(e) {
        return e.split("-")[0]
    }

    function me(e) {
        return {
            x: e.offsetLeft,
            y: e.offsetTop,
            width: e.offsetWidth,
            height: e.offsetHeight
        }
    }

    function ge(e, t) {
        var i, n = t.getRootNode && t.getRootNode();
        if (e.contains(t)) return !0;
        if (n && ((i = n) instanceof ue(i).ShadowRoot || i instanceof ShadowRoot)) {
            var r = t;
            do {
                if (r && e.isSameNode(r)) return !0;
                r = r.parentNode || r.host
            } while (r)
        }
        return !1
    }

    function ve(e) {
        return ue(e).getComputedStyle(e)
    }

    function ye(e) {
        return ["table", "td", "th"].indexOf(ce(e)) >= 0
    }

    function be(e) {
        return ((he(e) ? e.ownerDocument : e.document) || window.document).documentElement
    }

    function xe(e) {
        return "html" === ce(e) ? e : e.assignedSlot || e.parentNode || e.host || be(e)
    }

    function we(e) {
        if (!de(e) || "fixed" === ve(e).position) return null;
        var t = e.offsetParent;
        if (t) {
            var i = be(t);
            if ("body" === ce(t) && "static" === ve(t).position && "static" !== ve(i).position) return i
        }
        return t
    }

    function _e(e) {
        for (var t = ue(e), i = we(e); i && ye(i) && "static" === ve(i).position;) i = we(i);
        return i && "body" === ce(i) && "static" === ve(i).position ? t : i || function (e) {
            for (var t = xe(e); de(t) && ["html", "body"].indexOf(ce(t)) < 0;) {
                var i = ve(t);
                if ("none" !== i.transform || "none" !== i.perspective || i.willChange && "auto" !== i.willChange) return t;
                t = t.parentNode
            }
            return null
        }(e) || t
    }

    function Ee(e) {
        return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
    }

    function Me(e, t, i) {
        return Math.max(e, Math.min(t, i))
    }

    function Se(e) {
        return Object.assign(Object.assign({}, {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }), e)
    }

    function Te(e, t) {
        return t.reduce((function (t, i) {
            return t[i] = e, t
        }), {})
    }
    var Ae = {
            name: "arrow",
            enabled: !0,
            phase: "main",
            fn: function (e) {
                var t, i = e.state,
                    n = e.name,
                    r = i.elements.arrow,
                    o = i.modifiersData.popperOffsets,
                    s = fe(i.placement),
                    a = Ee(s),
                    l = [re, ne].indexOf(s) >= 0 ? "height" : "width";
                if (r && o) {
                    var c = i.modifiersData[n + "#persistent"].padding,
                        u = me(r),
                        h = "y" === a ? te : re,
                        d = "y" === a ? ie : ne,
                        p = i.rects.reference[l] + i.rects.reference[a] - o[a] - i.rects.popper[l],
                        f = o[a] - i.rects.reference[a],
                        m = _e(r),
                        g = m ? "y" === a ? m.clientHeight || 0 : m.clientWidth || 0 : 0,
                        v = p / 2 - f / 2,
                        y = c[h],
                        b = g - u[l] - c[d],
                        x = g / 2 - u[l] / 2 + v,
                        w = Me(y, x, b),
                        _ = a;
                    i.modifiersData[n] = ((t = {})[_] = w, t.centerOffset = w - x, t)
                }
            },
            effect: function (e) {
                var t = e.state,
                    i = e.options,
                    n = e.name,
                    r = i.element,
                    o = void 0 === r ? "[data-popper-arrow]" : r,
                    s = i.padding,
                    a = void 0 === s ? 0 : s;
                null != o && ("string" != typeof o || (o = t.elements.popper.querySelector(o))) && ge(t.elements.popper, o) && (t.elements.arrow = o, t.modifiersData[n + "#persistent"] = {
                    padding: Se("number" != typeof a ? a : Te(a, oe))
                })
            },
            requires: ["popperOffsets"],
            requiresIfExists: ["preventOverflow"]
        },
        Ce = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };

    function Le(e) {
        var t, i = e.popper,
            n = e.popperRect,
            r = e.placement,
            o = e.offsets,
            s = e.position,
            a = e.gpuAcceleration,
            l = e.adaptive,
            c = function (e) {
                var t = e.x,
                    i = e.y,
                    n = window.devicePixelRatio || 1;
                return {
                    x: Math.round(t * n) / n || 0,
                    y: Math.round(i * n) / n || 0
                }
            }(o),
            u = c.x,
            h = c.y,
            d = o.hasOwnProperty("x"),
            p = o.hasOwnProperty("y"),
            f = re,
            m = te,
            g = window;
        if (l) {
            var v = _e(i);
            v === ue(i) && (v = be(i)), r === te && (m = ie, h -= v.clientHeight - n.height, h *= a ? 1 : -1), r === re && (f = ne, u -= v.clientWidth - n.width, u *= a ? 1 : -1)
        }
        var y, b = Object.assign({
            position: s
        }, l && Ce);
        return a ? Object.assign(Object.assign({}, b), {}, ((y = {})[m] = p ? "0" : "", y[f] = d ? "0" : "", y.transform = (g.devicePixelRatio || 1) < 2 ? "translate(" + u + "px, " + h + "px)" : "translate3d(" + u + "px, " + h + "px, 0)", y)) : Object.assign(Object.assign({}, b), {}, ((t = {})[m] = p ? h + "px" : "", t[f] = d ? u + "px" : "", t.transform = "", t))
    }
    var Pe = {
            name: "computeStyles",
            enabled: !0,
            phase: "beforeWrite",
            fn: function (e) {
                var t = e.state,
                    i = e.options,
                    n = i.gpuAcceleration,
                    r = void 0 === n || n,
                    o = i.adaptive,
                    s = void 0 === o || o,
                    a = {
                        placement: fe(t.placement),
                        popper: t.elements.popper,
                        popperRect: t.rects.popper,
                        gpuAcceleration: r
                    };
                null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign(Object.assign({}, t.styles.popper), Le(Object.assign(Object.assign({}, a), {}, {
                    offsets: t.modifiersData.popperOffsets,
                    position: t.options.strategy,
                    adaptive: s
                })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign(Object.assign({}, t.styles.arrow), Le(Object.assign(Object.assign({}, a), {}, {
                    offsets: t.modifiersData.arrow,
                    position: "absolute",
                    adaptive: !1
                })))), t.attributes.popper = Object.assign(Object.assign({}, t.attributes.popper), {}, {
                    "data-popper-placement": t.placement
                })
            },
            data: {}
        },
        Ie = {
            passive: !0
        },
        Oe = {
            name: "eventListeners",
            enabled: !0,
            phase: "write",
            fn: function () {},
            effect: function (e) {
                var t = e.state,
                    i = e.instance,
                    n = e.options,
                    r = n.scroll,
                    o = void 0 === r || r,
                    s = n.resize,
                    a = void 0 === s || s,
                    l = ue(t.elements.popper),
                    c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
                return o && c.forEach((function (e) {
                        e.addEventListener("scroll", i.update, Ie)
                    })), a && l.addEventListener("resize", i.update, Ie),
                    function () {
                        o && c.forEach((function (e) {
                            e.removeEventListener("scroll", i.update, Ie)
                        })), a && l.removeEventListener("resize", i.update, Ie)
                    }
            },
            data: {}
        },
        Re = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };

    function De(e) {
        return e.replace(/left|right|bottom|top/g, (function (e) {
            return Re[e]
        }))
    }
    var ke = {
        start: "end",
        end: "start"
    };

    function ze(e) {
        return e.replace(/start|end/g, (function (e) {
            return ke[e]
        }))
    }

    function Be(e) {
        var t = e.getBoundingClientRect();
        return {
            width: t.width,
            height: t.height,
            top: t.top,
            right: t.right,
            bottom: t.bottom,
            left: t.left,
            x: t.left,
            y: t.top
        }
    }

    function Ne(e) {
        var t = ue(e);
        return {
            scrollLeft: t.pageXOffset,
            scrollTop: t.pageYOffset
        }
    }

    function Fe(e) {
        return Be(be(e)).left + Ne(e).scrollLeft
    }

    function He(e) {
        var t = ve(e),
            i = t.overflow,
            n = t.overflowX,
            r = t.overflowY;
        return /auto|scroll|overlay|hidden/.test(i + r + n)
    }

    function Ue(e, t) {
        void 0 === t && (t = []);
        var i = function e(t) {
                return ["html", "body", "#document"].indexOf(ce(t)) >= 0 ? t.ownerDocument.body : de(t) && He(t) ? t : e(xe(t))
            }(e),
            n = "body" === ce(i),
            r = ue(i),
            o = n ? [r].concat(r.visualViewport || [], He(i) ? i : []) : i,
            s = t.concat(o);
        return n ? s : s.concat(Ue(xe(o)))
    }

    function je(e) {
        return Object.assign(Object.assign({}, e), {}, {
            left: e.x,
            top: e.y,
            right: e.x + e.width,
            bottom: e.y + e.height
        })
    }

    function Ge(e, t) {
        return "viewport" === t ? je(function (e) {
            var t = ue(e),
                i = be(e),
                n = t.visualViewport,
                r = i.clientWidth,
                o = i.clientHeight,
                s = 0,
                a = 0;
            return n && (r = n.width, o = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (s = n.offsetLeft, a = n.offsetTop)), {
                width: r,
                height: o,
                x: s + Fe(e),
                y: a
            }
        }(e)) : de(t) ? function (e) {
            var t = Be(e);
            return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t
        }(t) : je(function (e) {
            var t = be(e),
                i = Ne(e),
                n = e.ownerDocument.body,
                r = Math.max(t.scrollWidth, t.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0),
                o = Math.max(t.scrollHeight, t.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0),
                s = -i.scrollLeft + Fe(e),
                a = -i.scrollTop;
            return "rtl" === ve(n || t).direction && (s += Math.max(t.clientWidth, n ? n.clientWidth : 0) - r), {
                width: r,
                height: o,
                x: s,
                y: a
            }
        }(be(e)))
    }

    function Ve(e) {
        return e.split("-")[1]
    }

    function We(e) {
        var t, i = e.reference,
            n = e.element,
            r = e.placement,
            o = r ? fe(r) : null,
            s = r ? Ve(r) : null,
            a = i.x + i.width / 2 - n.width / 2,
            l = i.y + i.height / 2 - n.height / 2;
        switch (o) {
            case te:
                t = {
                    x: a,
                    y: i.y - n.height
                };
                break;
            case ie:
                t = {
                    x: a,
                    y: i.y + i.height
                };
                break;
            case ne:
                t = {
                    x: i.x + i.width,
                    y: l
                };
                break;
            case re:
                t = {
                    x: i.x - n.width,
                    y: l
                };
                break;
            default:
                t = {
                    x: i.x,
                    y: i.y
                }
        }
        var c = o ? Ee(o) : null;
        if (null != c) {
            var u = "y" === c ? "height" : "width";
            switch (s) {
                case "start":
                    t[c] = Math.floor(t[c]) - Math.floor(i[u] / 2 - n[u] / 2);
                    break;
                case "end":
                    t[c] = Math.floor(t[c]) + Math.ceil(i[u] / 2 - n[u] / 2)
            }
        }
        return t
    }

    function qe(e, t) {
        void 0 === t && (t = {});
        var i = t,
            n = i.placement,
            r = void 0 === n ? e.placement : n,
            o = i.boundary,
            s = void 0 === o ? "clippingParents" : o,
            a = i.rootBoundary,
            l = void 0 === a ? "viewport" : a,
            c = i.elementContext,
            u = void 0 === c ? "popper" : c,
            h = i.altBoundary,
            d = void 0 !== h && h,
            p = i.padding,
            f = void 0 === p ? 0 : p,
            m = Se("number" != typeof f ? f : Te(f, oe)),
            g = "popper" === u ? "reference" : "popper",
            v = e.elements.reference,
            y = e.rects.popper,
            b = e.elements[d ? g : u],
            x = function (e, t, i) {
                var n = "clippingParents" === t ? function (e) {
                        var t = Ue(xe(e)),
                            i = ["absolute", "fixed"].indexOf(ve(e).position) >= 0 && de(e) ? _e(e) : e;
                        return he(i) ? t.filter((function (e) {
                            return he(e) && ge(e, i) && "body" !== ce(e)
                        })) : []
                    }(e) : [].concat(t),
                    r = [].concat(n, [i]),
                    o = r[0],
                    s = r.reduce((function (t, i) {
                        var n = Ge(e, i);
                        return t.top = Math.max(n.top, t.top), t.right = Math.min(n.right, t.right), t.bottom = Math.min(n.bottom, t.bottom), t.left = Math.max(n.left, t.left), t
                    }), Ge(e, o));
                return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s
            }(he(b) ? b : b.contextElement || be(e.elements.popper), s, l),
            w = Be(v),
            _ = We({
                reference: w,
                element: y,
                strategy: "absolute",
                placement: r
            }),
            E = je(Object.assign(Object.assign({}, y), _)),
            M = "popper" === u ? E : w,
            S = {
                top: x.top - M.top + m.top,
                bottom: M.bottom - x.bottom + m.bottom,
                left: x.left - M.left + m.left,
                right: M.right - x.right + m.right
            },
            T = e.modifiersData.offset;
        if ("popper" === u && T) {
            var A = T[r];
            Object.keys(S).forEach((function (e) {
                var t = [ne, ie].indexOf(e) >= 0 ? 1 : -1,
                    i = [te, ie].indexOf(e) >= 0 ? "y" : "x";
                S[e] += A[i] * t
            }))
        }
        return S
    }
    var Xe = {
        name: "flip",
        enabled: !0,
        phase: "main",
        fn: function (e) {
            var t = e.state,
                i = e.options,
                n = e.name;
            if (!t.modifiersData[n]._skip) {
                for (var r = i.mainAxis, o = void 0 === r || r, s = i.altAxis, a = void 0 === s || s, l = i.fallbackPlacements, c = i.padding, u = i.boundary, h = i.rootBoundary, d = i.altBoundary, p = i.flipVariations, f = void 0 === p || p, m = i.allowedAutoPlacements, g = t.options.placement, v = fe(g), y = l || (v !== g && f ? function (e) {
                        if ("auto" === fe(e)) return [];
                        var t = De(e);
                        return [ze(e), t, ze(t)]
                    }(g) : [De(g)]), b = [g].concat(y).reduce((function (e, i) {
                        return e.concat("auto" === fe(i) ? function (e, t) {
                            void 0 === t && (t = {});
                            var i = t,
                                n = i.placement,
                                r = i.boundary,
                                o = i.rootBoundary,
                                s = i.padding,
                                a = i.flipVariations,
                                l = i.allowedAutoPlacements,
                                c = void 0 === l ? ae : l,
                                u = Ve(n),
                                h = u ? a ? se : se.filter((function (e) {
                                    return Ve(e) === u
                                })) : oe,
                                d = h.filter((function (e) {
                                    return c.indexOf(e) >= 0
                                }));
                            0 === d.length && (d = h);
                            var p = d.reduce((function (t, i) {
                                return t[i] = qe(e, {
                                    placement: i,
                                    boundary: r,
                                    rootBoundary: o,
                                    padding: s
                                })[fe(i)], t
                            }), {});
                            return Object.keys(p).sort((function (e, t) {
                                return p[e] - p[t]
                            }))
                        }(t, {
                            placement: i,
                            boundary: u,
                            rootBoundary: h,
                            padding: c,
                            flipVariations: f,
                            allowedAutoPlacements: m
                        }) : i)
                    }), []), x = t.rects.reference, w = t.rects.popper, _ = new Map, E = !0, M = b[0], S = 0; S < b.length; S++) {
                    var T = b[S],
                        A = fe(T),
                        C = "start" === Ve(T),
                        L = [te, ie].indexOf(A) >= 0,
                        P = L ? "width" : "height",
                        I = qe(t, {
                            placement: T,
                            boundary: u,
                            rootBoundary: h,
                            altBoundary: d,
                            padding: c
                        }),
                        O = L ? C ? ne : re : C ? ie : te;
                    x[P] > w[P] && (O = De(O));
                    var R = De(O),
                        D = [];
                    if (o && D.push(I[A] <= 0), a && D.push(I[O] <= 0, I[R] <= 0), D.every((function (e) {
                            return e
                        }))) {
                        M = T, E = !1;
                        break
                    }
                    _.set(T, D)
                }
                if (E)
                    for (var k = function (e) {
                            var t = b.find((function (t) {
                                var i = _.get(t);
                                if (i) return i.slice(0, e).every((function (e) {
                                    return e
                                }))
                            }));
                            if (t) return M = t, "break"
                        }, z = f ? 3 : 1; z > 0 && "break" !== k(z); z--);
                t.placement !== M && (t.modifiersData[n]._skip = !0, t.placement = M, t.reset = !0)
            }
        },
        requiresIfExists: ["offset"],
        data: {
            _skip: !1
        }
    };

    function Ye(e, t, i) {
        return void 0 === i && (i = {
            x: 0,
            y: 0
        }), {
            top: e.top - t.height - i.y,
            right: e.right - t.width + i.x,
            bottom: e.bottom - t.height + i.y,
            left: e.left - t.width - i.x
        }
    }

    function Ze(e) {
        return [te, ne, ie, re].some((function (t) {
            return e[t] >= 0
        }))
    }
    var Qe = {
            name: "hide",
            enabled: !0,
            phase: "main",
            requiresIfExists: ["preventOverflow"],
            fn: function (e) {
                var t = e.state,
                    i = e.name,
                    n = t.rects.reference,
                    r = t.rects.popper,
                    o = t.modifiersData.preventOverflow,
                    s = qe(t, {
                        elementContext: "reference"
                    }),
                    a = qe(t, {
                        altBoundary: !0
                    }),
                    l = Ye(s, n),
                    c = Ye(a, r, o),
                    u = Ze(l),
                    h = Ze(c);
                t.modifiersData[i] = {
                    referenceClippingOffsets: l,
                    popperEscapeOffsets: c,
                    isReferenceHidden: u,
                    hasPopperEscaped: h
                }, t.attributes.popper = Object.assign(Object.assign({}, t.attributes.popper), {}, {
                    "data-popper-reference-hidden": u,
                    "data-popper-escaped": h
                })
            }
        },
        Je = {
            name: "offset",
            enabled: !0,
            phase: "main",
            requires: ["popperOffsets"],
            fn: function (e) {
                var t = e.state,
                    i = e.options,
                    n = e.name,
                    r = i.offset,
                    o = void 0 === r ? [0, 0] : r,
                    s = ae.reduce((function (e, i) {
                        return e[i] = function (e, t, i) {
                            var n = fe(e),
                                r = [re, te].indexOf(n) >= 0 ? -1 : 1,
                                o = "function" == typeof i ? i(Object.assign(Object.assign({}, t), {}, {
                                    placement: e
                                })) : i,
                                s = o[0],
                                a = o[1];
                            return s = s || 0, a = (a || 0) * r, [re, ne].indexOf(n) >= 0 ? {
                                x: a,
                                y: s
                            } : {
                                x: s,
                                y: a
                            }
                        }(i, t.rects, o), e
                    }), {}),
                    a = s[t.placement],
                    l = a.x,
                    c = a.y;
                null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[n] = s
            }
        },
        Ke = {
            name: "popperOffsets",
            enabled: !0,
            phase: "read",
            fn: function (e) {
                var t = e.state,
                    i = e.name;
                t.modifiersData[i] = We({
                    reference: t.rects.reference,
                    element: t.rects.popper,
                    strategy: "absolute",
                    placement: t.placement
                })
            },
            data: {}
        },
        $e = {
            name: "preventOverflow",
            enabled: !0,
            phase: "main",
            fn: function (e) {
                var t = e.state,
                    i = e.options,
                    n = e.name,
                    r = i.mainAxis,
                    o = void 0 === r || r,
                    s = i.altAxis,
                    a = void 0 !== s && s,
                    l = i.boundary,
                    c = i.rootBoundary,
                    u = i.altBoundary,
                    h = i.padding,
                    d = i.tether,
                    p = void 0 === d || d,
                    f = i.tetherOffset,
                    m = void 0 === f ? 0 : f,
                    g = qe(t, {
                        boundary: l,
                        rootBoundary: c,
                        padding: h,
                        altBoundary: u
                    }),
                    v = fe(t.placement),
                    y = Ve(t.placement),
                    b = !y,
                    x = Ee(v),
                    w = "x" === x ? "y" : "x",
                    _ = t.modifiersData.popperOffsets,
                    E = t.rects.reference,
                    M = t.rects.popper,
                    S = "function" == typeof m ? m(Object.assign(Object.assign({}, t.rects), {}, {
                        placement: t.placement
                    })) : m,
                    T = {
                        x: 0,
                        y: 0
                    };
                if (_) {
                    if (o) {
                        var A = "y" === x ? te : re,
                            C = "y" === x ? ie : ne,
                            L = "y" === x ? "height" : "width",
                            P = _[x],
                            I = _[x] + g[A],
                            O = _[x] - g[C],
                            R = p ? -M[L] / 2 : 0,
                            D = "start" === y ? E[L] : M[L],
                            k = "start" === y ? -M[L] : -E[L],
                            z = t.elements.arrow,
                            B = p && z ? me(z) : {
                                width: 0,
                                height: 0
                            },
                            N = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0
                            },
                            F = N[A],
                            H = N[C],
                            U = Me(0, E[L], B[L]),
                            j = b ? E[L] / 2 - R - U - F - S : D - U - F - S,
                            G = b ? -E[L] / 2 + R + U + H + S : k + U + H + S,
                            V = t.elements.arrow && _e(t.elements.arrow),
                            W = V ? "y" === x ? V.clientTop || 0 : V.clientLeft || 0 : 0,
                            q = t.modifiersData.offset ? t.modifiersData.offset[t.placement][x] : 0,
                            X = _[x] + j - q - W,
                            Y = _[x] + G - q,
                            Z = Me(p ? Math.min(I, X) : I, P, p ? Math.max(O, Y) : O);
                        _[x] = Z, T[x] = Z - P
                    }
                    if (a) {
                        var Q = "x" === x ? te : re,
                            J = "x" === x ? ie : ne,
                            K = _[w],
                            $ = Me(K + g[Q], K, K - g[J]);
                        _[w] = $, T[w] = $ - K
                    }
                    t.modifiersData[n] = T
                }
            },
            requiresIfExists: ["offset"]
        };

    function et(e, t, i) {
        void 0 === i && (i = !1);
        var n, r, o = be(t),
            s = Be(e),
            a = de(t),
            l = {
                scrollLeft: 0,
                scrollTop: 0
            },
            c = {
                x: 0,
                y: 0
            };
        return (a || !a && !i) && (("body" !== ce(t) || He(o)) && (l = (n = t) !== ue(n) && de(n) ? {
            scrollLeft: (r = n).scrollLeft,
            scrollTop: r.scrollTop
        } : Ne(n)), de(t) ? ((c = Be(t)).x += t.clientLeft, c.y += t.clientTop) : o && (c.x = Fe(o))), {
            x: s.left + l.scrollLeft - c.x,
            y: s.top + l.scrollTop - c.y,
            width: s.width,
            height: s.height
        }
    }
    var tt = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };

    function it() {
        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
        return !t.some((function (e) {
            return !(e && "function" == typeof e.getBoundingClientRect)
        }))
    }

    function nt(e) {
        void 0 === e && (e = {});
        var t = e,
            i = t.defaultModifiers,
            n = void 0 === i ? [] : i,
            r = t.defaultOptions,
            o = void 0 === r ? tt : r;
        return function (e, t, i) {
            void 0 === i && (i = o);
            var r, s, a = {
                    placement: "bottom",
                    orderedModifiers: [],
                    options: Object.assign(Object.assign({}, tt), o),
                    modifiersData: {},
                    elements: {
                        reference: e,
                        popper: t
                    },
                    attributes: {},
                    styles: {}
                },
                l = [],
                c = !1,
                u = {
                    state: a,
                    setOptions: function (i) {
                        h(), a.options = Object.assign(Object.assign(Object.assign({}, o), a.options), i), a.scrollParents = {
                            reference: he(e) ? Ue(e) : e.contextElement ? Ue(e.contextElement) : [],
                            popper: Ue(t)
                        };
                        var r, s, c = function (e) {
                            var t = function (e) {
                                var t = new Map,
                                    i = new Set,
                                    n = [];
                                return e.forEach((function (e) {
                                    t.set(e.name, e)
                                })), e.forEach((function (e) {
                                    i.has(e.name) || function e(r) {
                                        i.add(r.name), [].concat(r.requires || [], r.requiresIfExists || []).forEach((function (n) {
                                            if (!i.has(n)) {
                                                var r = t.get(n);
                                                r && e(r)
                                            }
                                        })), n.push(r)
                                    }(e)
                                })), n
                            }(e);
                            return le.reduce((function (e, i) {
                                return e.concat(t.filter((function (e) {
                                    return e.phase === i
                                })))
                            }), [])
                        }((r = [].concat(n, a.options.modifiers), s = r.reduce((function (e, t) {
                            var i = e[t.name];
                            return e[t.name] = i ? Object.assign(Object.assign(Object.assign({}, i), t), {}, {
                                options: Object.assign(Object.assign({}, i.options), t.options),
                                data: Object.assign(Object.assign({}, i.data), t.data)
                            }) : t, e
                        }), {}), Object.keys(s).map((function (e) {
                            return s[e]
                        }))));
                        return a.orderedModifiers = c.filter((function (e) {
                            return e.enabled
                        })), a.orderedModifiers.forEach((function (e) {
                            var t = e.name,
                                i = e.options,
                                n = void 0 === i ? {} : i,
                                r = e.effect;
                            if ("function" == typeof r) {
                                var o = r({
                                    state: a,
                                    name: t,
                                    instance: u,
                                    options: n
                                });
                                l.push(o || function () {})
                            }
                        })), u.update()
                    },
                    forceUpdate: function () {
                        if (!c) {
                            var e = a.elements,
                                t = e.reference,
                                i = e.popper;
                            if (it(t, i)) {
                                a.rects = {
                                    reference: et(t, _e(i), "fixed" === a.options.strategy),
                                    popper: me(i)
                                }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function (e) {
                                    return a.modifiersData[e.name] = Object.assign({}, e.data)
                                }));
                                for (var n = 0; n < a.orderedModifiers.length; n++)
                                    if (!0 !== a.reset) {
                                        var r = a.orderedModifiers[n],
                                            o = r.fn,
                                            s = r.options,
                                            l = void 0 === s ? {} : s,
                                            h = r.name;
                                        "function" == typeof o && (a = o({
                                            state: a,
                                            options: l,
                                            name: h,
                                            instance: u
                                        }) || a)
                                    } else a.reset = !1, n = -1
                            }
                        }
                    },
                    update: (r = function () {
                        return new Promise((function (e) {
                            u.forceUpdate(), e(a)
                        }))
                    }, function () {
                        return s || (s = new Promise((function (e) {
                            Promise.resolve().then((function () {
                                s = void 0, e(r())
                            }))
                        }))), s
                    }),
                    destroy: function () {
                        h(), c = !0
                    }
                };
            if (!it(e, t)) return u;

            function h() {
                l.forEach((function (e) {
                    return e()
                })), l = []
            }
            return u.setOptions(i).then((function (e) {
                !c && i.onFirstUpdate && i.onFirstUpdate(e)
            })), u
        }
    }
    var rt = nt(),
        ot = nt({
            defaultModifiers: [Oe, Ke, Pe, pe]
        }),
        st = nt({
            defaultModifiers: [Oe, Ke, Pe, pe, Je, Xe, $e, Ae, Qe]
        }),
        at = Object.freeze({
            __proto__: null,
            popperGenerator: nt,
            detectOverflow: qe,
            createPopperBase: rt,
            createPopper: st,
            createPopperLite: ot,
            top: te,
            bottom: ie,
            right: ne,
            left: re,
            auto: "auto",
            basePlacements: oe,
            start: "start",
            end: "end",
            clippingParents: "clippingParents",
            viewport: "viewport",
            popper: "popper",
            reference: "reference",
            variationPlacements: se,
            placements: ae,
            beforeRead: "beforeRead",
            read: "read",
            afterRead: "afterRead",
            beforeMain: "beforeMain",
            main: "main",
            afterMain: "afterMain",
            beforeWrite: "beforeWrite",
            write: "write",
            afterWrite: "afterWrite",
            modifierPhases: le,
            applyStyles: pe,
            arrow: Ae,
            computeStyles: Pe,
            eventListeners: Oe,
            flip: Xe,
            hide: Qe,
            offset: Je,
            popperOffsets: Ke,
            preventOverflow: $e
        }),
        lt = "dropdown",
        ct = new RegExp("ArrowUp|ArrowDown|Escape"),
        ut = x ? "top-end" : "top-start",
        ht = x ? "top-start" : "top-end",
        dt = x ? "bottom-end" : "bottom-start",
        pt = x ? "bottom-start" : "bottom-end",
        ft = x ? "left-start" : "right-start",
        mt = x ? "right-start" : "left-start",
        gt = {
            offset: 0,
            flip: !0,
            boundary: "clippingParents",
            reference: "toggle",
            display: "dynamic",
            popperConfig: null
        },
        vt = {
            offset: "(number|string|function)",
            flip: "boolean",
            boundary: "(string|element)",
            reference: "(string|element)",
            display: "string",
            popperConfig: "(null|object)"
        },
        yt = function (e) {
            function r(t, i) {
                var n;
                return (n = e.call(this, t) || this)._popper = null, n._config = n._getConfig(i), n._menu = n._getMenuElement(), n._inNavbar = n._detectNavbar(), n._addEventListeners(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.toggle = function () {
                if (!this._element.disabled && !this._element.classList.contains("disabled")) {
                    var e = this._element.classList.contains("show");
                    r.clearMenus(), e || this.show()
                }
            }, o.show = function () {
                if (!(this._element.disabled || this._element.classList.contains("disabled") || this._menu.classList.contains("show"))) {
                    var e = r.getParentFromElement(this._element),
                        t = {
                            relatedTarget: this._element
                        };
                    if (!B.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) {
                        if (!this._inNavbar) {
                            if (void 0 === at) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                            var i = this._element;
                            "parent" === this._config.reference ? i = e : d(this._config.reference) && (i = this._config.reference, void 0 !== this._config.reference.jquery && (i = this._config.reference[0])), this._popper = st(i, this._menu, this._getPopperConfig())
                        }
                        var n;
                        "ontouchstart" in document.documentElement && !e.closest(".navbar-nav") && (n = []).concat.apply(n, document.body.children).forEach((function (e) {
                            return B.on(e, "mouseover", null, (function () {}))
                        })), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), B.trigger(e, "shown.bs.dropdown", t)
                    }
                }
            }, o.hide = function () {
                if (!this._element.disabled && !this._element.classList.contains("disabled") && this._menu.classList.contains("show")) {
                    var e = r.getParentFromElement(this._element),
                        t = {
                            relatedTarget: this._element
                        };
                    B.trigger(e, "hide.bs.dropdown", t).defaultPrevented || (this._popper && this._popper.destroy(), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), B.trigger(e, "hidden.bs.dropdown", t))
                }
            }, o.dispose = function () {
                e.prototype.dispose.call(this), B.off(this._element, ".bs.dropdown"), this._menu = null, this._popper && (this._popper.destroy(), this._popper = null)
            }, o.update = function () {
                this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
            }, o._addEventListeners = function () {
                var e = this;
                B.on(this._element, "click.bs.dropdown", (function (t) {
                    t.preventDefault(), t.stopPropagation(), e.toggle()
                }))
            }, o._getConfig = function (e) {
                return e = i({}, this.constructor.Default, V.getDataAttributes(this._element), e), f(lt, e, this.constructor.DefaultType), e
            }, o._getMenuElement = function () {
                return W.next(this._element, ".dropdown-menu")[0]
            }, o._getPlacement = function () {
                var e = this._element.parentNode;
                if (e.classList.contains("dropend")) return ft;
                if (e.classList.contains("dropstart")) return mt;
                var t = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
                return e.classList.contains("dropup") ? t ? ht : ut : t ? pt : dt
            }, o._detectNavbar = function () {
                return null !== this._element.closest(".navbar")
            }, o._getPopperConfig = function () {
                var e = {
                    placement: this._getPlacement(),
                    modifiers: [{
                        name: "preventOverflow",
                        options: {
                            altBoundary: this._config.flip,
                            rootBoundary: this._config.boundary
                        }
                    }]
                };
                return "static" === this._config.display && (e.modifiers = [{
                    name: "applyStyles",
                    enabled: !1
                }]), i({}, e, this._config.popperConfig)
            }, r.dropdownInterface = function (e, t) {
                var i = E(e, "bs.dropdown");
                if (i || (i = new r(e, "object" == typeof t ? t : null)), "string" == typeof t) {
                    if (void 0 === i[t]) throw new TypeError('No method named "' + t + '"');
                    i[t]()
                }
            }, r.jQueryInterface = function (e) {
                return this.each((function () {
                    r.dropdownInterface(this, e)
                }))
            }, r.clearMenus = function (e) {
                if (!e || 2 !== e.button && ("keyup" !== e.type || "Tab" === e.key))
                    for (var t = W.find('[data-bs-toggle="dropdown"]'), i = 0, n = t.length; i < n; i++) {
                        var o = r.getParentFromElement(t[i]),
                            s = E(t[i], "bs.dropdown"),
                            a = {
                                relatedTarget: t[i]
                            };
                        if (e && "click" === e.type && (a.clickEvent = e), s) {
                            var l, c = s._menu;
                            if (t[i].classList.contains("show") && !(e && ("click" === e.type && /input|textarea/i.test(e.target.tagName) || "keyup" === e.type && "Tab" === e.key) && c.contains(e.target) || B.trigger(o, "hide.bs.dropdown", a).defaultPrevented)) "ontouchstart" in document.documentElement && (l = []).concat.apply(l, document.body.children).forEach((function (e) {
                                return B.off(e, "mouseover", null, (function () {}))
                            })), t[i].setAttribute("aria-expanded", "false"), s._popper && s._popper.destroy(), c.classList.remove("show"), t[i].classList.remove("show"), B.trigger(o, "hidden.bs.dropdown", a)
                        }
                    }
            }, r.getParentFromElement = function (e) {
                return c(e) || e.parentNode
            }, r.dataApiKeydownHandler = function (e) {
                if (!(/input|textarea/i.test(e.target.tagName) ? "Space" === e.key || "Escape" !== e.key && ("ArrowDown" !== e.key && "ArrowUp" !== e.key || e.target.closest(".dropdown-menu")) : !ct.test(e.key)) && (e.preventDefault(), e.stopPropagation(), !this.disabled && !this.classList.contains("disabled"))) {
                    var t = r.getParentFromElement(this),
                        i = this.classList.contains("show");
                    if ("Escape" === e.key) return (this.matches('[data-bs-toggle="dropdown"]') ? this : W.prev(this, '[data-bs-toggle="dropdown"]')[0]).focus(), void r.clearMenus();
                    if (i && "Space" !== e.key) {
                        var n = W.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", t).filter(m);
                        if (n.length) {
                            var o = n.indexOf(e.target);
                            "ArrowUp" === e.key && o > 0 && o--, "ArrowDown" === e.key && o < n.length - 1 && o++, n[o = -1 === o ? 0 : o].focus()
                        }
                    } else r.clearMenus()
                }
            }, t(r, null, [{
                key: "Default",
                get: function () {
                    return gt
                }
            }, {
                key: "DefaultType",
                get: function () {
                    return vt
                }
            }, {
                key: "DATA_KEY",
                get: function () {
                    return "bs.dropdown"
                }
            }]), r
        }(N);
    B.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', yt.dataApiKeydownHandler), B.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", yt.dataApiKeydownHandler), B.on(document, "click.bs.dropdown.data-api", yt.clearMenus), B.on(document, "keyup.bs.dropdown.data-api", yt.clearMenus), B.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', (function (e) {
        e.preventDefault(), e.stopPropagation(), yt.dropdownInterface(this, "toggle")
    })), B.on(document, "click.bs.dropdown.data-api", ".dropdown form", (function (e) {
        return e.stopPropagation()
    })), b((function () {
        var e = y();
        if (e) {
            var t = e.fn[lt];
            e.fn[lt] = yt.jQueryInterface, e.fn[lt].Constructor = yt, e.fn[lt].noConflict = function () {
                return e.fn[lt] = t, yt.jQueryInterface
            }
        }
    }));
    var bt = {
            backdrop: !0,
            keyboard: !0,
            focus: !0
        },
        xt = {
            backdrop: "(boolean|string)",
            keyboard: "boolean",
            focus: "boolean"
        },
        wt = function (e) {
            function r(t, i) {
                var n;
                return (n = e.call(this, t) || this)._config = n._getConfig(i), n._dialog = W.findOne(".modal-dialog", t), n._backdrop = null, n._isShown = !1, n._isBodyOverflowing = !1, n._ignoreBackdropClick = !1, n._isTransitioning = !1, n._scrollbarWidth = 0, n
            }
            n(r, e);
            var o = r.prototype;
            return o.toggle = function (e) {
                return this._isShown ? this.hide() : this.show(e)
            }, o.show = function (e) {
                var t = this;
                if (!this._isShown && !this._isTransitioning) {
                    this._element.classList.contains("fade") && (this._isTransitioning = !0);
                    var i = B.trigger(this._element, "show.bs.modal", {
                        relatedTarget: e
                    });
                    this._isShown || i.defaultPrevented || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), B.on(this._element, "click.dismiss.bs.modal", '[data-bs-dismiss="modal"]', (function (e) {
                        return t.hide(e)
                    })), B.on(this._dialog, "mousedown.dismiss.bs.modal", (function () {
                        B.one(t._element, "mouseup.dismiss.bs.modal", (function (e) {
                            e.target === t._element && (t._ignoreBackdropClick = !0)
                        }))
                    })), this._showBackdrop((function () {
                        return t._showElement(e)
                    })))
                }
            }, o.hide = function (e) {
                var t = this;
                if (e && e.preventDefault(), this._isShown && !this._isTransitioning && !B.trigger(this._element, "hide.bs.modal").defaultPrevented) {
                    this._isShown = !1;
                    var i = this._element.classList.contains("fade");
                    if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), B.off(document, "focusin.bs.modal"), this._element.classList.remove("show"), B.off(this._element, "click.dismiss.bs.modal"), B.off(this._dialog, "mousedown.dismiss.bs.modal"), i) {
                        var n = u(this._element);
                        B.one(this._element, "transitionend", (function (e) {
                            return t._hideModal(e)
                        })), p(this._element, n)
                    } else this._hideModal()
                }
            }, o.dispose = function () {
                [window, this._element, this._dialog].forEach((function (e) {
                    return B.off(e, ".bs.modal")
                })), e.prototype.dispose.call(this), B.off(document, "focusin.bs.modal"), this._config = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null
            }, o.handleUpdate = function () {
                this._adjustDialog()
            }, o._getConfig = function (e) {
                return e = i({}, bt, e), f("modal", e, xt), e
            }, o._showElement = function (e) {
                var t = this,
                    i = this._element.classList.contains("fade"),
                    n = W.findOne(".modal-body", this._dialog);
                this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, n && (n.scrollTop = 0), i && v(this._element), this._element.classList.add("show"), this._config.focus && this._enforceFocus();
                var r = function () {
                    t._config.focus && t._element.focus(), t._isTransitioning = !1, B.trigger(t._element, "shown.bs.modal", {
                        relatedTarget: e
                    })
                };
                if (i) {
                    var o = u(this._dialog);
                    B.one(this._dialog, "transitionend", r), p(this._dialog, o)
                } else r()
            }, o._enforceFocus = function () {
                var e = this;
                B.off(document, "focusin.bs.modal"), B.on(document, "focusin.bs.modal", (function (t) {
                    document === t.target || e._element === t.target || e._element.contains(t.target) || e._element.focus()
                }))
            }, o._setEscapeEvent = function () {
                var e = this;
                this._isShown ? B.on(this._element, "keydown.dismiss.bs.modal", (function (t) {
                    e._config.keyboard && "Escape" === t.key ? (t.preventDefault(), e.hide()) : e._config.keyboard || "Escape" !== t.key || e._triggerBackdropTransition()
                })) : B.off(this._element, "keydown.dismiss.bs.modal")
            }, o._setResizeEvent = function () {
                var e = this;
                this._isShown ? B.on(window, "resize.bs.modal", (function () {
                    return e._adjustDialog()
                })) : B.off(window, "resize.bs.modal")
            }, o._hideModal = function () {
                var e = this;
                this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._showBackdrop((function () {
                    document.body.classList.remove("modal-open"), e._resetAdjustments(), e._resetScrollbar(), B.trigger(e._element, "hidden.bs.modal")
                }))
            }, o._removeBackdrop = function () {
                this._backdrop.parentNode.removeChild(this._backdrop), this._backdrop = null
            }, o._showBackdrop = function (e) {
                var t = this,
                    i = this._element.classList.contains("fade") ? "fade" : "";
                if (this._isShown && this._config.backdrop) {
                    if (this._backdrop = document.createElement("div"), this._backdrop.className = "modal-backdrop", i && this._backdrop.classList.add(i), document.body.appendChild(this._backdrop), B.on(this._element, "click.dismiss.bs.modal", (function (e) {
                            t._ignoreBackdropClick ? t._ignoreBackdropClick = !1 : e.target === e.currentTarget && ("static" === t._config.backdrop ? t._triggerBackdropTransition() : t.hide())
                        })), i && v(this._backdrop), this._backdrop.classList.add("show"), !i) return void e();
                    var n = u(this._backdrop);
                    B.one(this._backdrop, "transitionend", e), p(this._backdrop, n)
                } else if (!this._isShown && this._backdrop) {
                    this._backdrop.classList.remove("show");
                    var r = function () {
                        t._removeBackdrop(), e()
                    };
                    if (this._element.classList.contains("fade")) {
                        var o = u(this._backdrop);
                        B.one(this._backdrop, "transitionend", r), p(this._backdrop, o)
                    } else r()
                } else e()
            }, o._triggerBackdropTransition = function () {
                var e = this;
                if (!B.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) {
                    var t = this._element.scrollHeight > document.documentElement.clientHeight;
                    t || (this._element.style.overflowY = "hidden"), this._element.classList.add("modal-static");
                    var i = u(this._dialog);
                    B.off(this._element, "transitionend"), B.one(this._element, "transitionend", (function () {
                        e._element.classList.remove("modal-static"), t || (B.one(e._element, "transitionend", (function () {
                            e._element.style.overflowY = ""
                        })), p(e._element, i))
                    })), p(this._element, i), this._element.focus()
                }
            }, o._adjustDialog = function () {
                var e = this._element.scrollHeight > document.documentElement.clientHeight;
                (!this._isBodyOverflowing && e && !x || this._isBodyOverflowing && !e && x) && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), (this._isBodyOverflowing && !e && !x || !this._isBodyOverflowing && e && x) && (this._element.style.paddingRight = this._scrollbarWidth + "px")
            }, o._resetAdjustments = function () {
                this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
            }, o._checkScrollbar = function () {
                var e = document.body.getBoundingClientRect();
                this._isBodyOverflowing = Math.round(e.left + e.right) < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth()
            }, o._setScrollbar = function () {
                var e = this;
                if (this._isBodyOverflowing) {
                    W.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function (t) {
                        var i = t.style.paddingRight,
                            n = window.getComputedStyle(t)["padding-right"];
                        V.setDataAttribute(t, "padding-right", i), t.style.paddingRight = Number.parseFloat(n) + e._scrollbarWidth + "px"
                    })), W.find(".sticky-top").forEach((function (t) {
                        var i = t.style.marginRight,
                            n = window.getComputedStyle(t)["margin-right"];
                        V.setDataAttribute(t, "margin-right", i), t.style.marginRight = Number.parseFloat(n) - e._scrollbarWidth + "px"
                    }));
                    var t = document.body.style.paddingRight,
                        i = window.getComputedStyle(document.body)["padding-right"];
                    V.setDataAttribute(document.body, "padding-right", t), document.body.style.paddingRight = Number.parseFloat(i) + this._scrollbarWidth + "px"
                }
                document.body.classList.add("modal-open")
            }, o._resetScrollbar = function () {
                W.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function (e) {
                    var t = V.getDataAttribute(e, "padding-right");
                    void 0 !== t && (V.removeDataAttribute(e, "padding-right"), e.style.paddingRight = t)
                })), W.find(".sticky-top").forEach((function (e) {
                    var t = V.getDataAttribute(e, "margin-right");
                    void 0 !== t && (V.removeDataAttribute(e, "margin-right"), e.style.marginRight = t)
                }));
                var e = V.getDataAttribute(document.body, "padding-right");
                void 0 === e ? document.body.style.paddingRight = "" : (V.removeDataAttribute(document.body, "padding-right"), document.body.style.paddingRight = e)
            }, o._getScrollbarWidth = function () {
                var e = document.createElement("div");
                e.className = "modal-scrollbar-measure", document.body.appendChild(e);
                var t = e.getBoundingClientRect().width - e.clientWidth;
                return document.body.removeChild(e), t
            }, r.jQueryInterface = function (e, t) {
                return this.each((function () {
                    var n = E(this, "bs.modal"),
                        o = i({}, bt, V.getDataAttributes(this), "object" == typeof e && e ? e : {});
                    if (n || (n = new r(this, o)), "string" == typeof e) {
                        if (void 0 === n[e]) throw new TypeError('No method named "' + e + '"');
                        n[e](t)
                    }
                }))
            }, t(r, null, [{
                key: "Default",
                get: function () {
                    return bt
                }
            }, {
                key: "DATA_KEY",
                get: function () {
                    return "bs.modal"
                }
            }]), r
        }(N);
    B.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', (function (e) {
        var t = this,
            n = c(this);
        "A" !== this.tagName && "AREA" !== this.tagName || e.preventDefault(), B.one(n, "show.bs.modal", (function (e) {
            e.defaultPrevented || B.one(n, "hidden.bs.modal", (function () {
                m(t) && t.focus()
            }))
        }));
        var r = E(n, "bs.modal");
        if (!r) {
            var o = i({}, V.getDataAttributes(n), V.getDataAttributes(this));
            r = new wt(n, o)
        }
        r.show(this)
    })), b((function () {
        var e = y();
        if (e) {
            var t = e.fn.modal;
            e.fn.modal = wt.jQueryInterface, e.fn.modal.Constructor = wt, e.fn.modal.noConflict = function () {
                return e.fn.modal = t, wt.jQueryInterface
            }
        }
    }));
    var _t = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
        Et = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi,
        Mt = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

    function St(e, t, i) {
        var n;
        if (!e.length) return e;
        if (i && "function" == typeof i) return i(e);
        for (var r = (new window.DOMParser).parseFromString(e, "text/html"), o = Object.keys(t), s = (n = []).concat.apply(n, r.body.querySelectorAll("*")), a = function (e, i) {
                var n, r = s[e],
                    a = r.nodeName.toLowerCase();
                if (!o.includes(a)) return r.parentNode.removeChild(r), "continue";
                var l = (n = []).concat.apply(n, r.attributes),
                    c = [].concat(t["*"] || [], t[a] || []);
                l.forEach((function (e) {
                    (function (e, t) {
                        var i = e.nodeName.toLowerCase();
                        if (t.includes(i)) return !_t.has(i) || Boolean(e.nodeValue.match(Et) || e.nodeValue.match(Mt));
                        for (var n = t.filter((function (e) {
                                return e instanceof RegExp
                            })), r = 0, o = n.length; r < o; r++)
                            if (i.match(n[r])) return !0;
                        return !1
                    })(e, c) || r.removeAttribute(e.nodeName)
                }))
            }, l = 0, c = s.length; l < c; l++) a(l);
        return r.body.innerHTML
    }
    var Tt = "tooltip",
        At = new RegExp("(^|\\s)bs-tooltip\\S+", "g"),
        Ct = new Set(["sanitize", "allowList", "sanitizeFn"]),
        Lt = {
            animation: "boolean",
            template: "string",
            title: "(string|element|function)",
            trigger: "string",
            delay: "(number|object)",
            html: "boolean",
            selector: "(string|boolean)",
            placement: "(string|function)",
            container: "(string|element|boolean)",
            fallbackPlacements: "(null|array)",
            boundary: "(string|element)",
            customClass: "(string|function)",
            sanitize: "boolean",
            sanitizeFn: "(null|function)",
            allowList: "object",
            popperConfig: "(null|object)"
        },
        Pt = {
            AUTO: "auto",
            TOP: "top",
            RIGHT: x ? "left" : "right",
            BOTTOM: "bottom",
            LEFT: x ? "right" : "left"
        },
        It = {
            animation: !0,
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: "hover focus",
            title: "",
            delay: 0,
            html: !1,
            selector: !1,
            placement: "top",
            container: !1,
            fallbackPlacements: null,
            boundary: "clippingParents",
            customClass: "",
            sanitize: !0,
            sanitizeFn: null,
            allowList: {
                "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
                a: ["target", "href", "title", "rel"],
                area: [],
                b: [],
                br: [],
                col: [],
                code: [],
                div: [],
                em: [],
                hr: [],
                h1: [],
                h2: [],
                h3: [],
                h4: [],
                h5: [],
                h6: [],
                i: [],
                img: ["src", "srcset", "alt", "title", "width", "height"],
                li: [],
                ol: [],
                p: [],
                pre: [],
                s: [],
                small: [],
                span: [],
                sub: [],
                sup: [],
                strong: [],
                u: [],
                ul: []
            },
            popperConfig: null
        },
        Ot = {
            HIDE: "hide.bs.tooltip",
            HIDDEN: "hidden.bs.tooltip",
            SHOW: "show.bs.tooltip",
            SHOWN: "shown.bs.tooltip",
            INSERTED: "inserted.bs.tooltip",
            CLICK: "click.bs.tooltip",
            FOCUSIN: "focusin.bs.tooltip",
            FOCUSOUT: "focusout.bs.tooltip",
            MOUSEENTER: "mouseenter.bs.tooltip",
            MOUSELEAVE: "mouseleave.bs.tooltip"
        },
        Rt = function (e) {
            function r(t, i) {
                var n;
                if (void 0 === at) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
                return (n = e.call(this, t) || this)._isEnabled = !0, n._timeout = 0, n._hoverState = "", n._activeTrigger = {}, n._popper = null, n.config = n._getConfig(i), n.tip = null, n._setListeners(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.enable = function () {
                this._isEnabled = !0
            }, o.disable = function () {
                this._isEnabled = !1
            }, o.toggleEnabled = function () {
                this._isEnabled = !this._isEnabled
            }, o.toggle = function (e) {
                if (this._isEnabled)
                    if (e) {
                        var t = this.constructor.DATA_KEY,
                            i = E(e.delegateTarget, t);
                        i || (i = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, t, i)), i._activeTrigger.click = !i._activeTrigger.click, i._isWithActiveTrigger() ? i._enter(null, i) : i._leave(null, i)
                    } else {
                        if (this.getTipElement().classList.contains("show")) return void this._leave(null, this);
                        this._enter(null, this)
                    }
            }, o.dispose = function () {
                clearTimeout(this._timeout), B.off(this._element, this.constructor.EVENT_KEY), B.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.tip && this.tip.parentNode.removeChild(this.tip), this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, this._popper && this._popper.destroy(), this._popper = null, this.config = null, this.tip = null, e.prototype.dispose.call(this)
            }, o.show = function () {
                var e = this;
                if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
                if (this.isWithContent() && this._isEnabled) {
                    var t = B.trigger(this._element, this.constructor.Event.SHOW),
                        i = function e(t) {
                            if (!document.documentElement.attachShadow) return null;
                            if ("function" == typeof t.getRootNode) {
                                var i = t.getRootNode();
                                return i instanceof ShadowRoot ? i : null
                            }
                            return t instanceof ShadowRoot ? t : t.parentNode ? e(t.parentNode) : null
                        }(this._element),
                        n = null === i ? this._element.ownerDocument.documentElement.contains(this._element) : i.contains(this._element);
                    if (t.defaultPrevented || !n) return;
                    var r = this.getTipElement(),
                        o = s(this.constructor.NAME);
                    r.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this.setContent(), this.config.animation && r.classList.add("fade");
                    var a = "function" == typeof this.config.placement ? this.config.placement.call(this, r, this._element) : this.config.placement,
                        l = this._getAttachment(a);
                    this._addAttachmentClass(l);
                    var c = this._getContainer();
                    _(r, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || c.appendChild(r), B.trigger(this._element, this.constructor.Event.INSERTED), this._popper = st(this._element, r, this._getPopperConfig(l)), r.classList.add("show");
                    var h, d, f = "function" == typeof this.config.customClass ? this.config.customClass() : this.config.customClass;
                    f && (h = r.classList).add.apply(h, f.split(" ")), "ontouchstart" in document.documentElement && (d = []).concat.apply(d, document.body.children).forEach((function (e) {
                        B.on(e, "mouseover", (function () {}))
                    }));
                    var m = function () {
                        var t = e._hoverState;
                        e._hoverState = null, B.trigger(e._element, e.constructor.Event.SHOWN), "out" === t && e._leave(null, e)
                    };
                    if (this.tip.classList.contains("fade")) {
                        var g = u(this.tip);
                        B.one(this.tip, "transitionend", m), p(this.tip, g)
                    } else m()
                }
            }, o.hide = function () {
                var e = this;
                if (this._popper) {
                    var t = this.getTipElement(),
                        i = function () {
                            "show" !== e._hoverState && t.parentNode && t.parentNode.removeChild(t), e._cleanTipClass(), e._element.removeAttribute("aria-describedby"), B.trigger(e._element, e.constructor.Event.HIDDEN), e._popper && (e._popper.destroy(), e._popper = null)
                        };
                    if (!B.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) {
                        var n;
                        if (t.classList.remove("show"), "ontouchstart" in document.documentElement && (n = []).concat.apply(n, document.body.children).forEach((function (e) {
                                return B.off(e, "mouseover", g)
                            })), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, this.tip.classList.contains("fade")) {
                            var r = u(t);
                            B.one(t, "transitionend", i), p(t, r)
                        } else i();
                        this._hoverState = ""
                    }
                }
            }, o.update = function () {
                null !== this._popper && this._popper.update()
            }, o.isWithContent = function () {
                return Boolean(this.getTitle())
            }, o.getTipElement = function () {
                if (this.tip) return this.tip;
                var e = document.createElement("div");
                return e.innerHTML = this.config.template, this.tip = e.children[0], this.tip
            }, o.setContent = function () {
                var e = this.getTipElement();
                this.setElementContent(W.findOne(".tooltip-inner", e), this.getTitle()), e.classList.remove("fade", "show")
            }, o.setElementContent = function (e, t) {
                if (null !== e) return "object" == typeof t && d(t) ? (t.jquery && (t = t[0]), void(this.config.html ? t.parentNode !== e && (e.innerHTML = "", e.appendChild(t)) : e.textContent = t.textContent)) : void(this.config.html ? (this.config.sanitize && (t = St(t, this.config.allowList, this.config.sanitizeFn)), e.innerHTML = t) : e.textContent = t)
            }, o.getTitle = function () {
                var e = this._element.getAttribute("data-bs-original-title");
                return e || (e = "function" == typeof this.config.title ? this.config.title.call(this._element) : this.config.title), e
            }, o.updateAttachment = function (e) {
                return "right" === e ? "end" : "left" === e ? "start" : e
            }, o._getPopperConfig = function (e) {
                var t = this,
                    n = {
                        name: "flip",
                        options: {
                            altBoundary: !0
                        }
                    };
                return this.config.fallbackPlacements && (n.options.fallbackPlacements = this.config.fallbackPlacements), i({}, {
                    placement: e,
                    modifiers: [n, {
                        name: "preventOverflow",
                        options: {
                            rootBoundary: this.config.boundary
                        }
                    }, {
                        name: "arrow",
                        options: {
                            element: "." + this.constructor.NAME + "-arrow"
                        }
                    }, {
                        name: "onChange",
                        enabled: !0,
                        phase: "afterWrite",
                        fn: function (e) {
                            return t._handlePopperPlacementChange(e)
                        }
                    }],
                    onFirstUpdate: function (e) {
                        e.options.placement !== e.placement && t._handlePopperPlacementChange(e)
                    }
                }, this.config.popperConfig)
            }, o._addAttachmentClass = function (e) {
                this.getTipElement().classList.add("bs-tooltip-" + this.updateAttachment(e))
            }, o._getContainer = function () {
                return !1 === this.config.container ? document.body : d(this.config.container) ? this.config.container : W.findOne(this.config.container)
            }, o._getAttachment = function (e) {
                return Pt[e.toUpperCase()]
            }, o._setListeners = function () {
                var e = this;
                this.config.trigger.split(" ").forEach((function (t) {
                    if ("click" === t) B.on(e._element, e.constructor.Event.CLICK, e.config.selector, (function (t) {
                        return e.toggle(t)
                    }));
                    else if ("manual" !== t) {
                        var i = "hover" === t ? e.constructor.Event.MOUSEENTER : e.constructor.Event.FOCUSIN,
                            n = "hover" === t ? e.constructor.Event.MOUSELEAVE : e.constructor.Event.FOCUSOUT;
                        B.on(e._element, i, e.config.selector, (function (t) {
                            return e._enter(t)
                        })), B.on(e._element, n, e.config.selector, (function (t) {
                            return e._leave(t)
                        }))
                    }
                })), this._hideModalHandler = function () {
                    e._element && e.hide()
                }, B.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.config.selector ? this.config = i({}, this.config, {
                    trigger: "manual",
                    selector: ""
                }) : this._fixTitle()
            }, o._fixTitle = function () {
                var e = this._element.getAttribute("title"),
                    t = typeof this._element.getAttribute("data-bs-original-title");
                (e || "string" !== t) && (this._element.setAttribute("data-bs-original-title", e || ""), !e || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", e), this._element.setAttribute("title", ""))
            }, o._enter = function (e, t) {
                var i = this.constructor.DATA_KEY;
                (t = t || E(e.delegateTarget, i)) || (t = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, i, t)), e && (t._activeTrigger["focusin" === e.type ? "focus" : "hover"] = !0), t.getTipElement().classList.contains("show") || "show" === t._hoverState ? t._hoverState = "show" : (clearTimeout(t._timeout), t._hoverState = "show", t.config.delay && t.config.delay.show ? t._timeout = setTimeout((function () {
                    "show" === t._hoverState && t.show()
                }), t.config.delay.show) : t.show())
            }, o._leave = function (e, t) {
                var i = this.constructor.DATA_KEY;
                (t = t || E(e.delegateTarget, i)) || (t = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, i, t)), e && (t._activeTrigger["focusout" === e.type ? "focus" : "hover"] = !1), t._isWithActiveTrigger() || (clearTimeout(t._timeout), t._hoverState = "out", t.config.delay && t.config.delay.hide ? t._timeout = setTimeout((function () {
                    "out" === t._hoverState && t.hide()
                }), t.config.delay.hide) : t.hide())
            }, o._isWithActiveTrigger = function () {
                for (var e in this._activeTrigger)
                    if (this._activeTrigger[e]) return !0;
                return !1
            }, o._getConfig = function (e) {
                var t = V.getDataAttributes(this._element);
                return Object.keys(t).forEach((function (e) {
                    Ct.has(e) && delete t[e]
                })), e && "object" == typeof e.container && e.container.jquery && (e.container = e.container[0]), "number" == typeof (e = i({}, this.constructor.Default, t, "object" == typeof e && e ? e : {})).delay && (e.delay = {
                    show: e.delay,
                    hide: e.delay
                }), "number" == typeof e.title && (e.title = e.title.toString()), "number" == typeof e.content && (e.content = e.content.toString()), f(Tt, e, this.constructor.DefaultType), e.sanitize && (e.template = St(e.template, e.allowList, e.sanitizeFn)), e
            }, o._getDelegateConfig = function () {
                var e = {};
                if (this.config)
                    for (var t in this.config) this.constructor.Default[t] !== this.config[t] && (e[t] = this.config[t]);
                return e
            }, o._cleanTipClass = function () {
                var e = this.getTipElement(),
                    t = e.getAttribute("class").match(At);
                null !== t && t.length > 0 && t.map((function (e) {
                    return e.trim()
                })).forEach((function (t) {
                    return e.classList.remove(t)
                }))
            }, o._handlePopperPlacementChange = function (e) {
                var t = e.state;
                t && (this.tip = t.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(t.placement)))
            }, r.jQueryInterface = function (e) {
                return this.each((function () {
                    var t = E(this, "bs.tooltip"),
                        i = "object" == typeof e && e;
                    if ((t || !/dispose|hide/.test(e)) && (t || (t = new r(this, i)), "string" == typeof e)) {
                        if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
                        t[e]()
                    }
                }))
            }, t(r, null, [{
                key: "Default",
                get: function () {
                    return It
                }
            }, {
                key: "NAME",
                get: function () {
                    return Tt
                }
            }, {
                key: "DATA_KEY",
                get: function () {
                    return "bs.tooltip"
                }
            }, {
                key: "Event",
                get: function () {
                    return Ot
                }
            }, {
                key: "EVENT_KEY",
                get: function () {
                    return ".bs.tooltip"
                }
            }, {
                key: "DefaultType",
                get: function () {
                    return Lt
                }
            }]), r
        }(N);
    b((function () {
        var e = y();
        if (e) {
            var t = e.fn[Tt];
            e.fn[Tt] = Rt.jQueryInterface, e.fn[Tt].Constructor = Rt, e.fn[Tt].noConflict = function () {
                return e.fn[Tt] = t, Rt.jQueryInterface
            }
        }
    }));
    var Dt = "popover",
        kt = new RegExp("(^|\\s)bs-popover\\S+", "g"),
        zt = i({}, Rt.Default, {
            placement: "right",
            trigger: "click",
            content: "",
            template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
        }),
        Bt = i({}, Rt.DefaultType, {
            content: "(string|element|function)"
        }),
        Nt = {
            HIDE: "hide.bs.popover",
            HIDDEN: "hidden.bs.popover",
            SHOW: "show.bs.popover",
            SHOWN: "shown.bs.popover",
            INSERTED: "inserted.bs.popover",
            CLICK: "click.bs.popover",
            FOCUSIN: "focusin.bs.popover",
            FOCUSOUT: "focusout.bs.popover",
            MOUSEENTER: "mouseenter.bs.popover",
            MOUSELEAVE: "mouseleave.bs.popover"
        },
        Ft = function (e) {
            function i() {
                return e.apply(this, arguments) || this
            }
            n(i, e);
            var r = i.prototype;
            return r.isWithContent = function () {
                return this.getTitle() || this._getContent()
            }, r.setContent = function () {
                var e = this.getTipElement();
                this.setElementContent(W.findOne(".popover-header", e), this.getTitle());
                var t = this._getContent();
                "function" == typeof t && (t = t.call(this._element)), this.setElementContent(W.findOne(".popover-body", e), t), e.classList.remove("fade", "show")
            }, r._addAttachmentClass = function (e) {
                this.getTipElement().classList.add("bs-popover-" + this.updateAttachment(e))
            }, r._getContent = function () {
                return this._element.getAttribute("data-bs-content") || this.config.content
            }, r._cleanTipClass = function () {
                var e = this.getTipElement(),
                    t = e.getAttribute("class").match(kt);
                null !== t && t.length > 0 && t.map((function (e) {
                    return e.trim()
                })).forEach((function (t) {
                    return e.classList.remove(t)
                }))
            }, i.jQueryInterface = function (e) {
                return this.each((function () {
                    var t = E(this, "bs.popover"),
                        n = "object" == typeof e ? e : null;
                    if ((t || !/dispose|hide/.test(e)) && (t || (t = new i(this, n), _(this, "bs.popover", t)), "string" == typeof e)) {
                        if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
                        t[e]()
                    }
                }))
            }, t(i, null, [{
                key: "Default",
                get: function () {
                    return zt
                }
            }, {
                key: "NAME",
                get: function () {
                    return Dt
                }
            }, {
                key: "DATA_KEY",
                get: function () {
                    return "bs.popover"
                }
            }, {
                key: "Event",
                get: function () {
                    return Nt
                }
            }, {
                key: "EVENT_KEY",
                get: function () {
                    return ".bs.popover"
                }
            }, {
                key: "DefaultType",
                get: function () {
                    return Bt
                }
            }]), i
        }(Rt);
    b((function () {
        var e = y();
        if (e) {
            var t = e.fn[Dt];
            e.fn[Dt] = Ft.jQueryInterface, e.fn[Dt].Constructor = Ft, e.fn[Dt].noConflict = function () {
                return e.fn[Dt] = t, Ft.jQueryInterface
            }
        }
    }));
    var Ht = "scrollspy",
        Ut = {
            offset: 10,
            method: "auto",
            target: ""
        },
        jt = {
            offset: "number",
            method: "string",
            target: "(string|element)"
        },
        Gt = function (e) {
            function r(t, i) {
                var n;
                return (n = e.call(this, t) || this)._scrollElement = "BODY" === t.tagName ? window : t, n._config = n._getConfig(i), n._selector = n._config.target + " .nav-link, " + n._config.target + " .list-group-item, " + n._config.target + " .dropdown-item", n._offsets = [], n._targets = [], n._activeTarget = null, n._scrollHeight = 0, B.on(n._scrollElement, "scroll.bs.scrollspy", (function (e) {
                    return n._process(e)
                })), n.refresh(), n._process(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.refresh = function () {
                var e = this,
                    t = this._scrollElement === this._scrollElement.window ? "offset" : "position",
                    i = "auto" === this._config.method ? t : this._config.method,
                    n = "position" === i ? this._getScrollTop() : 0;
                this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), W.find(this._selector).map((function (e) {
                    var t = l(e),
                        r = t ? W.findOne(t) : null;
                    if (r) {
                        var o = r.getBoundingClientRect();
                        if (o.width || o.height) return [V[i](r).top + n, t]
                    }
                    return null
                })).filter((function (e) {
                    return e
                })).sort((function (e, t) {
                    return e[0] - t[0]
                })).forEach((function (t) {
                    e._offsets.push(t[0]), e._targets.push(t[1])
                }))
            }, o.dispose = function () {
                e.prototype.dispose.call(this), B.off(this._scrollElement, ".bs.scrollspy"), this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null
            }, o._getConfig = function (e) {
                if ("string" != typeof (e = i({}, Ut, "object" == typeof e && e ? e : {})).target && d(e.target)) {
                    var t = e.target.id;
                    t || (t = s(Ht), e.target.id = t), e.target = "#" + t
                }
                return f(Ht, e, jt), e
            }, o._getScrollTop = function () {
                return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
            }, o._getScrollHeight = function () {
                return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
            }, o._getOffsetHeight = function () {
                return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
            }, o._process = function () {
                var e = this._getScrollTop() + this._config.offset,
                    t = this._getScrollHeight(),
                    i = this._config.offset + t - this._getOffsetHeight();
                if (this._scrollHeight !== t && this.refresh(), e >= i) {
                    var n = this._targets[this._targets.length - 1];
                    this._activeTarget !== n && this._activate(n)
                } else {
                    if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();
                    for (var r = this._offsets.length; r--;) this._activeTarget !== this._targets[r] && e >= this._offsets[r] && (void 0 === this._offsets[r + 1] || e < this._offsets[r + 1]) && this._activate(this._targets[r])
                }
            }, o._activate = function (e) {
                this._activeTarget = e, this._clear();
                var t = this._selector.split(",").map((function (t) {
                        return t + '[data-bs-target="' + e + '"],' + t + '[href="' + e + '"]'
                    })),
                    i = W.findOne(t.join(","));
                i.classList.contains("dropdown-item") ? (W.findOne(".dropdown-toggle", i.closest(".dropdown")).classList.add("active"), i.classList.add("active")) : (i.classList.add("active"), W.parents(i, ".nav, .list-group").forEach((function (e) {
                    W.prev(e, ".nav-link, .list-group-item").forEach((function (e) {
                        return e.classList.add("active")
                    })), W.prev(e, ".nav-item").forEach((function (e) {
                        W.children(e, ".nav-link").forEach((function (e) {
                            return e.classList.add("active")
                        }))
                    }))
                }))), B.trigger(this._scrollElement, "activate.bs.scrollspy", {
                    relatedTarget: e
                })
            }, o._clear = function () {
                W.find(this._selector).filter((function (e) {
                    return e.classList.contains("active")
                })).forEach((function (e) {
                    return e.classList.remove("active")
                }))
            }, r.jQueryInterface = function (e) {
                return this.each((function () {
                    var t = E(this, "bs.scrollspy");
                    if (t || (t = new r(this, "object" == typeof e && e)), "string" == typeof e) {
                        if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
                        t[e]()
                    }
                }))
            }, t(r, null, [{
                key: "Default",
                get: function () {
                    return Ut
                }
            }, {
                key: "DATA_KEY",
                get: function () {
                    return "bs.scrollspy"
                }
            }]), r
        }(N);
    B.on(window, "load.bs.scrollspy.data-api", (function () {
        W.find('[data-bs-spy="scroll"]').forEach((function (e) {
            return new Gt(e, V.getDataAttributes(e))
        }))
    })), b((function () {
        var e = y();
        if (e) {
            var t = e.fn[Ht];
            e.fn[Ht] = Gt.jQueryInterface, e.fn[Ht].Constructor = Gt, e.fn[Ht].noConflict = function () {
                return e.fn[Ht] = t, Gt.jQueryInterface
            }
        }
    }));
    var Vt = function (e) {
        function i() {
            return e.apply(this, arguments) || this
        }
        n(i, e);
        var r = i.prototype;
        return r.show = function () {
            var e = this;
            if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains("active") || this._element.classList.contains("disabled"))) {
                var t, i = c(this._element),
                    n = this._element.closest(".nav, .list-group");
                if (n) {
                    var r = "UL" === n.nodeName || "OL" === n.nodeName ? ":scope > li > .active" : ".active";
                    t = (t = W.find(r, n))[t.length - 1]
                }
                var o = null;
                if (t && (o = B.trigger(t, "hide.bs.tab", {
                        relatedTarget: this._element
                    })), !(B.trigger(this._element, "show.bs.tab", {
                        relatedTarget: t
                    }).defaultPrevented || null !== o && o.defaultPrevented)) {
                    this._activate(this._element, n);
                    var s = function () {
                        B.trigger(t, "hidden.bs.tab", {
                            relatedTarget: e._element
                        }), B.trigger(e._element, "shown.bs.tab", {
                            relatedTarget: t
                        })
                    };
                    i ? this._activate(i, i.parentNode, s) : s()
                }
            }
        }, r._activate = function (e, t, i) {
            var n = this,
                r = (!t || "UL" !== t.nodeName && "OL" !== t.nodeName ? W.children(t, ".active") : W.find(":scope > li > .active", t))[0],
                o = i && r && r.classList.contains("fade"),
                s = function () {
                    return n._transitionComplete(e, r, i)
                };
            if (r && o) {
                var a = u(r);
                r.classList.remove("show"), B.one(r, "transitionend", s), p(r, a)
            } else s()
        }, r._transitionComplete = function (e, t, i) {
            if (t) {
                t.classList.remove("active");
                var n = W.findOne(":scope > .dropdown-menu .active", t.parentNode);
                n && n.classList.remove("active"), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !1)
            }
            e.classList.add("active"), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !0), v(e), e.classList.contains("fade") && e.classList.add("show"), e.parentNode && e.parentNode.classList.contains("dropdown-menu") && (e.closest(".dropdown") && W.find(".dropdown-toggle").forEach((function (e) {
                return e.classList.add("active")
            })), e.setAttribute("aria-expanded", !0)), i && i()
        }, i.jQueryInterface = function (e) {
            return this.each((function () {
                var t = E(this, "bs.tab") || new i(this);
                if ("string" == typeof e) {
                    if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
                    t[e]()
                }
            }))
        }, t(i, null, [{
            key: "DATA_KEY",
            get: function () {
                return "bs.tab"
            }
        }]), i
    }(N);
    B.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', (function (e) {
        e.preventDefault(), (E(this, "bs.tab") || new Vt(this)).show()
    })), b((function () {
        var e = y();
        if (e) {
            var t = e.fn.tab;
            e.fn.tab = Vt.jQueryInterface, e.fn.tab.Constructor = Vt, e.fn.tab.noConflict = function () {
                return e.fn.tab = t, Vt.jQueryInterface
            }
        }
    }));
    var Wt = {
            animation: "boolean",
            autohide: "boolean",
            delay: "number"
        },
        qt = {
            animation: !0,
            autohide: !0,
            delay: 5e3
        },
        Xt = function (e) {
            function r(t, i) {
                var n;
                return (n = e.call(this, t) || this)._config = n._getConfig(i), n._timeout = null, n._setListeners(), n
            }
            n(r, e);
            var o = r.prototype;
            return o.show = function () {
                var e = this;
                if (!B.trigger(this._element, "show.bs.toast").defaultPrevented) {
                    this._clearTimeout(), this._config.animation && this._element.classList.add("fade");
                    var t = function () {
                        e._element.classList.remove("showing"), e._element.classList.add("show"), B.trigger(e._element, "shown.bs.toast"), e._config.autohide && (e._timeout = setTimeout((function () {
                            e.hide()
                        }), e._config.delay))
                    };
                    if (this._element.classList.remove("hide"), v(this._element), this._element.classList.add("showing"), this._config.animation) {
                        var i = u(this._element);
                        B.one(this._element, "transitionend", t), p(this._element, i)
                    } else t()
                }
            }, o.hide = function () {
                var e = this;
                if (this._element.classList.contains("show") && !B.trigger(this._element, "hide.bs.toast").defaultPrevented) {
                    var t = function () {
                        e._element.classList.add("hide"), B.trigger(e._element, "hidden.bs.toast")
                    };
                    if (this._element.classList.remove("show"), this._config.animation) {
                        var i = u(this._element);
                        B.one(this._element, "transitionend", t), p(this._element, i)
                    } else t()
                }
            }, o.dispose = function () {
                this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), B.off(this._element, "click.dismiss.bs.toast"), e.prototype.dispose.call(this), this._config = null
            }, o._getConfig = function (e) {
                return e = i({}, qt, V.getDataAttributes(this._element), "object" == typeof e && e ? e : {}), f("toast", e, this.constructor.DefaultType), e
            }, o._setListeners = function () {
                var e = this;
                B.on(this._element, "click.dismiss.bs.toast", '[data-bs-dismiss="toast"]', (function () {
                    return e.hide()
                }))
            }, o._clearTimeout = function () {
                clearTimeout(this._timeout), this._timeout = null
            }, r.jQueryInterface = function (e) {
                return this.each((function () {
                    var t = E(this, "bs.toast");
                    if (t || (t = new r(this, "object" == typeof e && e)), "string" == typeof e) {
                        if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
                        t[e](this)
                    }
                }))
            }, t(r, null, [{
                key: "DefaultType",
                get: function () {
                    return Wt
                }
            }, {
                key: "Default",
                get: function () {
                    return qt
                }
            }, {
                key: "DATA_KEY",
                get: function () {
                    return "bs.toast"
                }
            }]), r
        }(N);
    return b((function () {
        var e = y();
        if (e) {
            var t = e.fn.toast;
            e.fn.toast = Xt.jQueryInterface, e.fn.toast.Constructor = Xt, e.fn.toast.noConflict = function () {
                return e.fn.toast = t, Xt.jQueryInterface
            }
        }
    })), {
        Alert: H,
        Button: U,
        Carousel: Q,
        Collapse: ee,
        Dropdown: yt,
        Modal: wt,
        Popover: Ft,
        ScrollSpy: Gt,
        Tab: Vt,
        Toast: Xt,
        Tooltip: Rt
    }
})),
function (e) {
    if ("function" == typeof define && define.amd) define(["jquery"], e);
    else if ("object" == typeof module && module.exports) {
        var t = require("jquery");
        e(t), module.exports = t
    } else e(jQuery)
}((function (e) {
    function t(e) {
        this.init(e)
    }
    t.prototype = {
        value: 0,
        size: 100,
        startAngle: -Math.PI,
        thickness: "auto",
        fill: {
            gradient: ["#3aeabb", "#fdd250"]
        },
        emptyFill: "rgba(0, 0, 0, .1)",
        animation: {
            duration: 1200,
            easing: "circleProgressEasing"
        },
        animationStartValue: 0,
        reverse: !1,
        lineCap: "butt",
        insertMode: "prepend",
        constructor: t,
        el: null,
        canvas: null,
        ctx: null,
        radius: 0,
        arcFill: null,
        lastFrameValue: 0,
        init: function (t) {
            e.extend(this, t), this.radius = this.size / 2, this.initWidget(), this.initFill(), this.draw(), this.el.trigger("circle-inited")
        },
        initWidget: function () {
            this.canvas || (this.canvas = e("<canvas>")["prepend" == this.insertMode ? "prependTo" : "appendTo"](this.el)[0]);
            var t = this.canvas;
            if (t.width = this.size, t.height = this.size, this.ctx = t.getContext("2d"), window.devicePixelRatio > 1) {
                var i = window.devicePixelRatio;
                t.style.width = t.style.height = this.size + "px", t.width = t.height = this.size * i, this.ctx.scale(i, i)
            }
        },
        initFill: function () {
            var t, i = this,
                n = this.fill,
                r = this.ctx,
                o = this.size;
            if (!n) throw Error("The fill is not specified!");
            if ("string" == typeof n && (n = {
                    color: n
                }), n.color && (this.arcFill = n.color), n.gradient) {
                var s = n.gradient;
                if (1 == s.length) this.arcFill = s[0];
                else if (s.length > 1) {
                    for (var a = n.gradientAngle || 0, l = n.gradientDirection || [o / 2 * (1 - Math.cos(a)), o / 2 * (1 + Math.sin(a)), o / 2 * (1 + Math.cos(a)), o / 2 * (1 - Math.sin(a))], c = r.createLinearGradient.apply(r, l), u = 0; u < s.length; u++) {
                        var h = s[u],
                            d = u / (s.length - 1);
                        e.isArray(h) && (d = h[1], h = h[0]), c.addColorStop(d, h)
                    }
                    this.arcFill = c
                }
            }

            function p() {
                var n = e("<canvas>")[0];
                n.width = i.size, n.height = i.size, n.getContext("2d").drawImage(t, 0, 0, o, o), i.arcFill = i.ctx.createPattern(n, "no-repeat"), i.drawFrame(i.lastFrameValue)
            }
            n.image && (n.image instanceof Image ? t = n.image : (t = new Image).src = n.image, t.complete ? p() : t.onload = p)
        },
        draw: function () {
            this.animation ? this.drawAnimated(this.value) : this.drawFrame(this.value)
        },
        drawFrame: function (e) {
            this.lastFrameValue = e, this.ctx.clearRect(0, 0, this.size, this.size), this.drawEmptyArc(e), this.drawArc(e)
        },
        drawArc: function (e) {
            if (0 !== e) {
                var t = this.ctx,
                    i = this.radius,
                    n = this.getThickness(),
                    r = this.startAngle;
                t.save(), t.beginPath(), this.reverse ? t.arc(i, i, i - n / 2, r - 2 * Math.PI * e, r) : t.arc(i, i, i - n / 2, r, r + 2 * Math.PI * e), t.lineWidth = n, t.lineCap = this.lineCap, t.strokeStyle = this.arcFill, t.stroke(), t.restore()
            }
        },
        drawEmptyArc: function (e) {
            var t = this.ctx,
                i = this.radius,
                n = this.getThickness(),
                r = this.startAngle;
            e < 1 && (t.save(), t.beginPath(), e <= 0 ? t.arc(i, i, i - n / 2, 0, 2 * Math.PI) : this.reverse ? t.arc(i, i, i - n / 2, r, r - 2 * Math.PI * e) : t.arc(i, i, i - n / 2, r + 2 * Math.PI * e, r), t.lineWidth = n, t.strokeStyle = this.emptyFill, t.stroke(), t.restore())
        },
        drawAnimated: function (t) {
            var i = this,
                n = this.el,
                r = e(this.canvas);
            r.stop(!0, !1), n.trigger("circle-animation-start"), r.css({
                animationProgress: 0
            }).animate({
                animationProgress: 1
            }, e.extend({}, this.animation, {
                step: function (e) {
                    var r = i.animationStartValue * (1 - e) + t * e;
                    i.drawFrame(r), n.trigger("circle-animation-progress", [e, r])
                }
            })).promise().always((function () {
                n.trigger("circle-animation-end")
            }))
        },
        getThickness: function () {
            return e.isNumeric(this.thickness) ? this.thickness : this.size / 14
        },
        getValue: function () {
            return this.value
        },
        setValue: function (e) {
            this.animation && (this.animationStartValue = this.lastFrameValue), this.value = e, this.draw()
        }
    }, e.circleProgress = {
        defaults: t.prototype
    }, e.easing.circleProgressEasing = function (e) {
        return e < .5 ? .5 * (e *= 2) * e * e : 1 - .5 * (e = 2 - 2 * e) * e * e
    }, e.fn.circleProgress = function (i, n) {
        var r = "circle-progress",
            o = this.data(r);
        if ("widget" == i) {
            if (!o) throw Error('Calling "widget" method on not initialized instance is forbidden');
            return o.canvas
        }
        if ("value" == i) {
            if (!o) throw Error('Calling "value" method on not initialized instance is forbidden');
            if (void 0 === n) return o.getValue();
            var s = arguments[1];
            return this.each((function () {
                e(this).data(r).setValue(s)
            }))
        }
        return this.each((function () {
            var n = e(this),
                o = n.data(r),
                s = e.isPlainObject(i) ? i : {};
            if (o) o.init(s);
            else {
                var a = e.extend({}, n.data());
                "string" == typeof a.fill && (a.fill = JSON.parse(a.fill)), "string" == typeof a.animation && (a.animation = JSON.parse(a.animation)), (s = e.extend(a, s)).el = n, o = new t(s), n.data(r, o)
            }
        }))
    }
})),
function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).window = e.window || {})
}(this, (function (e) {
    "use strict";

    function t(e, t) {
        e.prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t
    }

    function i(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }

    function n(e) {
        return "string" == typeof e
    }

    function r(e) {
        return "function" == typeof e
    }

    function o(e) {
        return "number" == typeof e
    }

    function s(e) {
        return void 0 === e
    }

    function a(e) {
        return "object" == typeof e
    }

    function l(e) {
        return !1 !== e
    }

    function c() {
        return "undefined" != typeof window
    }

    function u(e) {
        return r(e) || n(e)
    }

    function h(e) {
        return (Me = _t(e, ut)) && zi
    }

    function d(e, t) {
        return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
    }

    function p(e, t) {
        return !t && console.warn(e)
    }

    function f(e, t) {
        return e && (ut[e] = t) && Me && (Me[e] = t) || ut
    }

    function m() {
        return 0
    }

    function g(e) {
        var t, i, n = e[0];
        if (a(n) || r(n) || (e = [e]), !(t = (n._gsap || {}).harness)) {
            for (i = xt.length; i-- && !xt[i].targetTest(n););
            t = xt[i]
        }
        for (i = e.length; i--;) e[i] && (e[i]._gsap || (e[i]._gsap = new qt(e[i], t))) || e.splice(i, 1);
        return e
    }

    function v(e) {
        return e._gsap || g(Lt(e))[0]._gsap
    }

    function y(e, t, i) {
        return (i = e[t]) && r(i) ? e[t]() : s(i) && e.getAttribute && e.getAttribute(t) || i
    }

    function b(e, t) {
        return (e = e.split(",")).forEach(t) || e
    }

    function x(e) {
        return Math.round(1e5 * e) / 1e5 || 0
    }

    function w(e) {
        return Math.round(1e7 * e) / 1e7 || 0
    }

    function _(e, t) {
        var i = t.charAt(0),
            n = parseFloat(t.substr(2));
        return e = parseFloat(e), "+" === i ? e + n : "-" === i ? e - n : "*" === i ? e * n : e / n
    }

    function E(e, t) {
        for (var i = t.length, n = 0; e.indexOf(t[n]) < 0 && ++n < i;);
        return n < i
    }

    function M() {
        var e, t, i = mt.length,
            n = mt.slice(0);
        for (gt = {}, e = mt.length = 0; e < i; e++)(t = n[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
    }

    function S(e, t, i, n) {
        mt.length && !ye && M(), e.render(t, i, n || ye && t < 0 && (e._initted || e._startAt)), mt.length && !ye && M()
    }

    function T(e) {
        var t = parseFloat(e);
        return (t || 0 === t) && (e + "").match(lt).length < 2 ? t : n(e) ? e.trim() : e
    }

    function A(e) {
        return e
    }

    function C(e, t) {
        for (var i in t) i in e || (e[i] = t[i]);
        return e
    }

    function L(e, t) {
        for (var i in t) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (e[i] = a(t[i]) ? L(e[i] || (e[i] = {}), t[i]) : t[i]);
        return e
    }

    function P(e, t) {
        var i, n = {};
        for (i in e) i in t || (n[i] = e[i]);
        return n
    }

    function I(e) {
        var t = e.parent || xe,
            i = e.keyframes ? function (e) {
                return function (t, i) {
                    for (var n in i) n in t || "duration" === n && e || "ease" === n || (t[n] = i[n])
                }
            }(it(e.keyframes)) : C;
        if (l(e.inherit))
            for (; t;) i(e, t.vars.defaults), t = t.parent || t._dp;
        return e
    }

    function O(e, t, i, n, r) {
        void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
        var o, s = e[n];
        if (r)
            for (o = t[r]; s && s[r] > o;) s = s._prev;
        return s ? (t._next = s._next, s._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[n] = t, t._prev = s, t.parent = t._dp = e, t
    }

    function R(e, t, i, n) {
        void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
        var r = t._prev,
            o = t._next;
        r ? r._next = o : e[i] === t && (e[i] = o), o ? o._prev = r : e[n] === t && (e[n] = r), t._next = t._prev = t.parent = null
    }

    function D(e, t) {
        !e.parent || t && !e.parent.autoRemoveChildren || e.parent.remove(e), e._act = 0
    }

    function k(e, t) {
        if (e && (!t || t._end > e._dur || t._start < 0))
            for (var i = e; i;) i._dirty = 1, i = i.parent;
        return e
    }

    function z(e, t, i, n) {
        return e._startAt && (ye ? e._startAt.revert(dt) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, n))
    }

    function B(e) {
        return e._repeat ? Et(e._tTime, e = e.duration() + e._rDelay) * e : 0
    }

    function N(e, t) {
        return (e - t._start) * t._ts + (0 <= t._ts ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    }

    function F(e) {
        return e._end = w(e._start + (e._tDur / Math.abs(e._ts || e._rts || Ye) || 0))
    }

    function H(e, t) {
        var i = e._dp;
        return i && i.smoothChildTiming && e._ts && (e._start = w(i._time - (0 < e._ts ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), F(e), i._dirty || k(i, e)), e
    }

    function U(e, t) {
        var i;
        if ((t._time || t._initted && !t._dur) && (i = N(e.rawTime(), t), (!t._dur || At(0, t.totalDuration(), i) - t._tTime > Ye) && t.render(i, !0)), k(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
            if (e._dur < e.duration())
                for (i = e; i._dp;) 0 <= i.rawTime() && i.totalTime(i._tTime), i = i._dp;
            e._zTime = -Ye
        }
    }

    function j(e, t, i, n) {
        return t.parent && D(t), t._start = w((o(i) ? i : i || e !== xe ? Tt(e, i, t) : e._time) + t._delay), t._end = w(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), O(e, t, "_first", "_last", e._sort ? "_start" : 0), Mt(t) || (e._recent = t), n || U(e, t), e._ts < 0 && H(e, e._tTime), e
    }

    function G(e, t) {
        return (ut.ScrollTrigger || d("scrollTrigger", t)) && ut.ScrollTrigger.create(t, e)
    }

    function V(e, t, i, n, r) {
        return ti(e, t, r), e._initted ? !i && e._pt && !ye && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && Te !== zt.frame ? (mt.push(e), e._lazy = [r, n], 1) : void 0 : 1
    }

    function W(e, t, i, n) {
        var r = e._repeat,
            o = w(t) || 0,
            s = e._tTime / e._tDur;
        return s && !n && (e._time *= o / e._dur), e._dur = o, e._tDur = r ? r < 0 ? 1e10 : w(o * (r + 1) + e._rDelay * r) : o, 0 < s && !n && H(e, e._tTime = e._tDur * s), e.parent && F(e), i || k(e.parent, e), e
    }

    function q(e) {
        return e instanceof Zt ? k(e) : W(e, e._dur)
    }

    function X(e, t, i) {
        var n, r, s = o(t[1]),
            a = (s ? 2 : 1) + (e < 2 ? 0 : 1),
            c = t[a];
        if (s && (c.duration = t[1]), c.parent = i, e) {
            for (n = c, r = i; r && !("immediateRender" in n);) n = r.vars.defaults || {}, r = l(r.vars.inherit) && r.parent;
            c.immediateRender = l(n.immediateRender), e < 2 ? c.runBackwards = 1 : c.startAt = t[a - 1]
        }
        return new oi(t[0], c, t[1 + a])
    }

    function Y(e, t) {
        return e || 0 === e ? t(e) : t
    }

    function Z(e, t) {
        return n(e) && (t = ct.exec(e)) ? t[1] : ""
    }

    function Q(e, t) {
        return e && a(e) && "length" in e && (!t && !e.length || e.length - 1 in e && a(e[0])) && !e.nodeType && e !== we
    }

    function J(e) {
        return e = Lt(e)[0] || p("Invalid scope") || {},
            function (t) {
                var i = e.current || e.nativeElement || e;
                return Lt(t, i.querySelectorAll ? i : i === e ? p("Invalid scope") || Ee.createElement("div") : e)
            }
    }

    function K(e) {
        return e.sort((function () {
            return .5 - Math.random()
        }))
    }

    function $(e) {
        if (r(e)) return e;
        var t = a(e) ? e : {
                each: e
            },
            i = jt(t.ease),
            o = t.from || 0,
            s = parseFloat(t.base) || 0,
            l = {},
            c = 0 < o && o < 1,
            u = isNaN(o) || c,
            h = t.axis,
            d = o,
            p = o;
        return n(o) ? d = p = {
                center: .5,
                edges: .5,
                end: 1
            } [o] || 0 : !c && u && (d = o[0], p = o[1]),
            function (e, n, r) {
                var a, c, f, m, g, v, y, b, x, _ = (r || t).length,
                    E = l[_];
                if (!E) {
                    if (!(x = "auto" === t.grid ? 0 : (t.grid || [1, Xe])[1])) {
                        for (y = -Xe; y < (y = r[x++].getBoundingClientRect().left) && x < _;);
                        x--
                    }
                    for (E = l[_] = [], a = u ? Math.min(x, _) * d - .5 : o % x, c = x === Xe ? 0 : u ? _ * p / x - .5 : o / x | 0, b = Xe, v = y = 0; v < _; v++) f = v % x - a, m = c - (v / x | 0), E[v] = g = h ? Math.abs("y" === h ? m : f) : Ke(f * f + m * m), y < g && (y = g), g < b && (b = g);
                    "random" === o && K(E), E.max = y - b, E.min = b, E.v = _ = (parseFloat(t.amount) || parseFloat(t.each) * (_ < x ? _ - 1 : h ? "y" === h ? _ / x : x : Math.max(x, _ / x)) || 0) * ("edges" === o ? -1 : 1), E.b = _ < 0 ? s - _ : s, E.u = Z(t.amount || t.each) || 0, i = i && _ < 0 ? Ut(i) : i
                }
                return _ = (E[e] - E.min) / E.max || 0, w(E.b + (i ? i(_) : _) * E.v) + E.u
            }
    }

    function ee(e) {
        var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
        return function (i) {
            var n = w(Math.round(parseFloat(i) / e) * e * t);
            return (n - n % 1) / t + (o(i) ? 0 : Z(i))
        }
    }

    function te(e, t) {
        var i, n, s = it(e);
        return !s && a(e) && (i = s = e.radius || Xe, e.values ? (e = Lt(e.values), (n = !o(e[0])) && (i *= i)) : e = ee(e.increment)), Y(t, s ? r(e) ? function (t) {
            return n = e(t), Math.abs(n - t) <= i ? n : t
        } : function (t) {
            for (var r, s, a = parseFloat(n ? t.x : t), l = parseFloat(n ? t.y : 0), c = Xe, u = 0, h = e.length; h--;)(r = n ? (r = e[h].x - a) * r + (s = e[h].y - l) * s : Math.abs(e[h] - a)) < c && (c = r, u = h);
            return u = !i || c <= i ? e[u] : t, n || u === t || o(t) ? u : u + Z(t)
        } : ee(e))
    }

    function ie(e, t, i, n) {
        return Y(it(e) ? !t : !0 === i ? !!(i = 0) : !n, (function () {
            return it(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + .99 * i)) / i) * i * n) / n
        }))
    }

    function ne(e, t, i) {
        return Y(i, (function (i) {
            return e[~~t(i)]
        }))
    }

    function re(e) {
        for (var t, i, n, r, o = 0, s = ""; ~(t = e.indexOf("random(", o));) n = e.indexOf(")", t), r = "[" === e.charAt(t + 7), i = e.substr(t + 7, n - t - 7).match(r ? lt : nt), s += e.substr(o, t - o) + ie(r ? i : +i[0], r ? 0 : +i[1], +i[2] || 1e-5), o = n + 1;
        return s + e.substr(o, e.length - o)
    }

    function oe(e, t, i) {
        var n, r, o, s = e.labels,
            a = Xe;
        for (n in s)(r = s[n] - t) < 0 == !!i && r && a > (r = Math.abs(r)) && (o = n, a = r);
        return o
    }

    function se(e) {
        return D(e), e.scrollTrigger && e.scrollTrigger.kill(!!ye), e.progress() < 1 && It(e, "onInterrupt"), e
    }

    function ae(e, t, i) {
        return (6 * (e += e < 0 ? 1 : 1 < e ? -1 : 0) < 1 ? t + (i - t) * e * 6 : e < .5 ? i : 3 * e < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * Ot + .5 | 0
    }

    function le(e, t, i) {
        var n, r, s, a, l, c, u, h, d, p, f = e ? o(e) ? [e >> 16, e >> 8 & Ot, e & Ot] : 0 : Rt.black;
        if (!f) {
            if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), Rt[e]) f = Rt[e];
            else if ("#" === e.charAt(0)) {
                if (e.length < 6 && (e = "#" + (n = e.charAt(1)) + n + (r = e.charAt(2)) + r + (s = e.charAt(3)) + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(f = parseInt(e.substr(1, 6), 16)) >> 16, f >> 8 & Ot, f & Ot, parseInt(e.substr(7), 16) / 255];
                f = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & Ot, e & Ot]
            } else if ("hsl" === e.substr(0, 3))
                if (f = p = e.match(nt), t) {
                    if (~e.indexOf("=")) return f = e.match(rt), i && f.length < 4 && (f[3] = 1), f
                } else a = +f[0] % 360 / 360, l = f[1] / 100, n = 2 * (c = f[2] / 100) - (r = c <= .5 ? c * (l + 1) : c + l - c * l), 3 < f.length && (f[3] *= 1), f[0] = ae(a + 1 / 3, n, r), f[1] = ae(a, n, r), f[2] = ae(a - 1 / 3, n, r);
            else f = e.match(nt) || Rt.transparent;
            f = f.map(Number)
        }
        return t && !p && (n = f[0] / Ot, r = f[1] / Ot, s = f[2] / Ot, c = ((u = Math.max(n, r, s)) + (h = Math.min(n, r, s))) / 2, u === h ? a = l = 0 : (d = u - h, l = .5 < c ? d / (2 - u - h) : d / (u + h), a = u === n ? (r - s) / d + (r < s ? 6 : 0) : u === r ? (s - n) / d + 2 : (n - r) / d + 4, a *= 60), f[0] = ~~(a + .5), f[1] = ~~(100 * l + .5), f[2] = ~~(100 * c + .5)), i && f.length < 4 && (f[3] = 1), f
    }

    function ce(e) {
        var t = [],
            i = [],
            n = -1;
        return e.split(Dt).forEach((function (e) {
            var r = e.match(ot) || [];
            t.push.apply(t, r), i.push(n += r.length + 1)
        })), t.c = i, t
    }

    function ue(e, t, i) {
        var n, r, o, s, a = "",
            l = (e + a).match(Dt),
            c = t ? "hsla(" : "rgba(",
            u = 0;
        if (!l) return e;
        if (l = l.map((function (e) {
                return (e = le(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
            })), i && (o = ce(e), (n = i.c).join(a) !== o.c.join(a)))
            for (s = (r = e.replace(Dt, "1").split(ot)).length - 1; u < s; u++) a += r[u] + (~n.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (o.length ? o : l.length ? l : i).shift());
        if (!r)
            for (s = (r = e.split(Dt)).length - 1; u < s; u++) a += r[u] + l[u];
        return a + r[s]
    }

    function he(e) {
        var t, i = e.join(" ");
        if (Dt.lastIndex = 0, Dt.test(i)) return t = kt.test(i), e[1] = ue(e[1], t), e[0] = ue(e[0], t, ce(e[1])), !0
    }

    function de(e, t) {
        for (var i, n = e._first; n;) n instanceof Zt ? de(n, t) : !n.vars.yoyoEase || n._yoyo && n._repeat || n._yoyo === t || (n.timeline ? de(n.timeline, t) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = t)), n = n._next
    }

    function pe(e, t, i, n) {
        void 0 === i && (i = function (e) {
            return 1 - t(1 - e)
        }), void 0 === n && (n = function (e) {
            return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
        });
        var r, o = {
            easeIn: t,
            easeOut: i,
            easeInOut: n
        };
        return b(e, (function (e) {
            for (var t in Nt[e] = ut[e] = o, Nt[r = e.toLowerCase()] = i, o) Nt[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = Nt[e + "." + t] = o[t]
        })), o
    }

    function fe(e) {
        return function (t) {
            return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
        }
    }

    function me(e, t, i) {
        function n(e) {
            return 1 === e ? 1 : r * Math.pow(2, -10 * e) * et((e - s) * o) + 1
        }
        var r = 1 <= t ? t : 1,
            o = (i || (e ? .3 : .45)) / (t < 1 ? t : 1),
            s = o / Ze * (Math.asin(1 / r) || 0),
            a = "out" === e ? n : "in" === e ? function (e) {
                return 1 - n(1 - e)
            } : fe(n);
        return o = Ze / o, a.config = function (t, i) {
            return me(e, t, i)
        }, a
    }

    function ge(e, t) {
        function i(e) {
            return e ? --e * e * ((t + 1) * e + t) + 1 : 0
        }
        void 0 === t && (t = 1.70158);
        var n = "out" === e ? i : "in" === e ? function (e) {
            return 1 - i(1 - e)
        } : fe(i);
        return n.config = function (t) {
            return ge(e, t)
        }, n
    }
    var ve, ye, be, xe, we, _e, Ee, Me, Se, Te, Ae, Ce, Le, Pe, Ie, Oe, Re, De, ke, ze, Be, Ne, Fe, He, Ue, je, Ge, Ve, We = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        },
        qe = {
            duration: .5,
            overwrite: !1,
            delay: 0
        },
        Xe = 1e8,
        Ye = 1 / Xe,
        Ze = 2 * Math.PI,
        Qe = Ze / 4,
        Je = 0,
        Ke = Math.sqrt,
        $e = Math.cos,
        et = Math.sin,
        tt = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () {},
        it = Array.isArray,
        nt = /(?:-?\.?\d|\.)+/gi,
        rt = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        ot = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        st = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        at = /[+-]=-?[.\d]+/,
        lt = /[^,'"\[\]\s]+/gi,
        ct = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        ut = {},
        ht = {
            suppressEvents: !0,
            isStart: !0,
            kill: !1
        },
        dt = {
            suppressEvents: !0,
            kill: !1
        },
        pt = {
            suppressEvents: !0
        },
        ft = {},
        mt = [],
        gt = {},
        vt = {},
        yt = {},
        bt = 30,
        xt = [],
        wt = "",
        _t = function (e, t) {
            for (var i in t) e[i] = t[i];
            return e
        },
        Et = function (e, t) {
            var i = Math.floor(e /= t);
            return e && i === e ? i - 1 : i
        },
        Mt = function (e) {
            var t = e.data;
            return "isFromStart" === t || "isStart" === t
        },
        St = {
            _start: 0,
            endTime: m,
            totalDuration: m
        },
        Tt = function e(t, i, r) {
            var o, s, a, l = t.labels,
                c = t._recent || St,
                u = t.duration() >= Xe ? c.endTime(!1) : t._dur;
            return n(i) && (isNaN(i) || i in l) ? (s = i.charAt(0), a = "%" === i.substr(-1), o = i.indexOf("="), "<" === s || ">" === s ? (0 <= o && (i = i.replace(/=/, "")), ("<" === s ? c._start : c.endTime(0 <= c._repeat)) + (parseFloat(i.substr(1)) || 0) * (a ? (o < 0 ? c : r).totalDuration() / 100 : 1)) : o < 0 ? (i in l || (l[i] = u), l[i]) : (s = parseFloat(i.charAt(o - 1) + i.substr(o + 1)), a && r && (s = s / 100 * (it(r) ? r[0] : r).totalDuration()), 1 < o ? e(t, i.substr(0, o - 1), r) + s : u + s)) : null == i ? u : +i
        },
        At = function (e, t, i) {
            return i < e ? e : t < i ? t : i
        },
        Ct = [].slice,
        Lt = function (e, t, i) {
            return be && !t && be.selector ? be.selector(e) : !n(e) || i || !_e && Bt() ? it(e) ? function (e, t, i) {
                return void 0 === i && (i = []), e.forEach((function (e) {
                    return n(e) && !t || Q(e, 1) ? i.push.apply(i, Lt(e)) : i.push(e)
                })) || i
            }(e, i) : Q(e) ? Ct.call(e, 0) : e ? [e] : [] : Ct.call((t || Ee).querySelectorAll(e), 0)
        },
        Pt = function (e, t, i, n, r) {
            var o = t - e,
                s = n - i;
            return Y(r, (function (t) {
                return i + ((t - e) / o * s || 0)
            }))
        },
        It = function (e, t, i) {
            var n, r, o, s = e.vars,
                a = s[t],
                l = be,
                c = e._ctx;
            if (a) return n = s[t + "Params"], r = s.callbackScope || e, i && mt.length && M(), c && (be = c), o = n ? a.apply(r, n) : a.call(r), be = l, o
        },
        Ot = 255,
        Rt = {
            aqua: [0, Ot, Ot],
            lime: [0, Ot, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, Ot],
            navy: [0, 0, 128],
            white: [Ot, Ot, Ot],
            olive: [128, 128, 0],
            yellow: [Ot, Ot, 0],
            orange: [Ot, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [Ot, 0, 0],
            pink: [Ot, 192, 203],
            cyan: [0, Ot, Ot],
            transparent: [Ot, Ot, Ot, 0]
        },
        Dt = function () {
            var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (e in Rt) t += "|" + e + "\\b";
            return new RegExp(t + ")", "gi")
        }(),
        kt = /hsl[a]?\(/,
        zt = (ke = Date.now, ze = 500, Be = 33, Ne = ke(), Fe = Ne, Ue = He = 1e3 / 240, Oe = {
            time: 0,
            frame: 0,
            tick: function () {
                Gt(!0)
            },
            deltaRatio: function (e) {
                return Re / (1e3 / (e || 60))
            },
            wake: function () {
                Se && (!_e && c() && (we = _e = window, Ee = we.document || {}, ut.gsap = zi, (we.gsapVersions || (we.gsapVersions = [])).push(zi.version), h(Me || we.GreenSockGlobals || !we.gsap && we || {}), Ie = we.requestAnimationFrame), Le && Oe.sleep(), Pe = Ie || function (e) {
                    return setTimeout(e, Ue - 1e3 * Oe.time + 1 | 0)
                }, Ce = 1, Gt(2))
            },
            sleep: function () {
                (Ie ? we.cancelAnimationFrame : clearTimeout)(Le), Ce = 0, Pe = m
            },
            lagSmoothing: function (e, t) {
                ze = e || 1 / 0, Be = Math.min(t || 33, ze)
            },
            fps: function (e) {
                He = 1e3 / (e || 240), Ue = 1e3 * Oe.time + He
            },
            add: function (e, t, i) {
                var n = t ? function (t, i, r, o) {
                    e(t, i, r, o), Oe.remove(n)
                } : e;
                return Oe.remove(e), je[i ? "unshift" : "push"](n), Bt(), n
            },
            remove: function (e, t) {
                ~(t = je.indexOf(e)) && je.splice(t, 1) && t <= De && De--
            },
            _listeners: je = []
        }),
        Bt = function () {
            return !Ce && zt.wake()
        },
        Nt = {},
        Ft = /^[\d.\-M][\d.\-,\s]/,
        Ht = /["']/g,
        Ut = function (e) {
            return function (t) {
                return 1 - e(1 - t)
            }
        },
        jt = function (e, t) {
            return e && (r(e) ? e : Nt[e] || function (e) {
                var t = (e + "").split("("),
                    i = Nt[t[0]];
                return i && 1 < t.length && i.config ? i.config.apply(null, ~e.indexOf("{") ? [function (e) {
                    for (var t, i, n, r = {}, o = e.substr(1, e.length - 3).split(":"), s = o[0], a = 1, l = o.length; a < l; a++) i = o[a], t = a !== l - 1 ? i.lastIndexOf(",") : i.length, n = i.substr(0, t), r[s] = isNaN(n) ? n.replace(Ht, "").trim() : +n, s = i.substr(t + 1).trim();
                    return r
                }(t[1])] : function (e) {
                    var t = e.indexOf("(") + 1,
                        i = e.indexOf(")"),
                        n = e.indexOf("(", t);
                    return e.substring(t, ~n && n < i ? e.indexOf(")", i + 1) : i)
                }(e).split(",").map(T)) : Nt._CE && Ft.test(e) ? Nt._CE("", e) : i
            }(e)) || t
        };

    function Gt(e) {
        var t, i, n, r, o = ke() - Fe,
            s = !0 === e;
        if (ze < o && (Ne += o - Be), (0 < (t = (n = (Fe += o) - Ne) - Ue) || s) && (r = ++Oe.frame, Re = n - 1e3 * Oe.time, Oe.time = n /= 1e3, Ue += t + (He <= t ? 4 : He - t), i = 1), s || (Le = Pe(Gt)), i)
            for (De = 0; De < je.length; De++) je[De](n, Re, r, e)
    }

    function Vt(e) {
        return e < Ve ? Ge * e * e : e < .7272727272727273 ? Ge * Math.pow(e - 1.5 / 2.75, 2) + .75 : e < .9090909090909092 ? Ge * (e -= 2.25 / 2.75) * e + .9375 : Ge * Math.pow(e - 2.625 / 2.75, 2) + .984375
    }
    b("Linear,Quad,Cubic,Quart,Quint,Strong", (function (e, t) {
        var i = t < 5 ? t + 1 : t;
        pe(e + ",Power" + (i - 1), t ? function (e) {
            return Math.pow(e, i)
        } : function (e) {
            return e
        }, (function (e) {
            return 1 - Math.pow(1 - e, i)
        }), (function (e) {
            return e < .5 ? Math.pow(2 * e, i) / 2 : 1 - Math.pow(2 * (1 - e), i) / 2
        }))
    })), Nt.Linear.easeNone = Nt.none = Nt.Linear.easeIn, pe("Elastic", me("in"), me("out"), me()), Ge = 7.5625, Ve = 1 / 2.75, pe("Bounce", (function (e) {
        return 1 - Vt(1 - e)
    }), Vt), pe("Expo", (function (e) {
        return e ? Math.pow(2, 10 * (e - 1)) : 0
    })), pe("Circ", (function (e) {
        return -(Ke(1 - e * e) - 1)
    })), pe("Sine", (function (e) {
        return 1 === e ? 1 : 1 - $e(e * Qe)
    })), pe("Back", ge("in"), ge("out"), ge()), Nt.SteppedEase = Nt.steps = ut.SteppedEase = {
        config: function (e, t) {
            void 0 === e && (e = 1);
            var i = 1 / e,
                n = e + (t ? 0 : 1),
                r = t ? 1 : 0;
            return function (e) {
                return ((n * At(0, .99999999, e) | 0) + r) * i
            }
        }
    }, qe.ease = Nt["quad.out"], b("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (e) {
        return wt += e + "," + e + "Params,"
    }));
    var Wt, qt = function (e, t) {
            this.id = Je++, (e._gsap = this).target = e, this.harness = t, this.get = t ? t.get : y, this.set = t ? t.getSetter : hi
        },
        Xt = ((Wt = Yt.prototype).delay = function (e) {
            return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay
        }, Wt.duration = function (e) {
            return arguments.length ? this.totalDuration(0 < this._repeat ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
        }, Wt.totalDuration = function (e) {
            return arguments.length ? (this._dirty = 0, W(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }, Wt.totalTime = function (e, t) {
            if (Bt(), !arguments.length) return this._tTime;
            var i = this._dp;
            if (i && i.smoothChildTiming && this._ts) {
                for (H(this, e), !i._dp || i.parent || U(i, this); i && i.parent;) i.parent._time !== i._start + (0 <= i._ts ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0), i = i.parent;
                !this.parent && this._dp.autoRemoveChildren && (0 < this._ts && e < this._tDur || this._ts < 0 && 0 < e || !this._tDur && !e) && j(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === Ye || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), S(this, e, t)), this
        }, Wt.time = function (e, t) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + B(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time
        }, Wt.totalProgress = function (e, t) {
            return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
        }, Wt.progress = function (e, t) {
            return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + B(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
        }, Wt.iteration = function (e, t) {
            var i = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (e - 1) * i, t) : this._repeat ? Et(this._tTime, i) + 1 : 1
        }, Wt.timeScale = function (e) {
            if (!arguments.length) return this._rts === -Ye ? 0 : this._rts;
            if (this._rts === e) return this;
            var t = this.parent && this._ts ? N(this.parent._time, this) : this._tTime;
            return this._rts = +e || 0, this._ts = this._ps || e === -Ye ? 0 : this._rts, this.totalTime(At(-this._delay, this._tDur, t), !0), F(this),
                function (e) {
                    for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
                    return e
                }(this)
        }, Wt.paused = function (e) {
            return arguments.length ? (this._ps !== e && ((this._ps = e) ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Bt(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== Ye && (this._tTime -= Ye)))), this) : this._ps
        }, Wt.startTime = function (e) {
            if (arguments.length) {
                this._start = e;
                var t = this.parent || this._dp;
                return !t || !t._sort && this.parent || j(t, this, e - this._delay), this
            }
            return this._start
        }, Wt.endTime = function (e) {
            return this._start + (l(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
        }, Wt.rawTime = function (e) {
            var t = this.parent || this._dp;
            return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? N(t.rawTime(e), this) : this._tTime : this._tTime
        }, Wt.revert = function (e) {
            void 0 === e && (e = pt);
            var t = ye;
            return ye = e, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(e), this.totalTime(-.01, e.suppressEvents)), "nested" !== this.data && !1 !== e.kill && this.kill(), ye = t, this
        }, Wt.globalTime = function (e) {
            for (var t = this, i = arguments.length ? e : t.rawTime(); t;) i = t._start + i / (t._ts || 1), t = t._dp;
            return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(e) : i
        }, Wt.repeat = function (e) {
            return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, q(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
        }, Wt.repeatDelay = function (e) {
            if (arguments.length) {
                var t = this._time;
                return this._rDelay = e, q(this), t ? this.time(t) : this
            }
            return this._rDelay
        }, Wt.yoyo = function (e) {
            return arguments.length ? (this._yoyo = e, this) : this._yoyo
        }, Wt.seek = function (e, t) {
            return this.totalTime(Tt(this, e), l(t))
        }, Wt.restart = function (e, t) {
            return this.play().totalTime(e ? -this._delay : 0, l(t))
        }, Wt.play = function (e, t) {
            return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
        }, Wt.reverse = function (e, t) {
            return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
        }, Wt.pause = function (e, t) {
            return null != e && this.seek(e, t), this.paused(!0)
        }, Wt.resume = function () {
            return this.paused(!1)
        }, Wt.reversed = function (e) {
            return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -Ye : 0)), this) : this._rts < 0
        }, Wt.invalidate = function () {
            return this._initted = this._act = 0, this._zTime = -Ye, this
        }, Wt.isActive = function () {
            var e, t = this.parent || this._dp,
                i = this._start;
            return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= i && e < this.endTime(!0) - Ye))
        }, Wt.eventCallback = function (e, t, i) {
            var n = this.vars;
            return 1 < arguments.length ? (t ? (n[e] = t, i && (n[e + "Params"] = i), "onUpdate" === e && (this._onUpdate = t)) : delete n[e], this) : n[e]
        }, Wt.then = function (e) {
            var t = this;
            return new Promise((function (i) {
                function n() {
                    var e = t.then;
                    t.then = null, r(o) && (o = o(t)) && (o.then || o === t) && (t.then = e), i(o), t.then = e
                }
                var o = r(e) ? e : A;
                t._initted && 1 === t.totalProgress() && 0 <= t._ts || !t._tTime && t._ts < 0 ? n() : t._prom = n
            }))
        }, Wt.kill = function () {
            se(this)
        }, Yt);

    function Yt(e) {
        this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, W(this, +e.duration, 1, 1), this.data = e.data, be && (this._ctx = be).data.push(this), Ce || zt.wake()
    }
    C(Xt.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -Ye,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var Zt = function (e) {
        function s(t, n) {
            var r;
            return void 0 === t && (t = {}), (r = e.call(this, t) || this).labels = {}, r.smoothChildTiming = !!t.smoothChildTiming, r.autoRemoveChildren = !!t.autoRemoveChildren, r._sort = l(t.sortChildren), xe && j(t.parent || xe, i(r), n), t.reversed && r.reverse(), t.paused && r.paused(!0), t.scrollTrigger && G(i(r), t.scrollTrigger), r
        }
        t(s, e);
        var a = s.prototype;
        return a.to = function (e, t, i) {
            return X(0, arguments, this), this
        }, a.from = function (e, t, i) {
            return X(1, arguments, this), this
        }, a.fromTo = function (e, t, i, n) {
            return X(2, arguments, this), this
        }, a.set = function (e, t, i) {
            return t.duration = 0, t.parent = this, I(t).repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new oi(e, t, Tt(this, i), 1), this
        }, a.call = function (e, t, i) {
            return j(this, oi.delayedCall(0, e, t), i)
        }, a.staggerTo = function (e, t, i, n, r, o, s) {
            return i.duration = t, i.stagger = i.stagger || n, i.onComplete = o, i.onCompleteParams = s, i.parent = this, new oi(e, i, Tt(this, r)), this
        }, a.staggerFrom = function (e, t, i, n, r, o, s) {
            return i.runBackwards = 1, I(i).immediateRender = l(i.immediateRender), this.staggerTo(e, t, i, n, r, o, s)
        }, a.staggerFromTo = function (e, t, i, n, r, o, s, a) {
            return n.startAt = i, I(n).immediateRender = l(n.immediateRender), this.staggerTo(e, t, n, r, o, s, a)
        }, a.render = function (e, t, i) {
            var n, r, o, s, a, l, c, u, h, d, p, f, m = this._time,
                g = this._dirty ? this.totalDuration() : this._tDur,
                v = this._dur,
                y = e <= 0 ? 0 : w(e),
                b = this._zTime < 0 != e < 0 && (this._initted || !v);
            if (this !== xe && g < y && 0 <= e && (y = g), y !== this._tTime || i || b) {
                if (m !== this._time && v && (y += this._time - m, e += this._time - m), n = y, h = this._start, l = !(u = this._ts), b && (v || (m = this._zTime), !e && t || (this._zTime = e)), this._repeat) {
                    if (p = this._yoyo, a = v + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * a + e, t, i);
                    if (n = w(y % a), y === g ? (s = this._repeat, n = v) : ((s = ~~(y / a)) && s === y / a && (n = v, s--), v < n && (n = v)), d = Et(this._tTime, a), !m && this._tTime && d !== s && (d = s), p && 1 & s && (n = v - n, f = 1), s !== d && !this._lock) {
                        var x = p && 1 & d,
                            _ = x === (p && 1 & s);
                        if (s < d && (x = !x), m = x ? 0 : v, this._lock = 1, this.render(m || (f ? 0 : w(s * a)), t, !v)._lock = 0, this._tTime = y, !t && this.parent && It(this, "onRepeat"), this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1), m && m !== this._time || l != !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                        if (v = this._dur, g = this._tDur, _ && (this._lock = 2, m = x ? v : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !f && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                        de(this, f)
                    }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (c = function (e, t, i) {
                        var n;
                        if (t < i)
                            for (n = e._first; n && n._start <= i;) {
                                if ("isPause" === n.data && n._start > t) return n;
                                n = n._next
                            } else
                                for (n = e._last; n && n._start >= i;) {
                                    if ("isPause" === n.data && n._start < t) return n;
                                    n = n._prev
                                }
                    }(this, w(m), w(n))) && (y -= n - (n = c._start)), this._tTime = y, this._time = n, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = e, m = 0), !m && n && !t && (It(this, "onStart"), this._tTime !== y)) return this;
                if (m <= n && 0 <= e)
                    for (r = this._first; r;) {
                        if (o = r._next, (r._act || n >= r._start) && r._ts && c !== r) {
                            if (r.parent !== this) return this.render(e, t, i);
                            if (r.render(0 < r._ts ? (n - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (n - r._start) * r._ts, t, i), n !== this._time || !this._ts && !l) {
                                c = 0, o && (y += this._zTime = -Ye);
                                break
                            }
                        }
                        r = o
                    } else {
                        r = this._last;
                        for (var E = e < 0 ? e : n; r;) {
                            if (o = r._prev, (r._act || E <= r._end) && r._ts && c !== r) {
                                if (r.parent !== this) return this.render(e, t, i);
                                if (r.render(0 < r._ts ? (E - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (E - r._start) * r._ts, t, i || ye && (r._initted || r._startAt)), n !== this._time || !this._ts && !l) {
                                    c = 0, o && (y += this._zTime = E ? -Ye : Ye);
                                    break
                                }
                            }
                            r = o
                        }
                    }
                if (c && !t && (this.pause(), c.render(m <= n ? 0 : -Ye)._zTime = m <= n ? 1 : -1, this._ts)) return this._start = h, F(this), this.render(e, t, i);
                this._onUpdate && !t && It(this, "onUpdate", !0), (y === g && this._tTime >= this.totalDuration() || !y && m) && (h !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || (!e && v || !(y === g && 0 < this._ts || !y && this._ts < 0) || D(this, 1), t || e < 0 && !m || !y && !m && g || (It(this, y === g && 0 <= e ? "onComplete" : "onReverseComplete", !0), !this._prom || y < g && 0 < this.timeScale() || this._prom())))
            }
            return this
        }, a.add = function (e, t) {
            var i = this;
            if (o(t) || (t = Tt(this, t, e)), !(e instanceof Xt)) {
                if (it(e)) return e.forEach((function (e) {
                    return i.add(e, t)
                })), this;
                if (n(e)) return this.addLabel(e, t);
                if (!r(e)) return this;
                e = oi.delayedCall(0, e)
            }
            return this !== e ? j(this, e, t) : this
        }, a.getChildren = function (e, t, i, n) {
            void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === i && (i = !0), void 0 === n && (n = -Xe);
            for (var r = [], o = this._first; o;) o._start >= n && (o instanceof oi ? t && r.push(o) : (i && r.push(o), e && r.push.apply(r, o.getChildren(!0, t, i)))), o = o._next;
            return r
        }, a.getById = function (e) {
            for (var t = this.getChildren(1, 1, 1), i = t.length; i--;)
                if (t[i].vars.id === e) return t[i]
        }, a.remove = function (e) {
            return n(e) ? this.removeLabel(e) : r(e) ? this.killTweensOf(e) : (R(this, e), e === this._recent && (this._recent = this._last), k(this))
        }, a.totalTime = function (t, i) {
            return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = w(zt.time - (0 < this._ts ? t / this._ts : (this.totalDuration() - t) / -this._ts))), e.prototype.totalTime.call(this, t, i), this._forcing = 0, this) : this._tTime
        }, a.addLabel = function (e, t) {
            return this.labels[e] = Tt(this, t), this
        }, a.removeLabel = function (e) {
            return delete this.labels[e], this
        }, a.addPause = function (e, t, i) {
            var n = oi.delayedCall(0, t || m, i);
            return n.data = "isPause", this._hasPause = 1, j(this, n, Tt(this, e))
        }, a.removePause = function (e) {
            var t = this._first;
            for (e = Tt(this, e); t;) t._start === e && "isPause" === t.data && D(t), t = t._next
        }, a.killTweensOf = function (e, t, i) {
            for (var n = this.getTweensOf(e, i), r = n.length; r--;) Kt !== n[r] && n[r].kill(e, t);
            return this
        }, a.getTweensOf = function (e, t) {
            for (var i, n = [], r = Lt(e), s = this._first, a = o(t); s;) s instanceof oi ? E(s._targets, r) && (a ? (!Kt || s._initted && s._ts) && s.globalTime(0) <= t && s.globalTime(s.totalDuration()) > t : !t || s.isActive()) && n.push(s) : (i = s.getTweensOf(r, t)).length && n.push.apply(n, i), s = s._next;
            return n
        }, a.tweenTo = function (e, t) {
            t = t || {};
            var i, n = this,
                r = Tt(n, e),
                o = t.startAt,
                s = t.onStart,
                a = t.onStartParams,
                l = t.immediateRender,
                c = oi.to(n, C({
                    ease: t.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: "auto",
                    duration: t.duration || Math.abs((r - (o && "time" in o ? o.time : n._time)) / n.timeScale()) || Ye,
                    onStart: function () {
                        if (n.pause(), !i) {
                            var e = t.duration || Math.abs((r - (o && "time" in o ? o.time : n._time)) / n.timeScale());
                            c._dur !== e && W(c, e, 0, 1).render(c._time, !0, !0), i = 1
                        }
                        s && s.apply(c, a || [])
                    }
                }, t));
            return l ? c.render(0) : c
        }, a.tweenFromTo = function (e, t, i) {
            return this.tweenTo(t, C({
                startAt: {
                    time: Tt(this, e)
                }
            }, i))
        }, a.recent = function () {
            return this._recent
        }, a.nextLabel = function (e) {
            return void 0 === e && (e = this._time), oe(this, Tt(this, e))
        }, a.previousLabel = function (e) {
            return void 0 === e && (e = this._time), oe(this, Tt(this, e), 1)
        }, a.currentLabel = function (e) {
            return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + Ye)
        }, a.shiftChildren = function (e, t, i) {
            void 0 === i && (i = 0);
            for (var n, r = this._first, o = this.labels; r;) r._start >= i && (r._start += e, r._end += e), r = r._next;
            if (t)
                for (n in o) o[n] >= i && (o[n] += e);
            return k(this)
        }, a.invalidate = function (t) {
            var i = this._first;
            for (this._lock = 0; i;) i.invalidate(t), i = i._next;
            return e.prototype.invalidate.call(this, t)
        }, a.clear = function (e) {
            void 0 === e && (e = !0);
            for (var t, i = this._first; i;) t = i._next, this.remove(i), i = t;
            return this._dp && (this._time = this._tTime = this._pTime = 0), e && (this.labels = {}), k(this)
        }, a.totalDuration = function (e) {
            var t, i, n, r = 0,
                o = this,
                s = o._last,
                a = Xe;
            if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -e : e));
            if (o._dirty) {
                for (n = o.parent; s;) t = s._prev, s._dirty && s.totalDuration(), a < (i = s._start) && o._sort && s._ts && !o._lock ? (o._lock = 1, j(o, s, i - s._delay, 1)._lock = 0) : a = i, i < 0 && s._ts && (r -= i, (!n && !o._dp || n && n.smoothChildTiming) && (o._start += i / o._ts, o._time -= i, o._tTime -= i), o.shiftChildren(-i, !1, -1 / 0), a = 0), s._end > r && s._ts && (r = s._end), s = t;
                W(o, o === xe && o._time > r ? o._time : r, 1, 1), o._dirty = 0
            }
            return o._tDur
        }, s.updateRoot = function (e) {
            if (xe._ts && (S(xe, N(e, xe)), Te = zt.frame), zt.frame >= bt) {
                bt += We.autoSleep || 120;
                var t = xe._first;
                if ((!t || !t._ts) && We.autoSleep && zt._listeners.length < 2) {
                    for (; t && !t._ts;) t = t._next;
                    t || zt.sleep()
                }
            }
        }, s
    }(Xt);

    function Qt(e, t, i, o, s, l) {
        var c, u, h, d;
        if (vt[e] && !1 !== (c = new vt[e]).init(s, c.rawVars ? t[e] : function (e, t, i, o, s) {
                if (r(e) && (e = ii(e, s, t, i, o)), !a(e) || e.style && e.nodeType || it(e) || tt(e)) return n(e) ? ii(e, s, t, i, o) : e;
                var l, c = {};
                for (l in e) c[l] = ii(e[l], s, t, i, o);
                return c
            }(t[e], o, s, l, i), i, o, l) && (i._pt = u = new bi(i._pt, s, e, 0, 1, c.render, c, 0, c.priority), i !== Ae))
            for (h = i._ptLookup[i._targets.indexOf(s)], d = c._props.length; d--;) h[c._props[d]] = u;
        return c
    }

    function Jt(e, t, i, n) {
        var r, o, s = t.ease || n || "power1.inOut";
        if (it(t)) o = i[e] || (i[e] = []), t.forEach((function (e, i) {
            return o.push({
                t: i / (t.length - 1) * 100,
                v: e,
                e: s
            })
        }));
        else
            for (r in t) o = i[r] || (i[r] = []), "ease" === r || o.push({
                t: parseFloat(e),
                v: t[r],
                e: s
            })
    }
    C(Zt.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var Kt, $t, ei = function (e, t, i, o, s, a, l, c, u, h) {
            r(o) && (o = o(s || 0, e, a));
            var p, f = e[t],
                m = "get" !== i ? i : r(f) ? u ? e[t.indexOf("set") || !r(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](u) : e[t]() : f,
                g = r(f) ? u ? ui : ci : li;
            if (n(o) && (~o.indexOf("random(") && (o = re(o)), "=" === o.charAt(1) && (!(p = _(m, o) + (Z(m) || 0)) && 0 !== p || (o = p))), !h || m !== o || $t) return isNaN(m * o) || "" === o ? (f || t in e || d(t, o), function (e, t, i, n, r, o, s) {
                var a, l, c, u, h, d, p, f, m = new bi(this._pt, e, t, 0, 1, fi, null, r),
                    g = 0,
                    v = 0;
                for (m.b = i, m.e = n, i += "", (p = ~(n += "").indexOf("random(")) && (n = re(n)), o && (o(f = [i, n], e, t), i = f[0], n = f[1]), l = i.match(st) || []; a = st.exec(n);) u = a[0], h = n.substring(g, a.index), c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1), u !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = {
                    _next: m._pt,
                    p: h || 1 === v ? h : ",",
                    s: d,
                    c: "=" === u.charAt(1) ? _(d, u) - d : parseFloat(u) - d,
                    m: c && c < 4 ? Math.round : 0
                }, g = st.lastIndex);
                return m.c = g < n.length ? n.substring(g, n.length) : "", m.fp = s, (at.test(n) || p) && (m.e = 0), this._pt = m
            }.call(this, e, t, m, o, g, c || We.stringFilter, u)) : (p = new bi(this._pt, e, t, +m || 0, o - (m || 0), "boolean" == typeof f ? pi : di, 0, g), u && (p.fp = u), l && p.modifier(l, this, e), this._pt = p)
        },
        ti = function e(t, i, n) {
            var r, o, s, a, c, u, h, d, p, f, m, y, b, x = t.vars,
                w = x.ease,
                _ = x.startAt,
                E = x.immediateRender,
                S = x.lazy,
                T = x.onUpdate,
                A = x.onUpdateParams,
                L = x.callbackScope,
                I = x.runBackwards,
                O = x.yoyoEase,
                R = x.keyframes,
                k = x.autoRevert,
                z = t._dur,
                B = t._startAt,
                N = t._targets,
                F = t.parent,
                H = F && "nested" === F.data ? F.vars.targets : N,
                U = "auto" === t._overwrite && !ve,
                j = t.timeline;
            if (!j || R && w || (w = "none"), t._ease = jt(w, qe.ease), t._yEase = O ? Ut(jt(!0 === O ? w : O, qe.ease)) : 0, O && t._yoyo && !t._repeat && (O = t._yEase, t._yEase = t._ease, t._ease = O), t._from = !j && !!x.runBackwards, !j || R && !x.stagger) {
                if (y = (d = N[0] ? v(N[0]).harness : 0) && x[d.prop], r = P(x, ft), B && (B._zTime < 0 && B.progress(1), i < 0 && I && E && !k ? B.render(-1, !0) : B.revert(I && z ? dt : ht), B._lazy = 0), _) {
                    if (D(t._startAt = oi.set(N, C({
                            data: "isStart",
                            overwrite: !1,
                            parent: F,
                            immediateRender: !0,
                            lazy: !B && l(S),
                            startAt: null,
                            delay: 0,
                            onUpdate: T,
                            onUpdateParams: A,
                            callbackScope: L,
                            stagger: 0
                        }, _))), t._startAt._dp = 0, t._startAt._sat = t, i < 0 && (ye || !E && !k) && t._startAt.revert(dt), E && z && i <= 0 && n <= 0) return void(i && (t._zTime = i))
                } else if (I && z && !B)
                    if (i && (E = !1), s = C({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: E && !B && l(S),
                            immediateRender: E,
                            stagger: 0,
                            parent: F
                        }, r), y && (s[d.prop] = y), D(t._startAt = oi.set(N, s)), t._startAt._dp = 0, t._startAt._sat = t, i < 0 && (ye ? t._startAt.revert(dt) : t._startAt.render(-1, !0)), t._zTime = i, E) {
                        if (!i) return
                    } else e(t._startAt, Ye, Ye);
                for (t._pt = t._ptCache = 0, S = z && l(S) || S && !z, o = 0; o < N.length; o++) {
                    if (h = (c = N[o])._gsap || g(N)[o]._gsap, t._ptLookup[o] = f = {}, gt[h.id] && mt.length && M(), m = H === N ? o : H.indexOf(c), d && !1 !== (p = new d).init(c, y || r, t, m, H) && (t._pt = a = new bi(t._pt, c, p.name, 0, 1, p.render, p, 0, p.priority), p._props.forEach((function (e) {
                            f[e] = a
                        })), p.priority && (u = 1)), !d || y)
                        for (s in r) vt[s] && (p = Qt(s, r, t, m, c, H)) ? p.priority && (u = 1) : f[s] = a = ei.call(t, c, s, "get", r[s], m, H, 0, x.stringFilter);
                    t._op && t._op[o] && t.kill(c, t._op[o]), U && t._pt && (Kt = t, xe.killTweensOf(c, f, t.globalTime(i)), b = !t.parent, Kt = 0), t._pt && S && (gt[h.id] = 1)
                }
                u && yi(t), t._onInit && t._onInit(t)
            }
            t._onUpdate = T, t._initted = (!t._op || t._pt) && !b, R && i <= 0 && j.render(Xe, !0, !0)
        },
        ii = function (e, t, i, o, s) {
            return r(e) ? e.call(t, i, o, s) : n(e) && ~e.indexOf("random(") ? re(e) : e
        },
        ni = wt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
        ri = {};
    b(ni + ",id,stagger,delay,duration,paused,scrollTrigger", (function (e) {
        return ri[e] = 1
    }));
    var oi = function (e) {
        function r(t, n, r, s) {
            var c;
            "number" == typeof n && (r.duration = n, n = r, r = null);
            var h, d, f, m, v, y, b, x, _ = (c = e.call(this, s ? n : I(n)) || this).vars,
                E = _.duration,
                M = _.delay,
                S = _.immediateRender,
                T = _.stagger,
                A = _.overwrite,
                L = _.keyframes,
                O = _.defaults,
                R = _.scrollTrigger,
                D = _.yoyoEase,
                k = n.parent || xe,
                z = (it(t) || tt(t) ? o(t[0]) : "length" in n) ? [t] : Lt(t);
            if (c._targets = z.length ? g(z) : p("GSAP target " + t + " not found. https://greensock.com", !We.nullTargetWarn) || [], c._ptLookup = [], c._overwrite = A, L || T || u(E) || u(M)) {
                if (n = c.vars, (h = c.timeline = new Zt({
                        data: "nested",
                        defaults: O || {},
                        targets: k && "nested" === k.data ? k.vars.targets : z
                    })).kill(), h.parent = h._dp = i(c), h._start = 0, T || u(E) || u(M)) {
                    if (m = z.length, b = T && $(T), a(T))
                        for (v in T) ~ni.indexOf(v) && ((x = x || {})[v] = T[v]);
                    for (d = 0; d < m; d++)(f = P(n, ri)).stagger = 0, D && (f.yoyoEase = D), x && _t(f, x), y = z[d], f.duration = +ii(E, i(c), d, y, z), f.delay = (+ii(M, i(c), d, y, z) || 0) - c._delay, !T && 1 === m && f.delay && (c._delay = M = f.delay, c._start += M, f.delay = 0), h.to(y, f, b ? b(d, y, z) : 0), h._ease = Nt.none;
                    h.duration() ? E = M = 0 : c.timeline = 0
                } else if (L) {
                    I(C(h.vars.defaults, {
                        ease: "none"
                    })), h._ease = jt(L.ease || n.ease || "none");
                    var B, N, F, H = 0;
                    if (it(L)) L.forEach((function (e) {
                        return h.to(z, e, ">")
                    })), h.duration();
                    else {
                        for (v in f = {}, L) "ease" === v || "easeEach" === v || Jt(v, L[v], f, L.easeEach);
                        for (v in f)
                            for (B = f[v].sort((function (e, t) {
                                    return e.t - t.t
                                })), d = H = 0; d < B.length; d++)(F = {
                                ease: (N = B[d]).e,
                                duration: (N.t - (d ? B[d - 1].t : 0)) / 100 * E
                            })[v] = N.v, h.to(z, F, H), H += F.duration;
                        h.duration() < E && h.to({}, {
                            duration: E - h.duration()
                        })
                    }
                }
                E || c.duration(E = h.duration())
            } else c.timeline = 0;
            return !0 !== A || ve || (Kt = i(c), xe.killTweensOf(z), Kt = 0), j(k, i(c), r), n.reversed && c.reverse(), n.paused && c.paused(!0), (S || !E && !L && c._start === w(k._time) && l(S) && function e(t) {
                return !t || t._ts && e(t.parent)
            }(i(c)) && "nested" !== k.data) && (c._tTime = -Ye, c.render(Math.max(0, -M) || 0)), R && G(i(c), R), c
        }
        t(r, e);
        var s = r.prototype;
        return s.render = function (e, t, i) {
            var n, r, o, s, a, l, c, u, h, d = this._time,
                p = this._tDur,
                f = this._dur,
                m = e < 0,
                g = p - Ye < e && !m ? p : e < Ye ? 0 : e;
            if (f) {
                if (g !== this._tTime || !e || i || !this._initted && this._tTime || this._startAt && this._zTime < 0 != m) {
                    if (n = g, u = this.timeline, this._repeat) {
                        if (s = f + this._rDelay, this._repeat < -1 && m) return this.totalTime(100 * s + e, t, i);
                        if (n = w(g % s), g === p ? (o = this._repeat, n = f) : ((o = ~~(g / s)) && o === g / s && (n = f, o--), f < n && (n = f)), (l = this._yoyo && 1 & o) && (h = this._yEase, n = f - n), a = Et(this._tTime, s), n === d && !i && this._initted) return this._tTime = g, this;
                        o !== a && (u && this._yEase && de(u, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = i = 1, this.render(w(s * o), !0).invalidate()._lock = 0))
                    }
                    if (!this._initted) {
                        if (V(this, m ? e : n, i, t, g)) return this._tTime = 0, this;
                        if (d !== this._time) return this;
                        if (f !== this._dur) return this.render(e, t, i)
                    }
                    if (this._tTime = g, this._time = n, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (h || this._ease)(n / f), this._from && (this.ratio = c = 1 - c), n && !d && !t && (It(this, "onStart"), this._tTime !== g)) return this;
                    for (r = this._pt; r;) r.r(c, r.d), r = r._next;
                    u && u.render(e < 0 ? e : !n && l ? -Ye : u._dur * u._ease(n / this._dur), t, i) || this._startAt && (this._zTime = e), this._onUpdate && !t && (m && z(this, e, 0, i), It(this, "onUpdate")), this._repeat && o !== a && this.vars.onRepeat && !t && this.parent && It(this, "onRepeat"), g !== this._tDur && g || this._tTime !== g || (m && !this._onUpdate && z(this, e, 0, !0), !e && f || !(g === this._tDur && 0 < this._ts || !g && this._ts < 0) || D(this, 1), t || m && !d || !(g || d || l) || (It(this, g === p ? "onComplete" : "onReverseComplete", !0), !this._prom || g < p && 0 < this.timeScale() || this._prom()))
                }
            } else ! function (e, t, i, n) {
                var r, o, s, a = e.ratio,
                    l = t < 0 || !t && (!e._start && function e(t) {
                        var i = t.parent;
                        return i && i._ts && i._initted && !i._lock && (i.rawTime() < 0 || e(i))
                    }(e) && (e._initted || !Mt(e)) || (e._ts < 0 || e._dp._ts < 0) && !Mt(e)) ? 0 : 1,
                    c = e._rDelay,
                    u = 0;
                if (c && e._repeat && (u = At(0, e._tDur, t), o = Et(u, c), e._yoyo && 1 & o && (l = 1 - l), o !== Et(e._tTime, c) && (a = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== a || ye || n || e._zTime === Ye || !t && e._zTime) {
                    if (!e._initted && V(e, t, n, i, u)) return;
                    for (s = e._zTime, e._zTime = t || (i ? Ye : 0), i = i || t && !s, e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = u, r = e._pt; r;) r.r(l, r.d), r = r._next;
                    t < 0 && z(e, t, 0, !0), e._onUpdate && !i && It(e, "onUpdate"), u && e._repeat && !i && e.parent && It(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && D(e, 1), i || ye || (It(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
                } else e._zTime || (e._zTime = t)
            }(this, e, t, i);
            return this
        }, s.targets = function () {
            return this._targets
        }, s.invalidate = function (t) {
            return t && this.vars.runBackwards || (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(t), e.prototype.invalidate.call(this, t)
        }, s.resetTo = function (e, t, i, n) {
            Ce || zt.wake(), this._ts || this.play();
            var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
            return this._initted || ti(this, r),
                function (e, t, i, n, r, o, s) {
                    var a, l, c, u, h = (e._pt && e._ptCache || (e._ptCache = {}))[t];
                    if (!h)
                        for (h = e._ptCache[t] = [], c = e._ptLookup, u = e._targets.length; u--;) {
                            if ((a = c[u][t]) && a.d && a.d._pt)
                                for (a = a.d._pt; a && a.p !== t && a.fp !== t;) a = a._next;
                            if (!a) return $t = 1, e.vars[t] = "+=0", ti(e, s), $t = 0, 1;
                            h.push(a)
                        }
                    for (u = h.length; u--;)(a = (l = h[u])._pt || l).s = !n && 0 !== n || r ? a.s + (n || 0) + o * a.c : n, a.c = i - a.s, l.e && (l.e = x(i) + Z(l.e)), l.b && (l.b = a.s + Z(l.b))
                }(this, e, t, i, n, this._ease(r / this._dur), r) ? this.resetTo(e, t, i, n) : (H(this, 0), this.parent || O(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
        }, s.kill = function (e, t) {
            if (void 0 === t && (t = "all"), !(e || t && "all" !== t)) return this._lazy = this._pt = 0, this.parent ? se(this) : this;
            if (this.timeline) {
                var i = this.timeline.totalDuration();
                return this.timeline.killTweensOf(e, t, Kt && !0 !== Kt.vars.overwrite)._first || se(this), this.parent && i !== this.timeline.totalDuration() && W(this, this._dur * this.timeline._tDur / i, 0, 1), this
            }
            var r, o, s, a, l, c, u, h = this._targets,
                d = e ? Lt(e) : h,
                p = this._ptLookup,
                f = this._pt;
            if ((!t || "all" === t) && function (e, t) {
                    for (var i = e.length, n = i === t.length; n && i-- && e[i] === t[i];);
                    return i < 0
                }(h, d)) return "all" === t && (this._pt = 0), se(this);
            for (r = this._op = this._op || [], "all" !== t && (n(t) && (l = {}, b(t, (function (e) {
                    return l[e] = 1
                })), t = l), t = function (e, t) {
                    var i, n, r, o, s = e[0] ? v(e[0]).harness : 0,
                        a = s && s.aliases;
                    if (!a) return t;
                    for (n in i = _t({}, t), a)
                        if (n in i)
                            for (r = (o = a[n].split(",")).length; r--;) i[o[r]] = i[n];
                    return i
                }(h, t)), u = h.length; u--;)
                if (~d.indexOf(h[u]))
                    for (l in o = p[u], "all" === t ? (r[u] = t, a = o, s = {}) : (s = r[u] = r[u] || {}, a = t), a)(c = o && o[l]) && ("kill" in c.d && !0 !== c.d.kill(l) || R(this, c, "_pt"), delete o[l]), "all" !== s && (s[l] = 1);
            return this._initted && !this._pt && f && se(this), this
        }, r.to = function (e, t, i) {
            return new r(e, t, i)
        }, r.from = function (e, t) {
            return X(1, arguments)
        }, r.delayedCall = function (e, t, i, n) {
            return new r(t, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: e,
                onComplete: t,
                onReverseComplete: t,
                onCompleteParams: i,
                onReverseCompleteParams: i,
                callbackScope: n
            })
        }, r.fromTo = function (e, t, i) {
            return X(2, arguments)
        }, r.set = function (e, t) {
            return t.duration = 0, t.repeatDelay || (t.repeat = 0), new r(e, t)
        }, r.killTweensOf = function (e, t, i) {
            return xe.killTweensOf(e, t, i)
        }, r
    }(Xt);

    function si(e, t, i) {
        return e.setAttribute(t, i)
    }

    function ai(e, t, i, n) {
        n.mSet(e, t, n.m.call(n.tween, i, n.mt), n)
    }
    C(oi.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }), b("staggerTo,staggerFrom,staggerFromTo", (function (e) {
        oi[e] = function () {
            var t = new Zt,
                i = Ct.call(arguments, 0);
            return i.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, i)
        }
    }));
    var li = function (e, t, i) {
            return e[t] = i
        },
        ci = function (e, t, i) {
            return e[t](i)
        },
        ui = function (e, t, i, n) {
            return e[t](n.fp, i)
        },
        hi = function (e, t) {
            return r(e[t]) ? ci : s(e[t]) && e.setAttribute ? si : li
        },
        di = function (e, t) {
            return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t)
        },
        pi = function (e, t) {
            return t.set(t.t, t.p, !!(t.s + t.c * e), t)
        },
        fi = function (e, t) {
            var i = t._pt,
                n = "";
            if (!e && t.b) n = t.b;
            else if (1 === e && t.e) n = t.e;
            else {
                for (; i;) n = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round(1e4 * (i.s + i.c * e)) / 1e4) + n, i = i._next;
                n += t.c
            }
            t.set(t.t, t.p, n, t)
        },
        mi = function (e, t) {
            for (var i = t._pt; i;) i.r(e, i.d), i = i._next
        },
        gi = function (e, t, i, n) {
            for (var r, o = this._pt; o;) r = o._next, o.p === n && o.modifier(e, t, i), o = r
        },
        vi = function (e) {
            for (var t, i, n = this._pt; n;) i = n._next, n.p === e && !n.op || n.op === e ? R(this, n, "_pt") : n.dep || (t = 1), n = i;
            return !t
        },
        yi = function (e) {
            for (var t, i, n, r, o = e._pt; o;) {
                for (t = o._next, i = n; i && i.pr > o.pr;) i = i._next;
                (o._prev = i ? i._prev : r) ? o._prev._next = o: n = o, (o._next = i) ? i._prev = o : r = o, o = t
            }
            e._pt = n
        },
        bi = (xi.prototype.modifier = function (e, t, i) {
            this.mSet = this.mSet || this.set, this.set = ai, this.m = e, this.mt = i, this.tween = t
        }, xi);

    function xi(e, t, i, n, r, o, s, a, l) {
        this.t = t, this.s = n, this.c = r, this.p = i, this.r = o || di, this.d = s || this, this.set = a || li, this.pr = l || 0, (this._next = e) && (e._prev = this)
    }

    function wi(e) {
        return (Si[e] || Ti).map((function (e) {
            return e()
        }))
    }

    function _i() {
        var e = Date.now(),
            t = [];
        2 < e - Ai && (wi("matchMediaInit"), Mi.forEach((function (e) {
            var i, n, r, o, s = e.queries,
                a = e.conditions;
            for (n in s)(i = we.matchMedia(s[n]).matches) && (r = 1), i !== a[n] && (a[n] = i, o = 1);
            o && (e.revert(), r && t.push(e))
        })), wi("matchMediaRevert"), t.forEach((function (e) {
            return e.onMatch(e)
        })), Ai = e, wi("matchMedia"))
    }
    b(wt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (e) {
        return ft[e] = 1
    })), ut.TweenMax = ut.TweenLite = oi, ut.TimelineLite = ut.TimelineMax = Zt, xe = new Zt({
        sortChildren: !1,
        defaults: qe,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }), We.stringFilter = he;
    var Ei, Mi = [],
        Si = {},
        Ti = [],
        Ai = 0,
        Ci = ((Ei = Li.prototype).add = function (e, t, i) {
            function n() {
                var e, n = be,
                    s = o.selector;
                return n && n !== o && n.data.push(o), i && (o.selector = J(i)), be = o, r(e = t.apply(o, arguments)) && o._r.push(e), be = n, o.selector = s, o.isReverted = !1, e
            }
            r(e) && (i = t, t = e, e = r);
            var o = this;
            return o.last = n, e === r ? n(o) : e ? o[e] = n : n
        }, Ei.ignore = function (e) {
            var t = be;
            be = null, e(this), be = t
        }, Ei.getTweens = function () {
            var e = [];
            return this.data.forEach((function (t) {
                return t instanceof Li ? e.push.apply(e, t.getTweens()) : t instanceof oi && !(t.parent && "nested" === t.parent.data) && e.push(t)
            })), e
        }, Ei.clear = function () {
            this._r.length = this.data.length = 0
        }, Ei.kill = function (e, t) {
            var i = this;
            if (e) {
                var n = this.getTweens();
                this.data.forEach((function (e) {
                    "isFlip" === e.data && (e.revert(), e.getChildren(!0, !0, !1).forEach((function (e) {
                        return n.splice(n.indexOf(e), 1)
                    })))
                })), n.map((function (e) {
                    return {
                        g: e.globalTime(0),
                        t: e
                    }
                })).sort((function (e, t) {
                    return t.g - e.g || -1
                })).forEach((function (t) {
                    return t.t.revert(e)
                })), this.data.forEach((function (t) {
                    return !(t instanceof Xt) && t.revert && t.revert(e)
                })), this._r.forEach((function (t) {
                    return t(e, i)
                })), this.isReverted = !0
            } else this.data.forEach((function (e) {
                return e.kill && e.kill()
            }));
            if (this.clear(), t) {
                var r = Mi.indexOf(this);
                ~r && Mi.splice(r, 1)
            }
        }, Ei.revert = function (e) {
            this.kill(e || {})
        }, Li);

    function Li(e, t) {
        this.selector = t && J(t), this.data = [], this._r = [], this.isReverted = !1, e && this.add(e)
    }
    var Pi, Ii = ((Pi = Oi.prototype).add = function (e, t, i) {
        a(e) || (e = {
            matches: e
        });
        var n, r, o, s = new Ci(0, i || this.scope),
            l = s.conditions = {};
        for (r in this.contexts.push(s), t = s.add("onMatch", t), s.queries = e) "all" === r ? o = 1 : (n = we.matchMedia(e[r])) && (Mi.indexOf(s) < 0 && Mi.push(s), (l[r] = n.matches) && (o = 1), n.addListener ? n.addListener(_i) : n.addEventListener("change", _i));
        return o && t(s), this
    }, Pi.revert = function (e) {
        this.kill(e || {})
    }, Pi.kill = function (e) {
        this.contexts.forEach((function (t) {
            return t.kill(e, !0)
        }))
    }, Oi);

    function Oi(e) {
        this.contexts = [], this.scope = e
    }
    var Ri = {
        registerPlugin: function () {
            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
            t.forEach((function (e) {
                return function (e) {
                    var t = (e = !e.name && e.default || e).name,
                        i = r(e),
                        n = t && !i && e.init ? function () {
                            this._props = []
                        } : e,
                        o = {
                            init: m,
                            render: mi,
                            add: ei,
                            kill: vi,
                            modifier: gi,
                            rawVars: 0
                        },
                        s = {
                            targetTest: 0,
                            get: 0,
                            getSetter: hi,
                            aliases: {},
                            register: 0
                        };
                    if (Bt(), e !== n) {
                        if (vt[t]) return;
                        C(n, C(P(e, o), s)), _t(n.prototype, _t(o, P(e, s))), vt[n.prop = t] = n, e.targetTest && (xt.push(n), ft[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                    }
                    f(t, n), e.register && e.register(zi, n, bi)
                }(e)
            }))
        },
        timeline: function (e) {
            return new Zt(e)
        },
        getTweensOf: function (e, t) {
            return xe.getTweensOf(e, t)
        },
        getProperty: function (e, t, i, r) {
            n(e) && (e = Lt(e)[0]);
            var o = v(e || {}).get,
                s = i ? A : T;
            return "native" === i && (i = ""), e ? t ? s((vt[t] && vt[t].get || o)(e, t, i, r)) : function (t, i, n) {
                return s((vt[t] && vt[t].get || o)(e, t, i, n))
            } : e
        },
        quickSetter: function (e, t, i) {
            if (1 < (e = Lt(e)).length) {
                var n = e.map((function (e) {
                        return zi.quickSetter(e, t, i)
                    })),
                    r = n.length;
                return function (e) {
                    for (var t = r; t--;) n[t](e)
                }
            }
            e = e[0] || {};
            var o = vt[t],
                s = v(e),
                a = s.harness && (s.harness.aliases || {})[t] || t,
                l = o ? function (t) {
                    var n = new o;
                    Ae._pt = 0, n.init(e, i ? t + i : t, Ae, 0, [e]), n.render(1, n), Ae._pt && mi(1, Ae)
                } : s.set(e, a);
            return o ? l : function (t) {
                return l(e, a, i ? t + i : t, s, 1)
            }
        },
        quickTo: function (e, t, i) {
            function n(e, i, n) {
                return o.resetTo(t, e, i, n)
            }
            var r, o = zi.to(e, _t(((r = {})[t] = "+=0.1", r.paused = !0, r), i || {}));
            return n.tween = o, n
        },
        isTweening: function (e) {
            return 0 < xe.getTweensOf(e, !0).length
        },
        defaults: function (e) {
            return e && e.ease && (e.ease = jt(e.ease, qe.ease)), L(qe, e || {})
        },
        config: function (e) {
            return L(We, e || {})
        },
        registerEffect: function (e) {
            var t = e.name,
                i = e.effect,
                n = e.plugins,
                r = e.defaults,
                o = e.extendTimeline;
            (n || "").split(",").forEach((function (e) {
                return e && !vt[e] && !ut[e] && p(t + " effect requires " + e + " plugin.")
            })), yt[t] = function (e, t, n) {
                return i(Lt(e), C(t || {}, r), n)
            }, o && (Zt.prototype[t] = function (e, i, n) {
                return this.add(yt[t](e, a(i) ? i : (n = i) && {}, this), n)
            })
        },
        registerEase: function (e, t) {
            Nt[e] = jt(t)
        },
        parseEase: function (e, t) {
            return arguments.length ? jt(e, t) : Nt
        },
        getById: function (e) {
            return xe.getById(e)
        },
        exportRoot: function (e, t) {
            void 0 === e && (e = {});
            var i, n, r = new Zt(e);
            for (r.smoothChildTiming = l(e.smoothChildTiming), xe.remove(r), r._dp = 0, r._time = r._tTime = xe._time, i = xe._first; i;) n = i._next, !t && !i._dur && i instanceof oi && i.vars.onComplete === i._targets[0] || j(r, i, i._start - i._delay), i = n;
            return j(xe, r, 0), r
        },
        context: function (e, t) {
            return e ? new Ci(e, t) : be
        },
        matchMedia: function (e) {
            return new Ii(e)
        },
        matchMediaRefresh: function () {
            return Mi.forEach((function (e) {
                var t, i, n = e.conditions;
                for (i in n) n[i] && (n[i] = !1, t = 1);
                t && e.revert()
            })) || _i()
        },
        addEventListener: function (e, t) {
            var i = Si[e] || (Si[e] = []);
            ~i.indexOf(t) || i.push(t)
        },
        removeEventListener: function (e, t) {
            var i = Si[e],
                n = i && i.indexOf(t);
            0 <= n && i.splice(n, 1)
        },
        utils: {
            wrap: function e(t, i, n) {
                var r = i - t;
                return it(t) ? ne(t, e(0, t.length), i) : Y(n, (function (e) {
                    return (r + (e - t) % r) % r + t
                }))
            },
            wrapYoyo: function e(t, i, n) {
                var r = i - t,
                    o = 2 * r;
                return it(t) ? ne(t, e(0, t.length - 1), i) : Y(n, (function (e) {
                    return t + (r < (e = (o + (e - t) % o) % o || 0) ? o - e : e)
                }))
            },
            distribute: $,
            random: ie,
            snap: te,
            normalize: function (e, t, i) {
                return Pt(e, t, 0, 1, i)
            },
            getUnit: Z,
            clamp: function (e, t, i) {
                return Y(i, (function (i) {
                    return At(e, t, i)
                }))
            },
            splitColor: le,
            toArray: Lt,
            selector: J,
            mapRange: Pt,
            pipe: function () {
                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                return function (e) {
                    return t.reduce((function (e, t) {
                        return t(e)
                    }), e)
                }
            },
            unitize: function (e, t) {
                return function (i) {
                    return e(parseFloat(i)) + (t || Z(i))
                }
            },
            interpolate: function e(t, i, r, o) {
                var s = isNaN(t + i) ? 0 : function (e) {
                    return (1 - e) * t + e * i
                };
                if (!s) {
                    var a, l, c, u, h, d = n(t),
                        p = {};
                    if (!0 === r && (o = 1) && (r = null), d) t = {
                        p: t
                    }, i = {
                        p: i
                    };
                    else if (it(t) && !it(i)) {
                        for (c = [], u = t.length, h = u - 2, l = 1; l < u; l++) c.push(e(t[l - 1], t[l]));
                        u--, s = function (e) {
                            e *= u;
                            var t = Math.min(h, ~~e);
                            return c[t](e - t)
                        }, r = i
                    } else o || (t = _t(it(t) ? [] : {}, t));
                    if (!c) {
                        for (a in i) ei.call(p, t, a, "get", i[a]);
                        s = function (e) {
                            return mi(e, p) || (d ? t.p : t)
                        }
                    }
                }
                return Y(r, s)
            },
            shuffle: K
        },
        install: h,
        effects: yt,
        ticker: zt,
        updateRoot: Zt.updateRoot,
        plugins: vt,
        globalTimeline: xe,
        core: {
            PropTween: bi,
            globals: f,
            Tween: oi,
            Timeline: Zt,
            Animation: Xt,
            getCache: v,
            _removeLinkedListItem: R,
            reverting: function () {
                return ye
            },
            context: function (e) {
                return e && be && (be.data.push(e), e._ctx = be), be
            },
            suppressOverwrites: function (e) {
                return ve = e
            }
        }
    };

    function Di(e, t) {
        for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t;) i = i._next;
        return i
    }

    function ki(e, t) {
        return {
            name: e,
            rawVars: 1,
            init: function (e, i, r) {
                r._onInit = function (e) {
                    var r, o;
                    if (n(i) && (r = {}, b(i, (function (e) {
                            return r[e] = 1
                        })), i = r), t) {
                        for (o in r = {}, i) r[o] = t(i[o]);
                        i = r
                    }! function (e, t) {
                        var i, n, r, o = e._targets;
                        for (i in t)
                            for (n = o.length; n--;)(r = (r = e._ptLookup[n][i]) && r.d) && (r._pt && (r = Di(r, i)), r && r.modifier && r.modifier(t[i], e, o[n], i))
                    }(e, i)
                }
            }
        }
    }
    b("to,from,fromTo,delayedCall,set,killTweensOf", (function (e) {
        return Ri[e] = oi[e]
    })), zt.add(Zt.updateRoot), Ae = Ri.to({}, {
        duration: 0
    });
    var zi = Ri.registerPlugin({
        name: "attr",
        init: function (e, t, i, n, r) {
            var o, s, a;
            for (o in this.tween = i, t) a = e.getAttribute(o) || "", (s = this.add(e, "setAttribute", (a || 0) + "", t[o], n, r, 0, 0, o)).op = o, s.b = a, this._props.push(o)
        },
        render: function (e, t) {
            for (var i = t._pt; i;) ye ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), i = i._next
        }
    }, {
        name: "endArray",
        init: function (e, t) {
            for (var i = t.length; i--;) this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1)
        }
    }, ki("roundProps", ee), ki("modifiers"), ki("snap", te)) || Ri;

    function Bi(e, t) {
        return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
    }

    function Ni(e, t) {
        return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
    }

    function Fi(e, t) {
        return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t)
    }

    function Hi(e, t) {
        var i = t.s + t.c * e;
        t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t)
    }

    function Ui(e, t) {
        return t.set(t.t, t.p, e ? t.e : t.b, t)
    }

    function ji(e, t) {
        return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
    }

    function Gi(e, t, i) {
        return e.style[t] = i
    }

    function Vi(e, t, i) {
        return e.style.setProperty(t, i)
    }

    function Wi(e, t, i) {
        return e._gsap[t] = i
    }

    function qi(e, t, i) {
        return e._gsap.scaleX = e._gsap.scaleY = i
    }

    function Xi(e, t, i, n, r) {
        var o = e._gsap;
        o.scaleX = o.scaleY = i, o.renderTransform(r, o)
    }

    function Yi(e, t, i, n, r) {
        var o = e._gsap;
        o[t] = i, o.renderTransform(r, o)
    }

    function Zi(e, t) {
        var i = this,
            n = this.target,
            r = n.style;
        if (e in Xn) {
            if (this.tfm = this.tfm || {}, "transform" !== e && (~(e = er[e] || e).indexOf(",") ? e.split(",").forEach((function (e) {
                    return i.tfm[e] = ar(n, e)
                })) : this.tfm[e] = n._gsap.x ? n._gsap[e] : ar(n, e)), 0 <= this.props.indexOf(tr)) return;
            n._gsap.svg && (this.svgo = n.getAttribute("data-svg-origin"), this.props.push(ir, t, "")), e = tr
        }(r || t) && this.props.push(e, t, r[e])
    }

    function Qi(e) {
        e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"))
    }

    function Ji() {
        var e, t, i = this.props,
            n = this.target,
            r = n.style,
            o = n._gsap;
        for (e = 0; e < i.length; e += 3) i[e + 1] ? n[i[e]] = i[e + 2] : i[e + 2] ? r[i[e]] = i[e + 2] : r.removeProperty(i[e].replace(Jn, "-$1").toLowerCase());
        if (this.tfm) {
            for (t in this.tfm) o[t] = this.tfm[t];
            o.svg && (o.renderTransform(), n.setAttribute("data-svg-origin", this.svgo || "")), !(e = An()) || e.isStart || r[tr] || (Qi(r), o.uncache = 1)
        }
    }

    function Ki(e, t) {
        var i = {
            target: e,
            props: [],
            revert: Ji,
            save: Zi
        };
        return t && t.split(",").forEach((function (e) {
            return i.save(e)
        })), i
    }

    function $i(e, t) {
        var i = _n.createElementNS ? _n.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : _n.createElement(e);
        return i.style ? i : _n.createElement(e)
    }

    function en(e, t, i) {
        var n = getComputedStyle(e);
        return n[t] || n.getPropertyValue(t.replace(Jn, "-$1").toLowerCase()) || n.getPropertyValue(t) || !i && en(e, rr(t) || t, 1) || ""
    }

    function tn() {
        "undefined" != typeof window && window.document && (wn = window, _n = wn.document, En = _n.documentElement, Sn = $i("div") || {
            style: {}
        }, $i("div"), tr = rr(tr), ir = tr + "Origin", Sn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Cn = !!rr("perspective"), An = zi.core.reverting, Mn = 1)
    }

    function nn(e) {
        var t, i = $i("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
            n = this.parentNode,
            r = this.nextSibling,
            o = this.style.cssText;
        if (En.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
            t = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = nn
        } catch (e) {} else this._gsapBBox && (t = this._gsapBBox());
        return n && (r ? n.insertBefore(this, r) : n.appendChild(this)), En.removeChild(i), this.style.cssText = o, t
    }

    function rn(e, t) {
        for (var i = t.length; i--;)
            if (e.hasAttribute(t[i])) return e.getAttribute(t[i])
    }

    function on(e) {
        var t;
        try {
            t = e.getBBox()
        } catch (i) {
            t = nn.call(e, !0)
        }
        return t && (t.width || t.height) || e.getBBox === nn || (t = nn.call(e, !0)), !t || t.width || t.x || t.y ? t : {
            x: +rn(e, ["x", "cx", "x1"]) || 0,
            y: +rn(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        }
    }

    function sn(e) {
        return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !on(e))
    }

    function an(e, t) {
        if (t) {
            var i = e.style;
            t in Xn && t !== ir && (t = tr), i.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), i.removeProperty(t.replace(Jn, "-$1").toLowerCase())) : i.removeAttribute(t)
        }
    }

    function ln(e, t, i, n, r, o) {
        var s = new bi(e._pt, t, i, 0, 1, o ? ji : Ui);
        return (e._pt = s).b = n, s.e = r, e._props.push(i), s
    }

    function cn(e, t, i, n) {
        var r, o, s, a, l = parseFloat(i) || 0,
            c = (i + "").trim().substr((l + "").length) || "px",
            u = Sn.style,
            h = Kn.test(t),
            d = "svg" === e.tagName.toLowerCase(),
            p = (d ? "client" : "offset") + (h ? "Width" : "Height"),
            f = "px" === n,
            m = "%" === n;
        return n === c || !l || or[n] || or[c] ? l : ("px" === c || f || (l = cn(e, t, i, "px")), a = e.getCTM && sn(e), !m && "%" !== c || !Xn[t] && !~t.indexOf("adius") ? (u[h ? "width" : "height"] = 100 + (f ? c : n), o = ~t.indexOf("adius") || "em" === n && e.appendChild && !d ? e : e.parentNode, a && (o = (e.ownerSVGElement || {}).parentNode), o && o !== _n && o.appendChild || (o = _n.body), (s = o._gsap) && m && s.width && h && s.time === zt.time && !s.uncache ? x(l / s.width * 100) : (!m && "%" !== c || sr[en(o, "display")] || (u.position = en(e, "position")), o === e && (u.position = "static"), o.appendChild(Sn), r = Sn[p], o.removeChild(Sn), u.position = "absolute", h && m && ((s = v(o)).time = zt.time, s.width = o[p]), x(f ? r * l / 100 : r && l ? 100 / r * l : 0))) : (r = a ? e.getBBox()[h ? "width" : "height"] : e[p], x(m ? l / r * 100 : l / 100 * r)))
    }

    function un(e, t, i, n) {
        if (!i || "none" === i) {
            var r = rr(t, e, 1),
                o = r && en(e, r, 1);
            o && o !== i ? (t = r, i = o) : "borderColor" === t && (i = en(e, "borderTopColor"))
        }
        var s, a, l, c, u, h, d, p, f, m, g, v = new bi(this._pt, e.style, t, 0, 1, fi),
            y = 0,
            b = 0;
        if (v.b = i, v.e = n, i += "", "auto" == (n += "") && (e.style[t] = n, n = en(e, t) || n, e.style[t] = i), he(s = [i, n]), n = s[1], l = (i = s[0]).match(ot) || [], (n.match(ot) || []).length) {
            for (; a = ot.exec(n);) d = a[0], f = n.substring(y, a.index), u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1), d !== (h = l[b++] || "") && (c = parseFloat(h) || 0, g = h.substr((c + "").length), "=" === d.charAt(1) && (d = _(c, d) + g), p = parseFloat(d), m = d.substr((p + "").length), y = ot.lastIndex - m.length, m || (m = m || We.units[t] || g, y === n.length && (n += m, v.e += m)), g !== m && (c = cn(e, t, h, m) || 0), v._pt = {
                _next: v._pt,
                p: f || 1 === b ? f : ",",
                s: c,
                c: p - c,
                m: u && u < 4 || "zIndex" === t ? Math.round : 0
            });
            v.c = y < n.length ? n.substring(y, n.length) : ""
        } else v.r = "display" === t && "none" === n ? ji : Ui;
        return at.test(n) && (v.e = 0), this._pt = v
    }

    function hn(e) {
        var t = e.split(" "),
            i = t[0],
            n = t[1] || "50%";
        return "top" !== i && "bottom" !== i && "left" !== n && "right" !== n || (e = i, i = n, n = e), t[0] = lr[i] || i, t[1] = lr[n] || n, t.join(" ")
    }

    function dn(e, t) {
        if (t.tween && t.tween._time === t.tween._dur) {
            var i, n, r, o = t.t,
                s = o.style,
                a = t.u,
                l = o._gsap;
            if ("all" === a || !0 === a) s.cssText = "", n = 1;
            else
                for (r = (a = a.split(",")).length; - 1 < --r;) i = a[r], Xn[i] && (n = 1, i = "transformOrigin" === i ? ir : tr), an(o, i);
            n && (an(o, tr), l && (l.svg && o.removeAttribute("transform"), dr(o, 1), l.uncache = 1, Qi(s)))
        }
    }

    function pn(e) {
        return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
    }

    function fn(e) {
        var t = en(e, tr);
        return pn(t) ? ur : t.substr(7).match(rt).map(x)
    }

    function mn(e, t) {
        var i, n, r, o, s = e._gsap || v(e),
            a = e.style,
            l = fn(e);
        return s.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? ur : l : (l !== ur || e.offsetParent || e === En || s.svg || (r = a.display, a.display = "block", (i = e.parentNode) && e.offsetParent || (o = 1, n = e.nextElementSibling, En.appendChild(e)), l = fn(e), r ? a.display = r : an(e, "display"), o && (n ? i.insertBefore(e, n) : i ? i.appendChild(e) : En.removeChild(e))), t && 6 < l.length ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
    }

    function gn(e, t, i, n, r, o) {
        var s, a, l, c = e._gsap,
            u = r || mn(e, !0),
            h = c.xOrigin || 0,
            d = c.yOrigin || 0,
            p = c.xOffset || 0,
            f = c.yOffset || 0,
            m = u[0],
            g = u[1],
            v = u[2],
            y = u[3],
            b = u[4],
            x = u[5],
            w = t.split(" "),
            _ = parseFloat(w[0]) || 0,
            E = parseFloat(w[1]) || 0;
        i ? u !== ur && (a = m * y - g * v) && (l = _ * (-g / a) + E * (m / a) - (m * x - g * b) / a, _ = _ * (y / a) + E * (-v / a) + (v * x - y * b) / a, E = l) : (_ = (s = on(e)).x + (~w[0].indexOf("%") ? _ / 100 * s.width : _), E = s.y + (~(w[1] || w[0]).indexOf("%") ? E / 100 * s.height : E)), n || !1 !== n && c.smooth ? (b = _ - h, x = E - d, c.xOffset = p + (b * m + x * v) - b, c.yOffset = f + (b * g + x * y) - x) : c.xOffset = c.yOffset = 0, c.xOrigin = _, c.yOrigin = E, c.smooth = !!n, c.origin = t, c.originIsAbsolute = !!i, e.style[ir] = "0px 0px", o && (ln(o, c, "xOrigin", h, _), ln(o, c, "yOrigin", d, E), ln(o, c, "xOffset", p, c.xOffset), ln(o, c, "yOffset", f, c.yOffset)), e.setAttribute("data-svg-origin", _ + " " + E)
    }

    function vn(e, t, i) {
        var n = Z(t);
        return x(parseFloat(t) + parseFloat(cn(e, "x", i + "px", n))) + n
    }

    function yn(e, t, i, r, o) {
        var s, a, l = 360,
            c = n(o),
            u = parseFloat(o) * (c && ~o.indexOf("rad") ? Yn : 1) - r,
            h = r + u + "deg";
        return c && ("short" === (s = o.split("_")[1]) && (u %= l) != u % 180 && (u += u < 0 ? l : -l), "cw" === s && u < 0 ? u = (u + 36e9) % l - ~~(u / l) * l : "ccw" === s && 0 < u && (u = (u - 36e9) % l - ~~(u / l) * l)), e._pt = a = new bi(e._pt, t, i, r, u, Ni), a.e = h, a.u = "deg", e._props.push(i), a
    }

    function bn(e, t) {
        for (var i in t) e[i] = t[i];
        return e
    }

    function xn(e, t, i) {
        var n, r, o, s, a, l, c, u = bn({}, i._gsap),
            h = i.style;
        for (r in u.svg ? (o = i.getAttribute("transform"), i.setAttribute("transform", ""), h[tr] = t, n = dr(i, 1), an(i, tr), i.setAttribute("transform", o)) : (o = getComputedStyle(i)[tr], h[tr] = t, n = dr(i, 1), h[tr] = o), Xn)(o = u[r]) !== (s = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = Z(o) !== (c = Z(s)) ? cn(i, r, o, c) : parseFloat(o), l = parseFloat(s), e._pt = new bi(e._pt, n, r, a, l - a, Bi), e._pt.u = c || 0, e._props.push(r));
        bn(n, u)
    }
    oi.version = Zt.version = zi.version = "3.11.4", Se = 1, c() && Bt();
    var wn, _n, En, Mn, Sn, Tn, An, Cn, Ln = Nt.Power0,
        Pn = Nt.Power1,
        In = Nt.Power2,
        On = Nt.Power3,
        Rn = Nt.Power4,
        Dn = Nt.Linear,
        kn = Nt.Quad,
        zn = Nt.Cubic,
        Bn = Nt.Quart,
        Nn = Nt.Quint,
        Fn = Nt.Strong,
        Hn = Nt.Elastic,
        Un = Nt.Back,
        jn = Nt.SteppedEase,
        Gn = Nt.Bounce,
        Vn = Nt.Sine,
        Wn = Nt.Expo,
        qn = Nt.Circ,
        Xn = {},
        Yn = 180 / Math.PI,
        Zn = Math.PI / 180,
        Qn = Math.atan2,
        Jn = /([A-Z])/g,
        Kn = /(left|right|width|margin|padding|x)/i,
        $n = /[\s,\(]\S/,
        er = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        },
        tr = "transform",
        ir = tr + "Origin",
        nr = "O,Moz,ms,Ms,Webkit".split(","),
        rr = function (e, t, i) {
            var n = (t || Sn).style,
                r = 5;
            if (e in n && !i) return e;
            for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(nr[r] + e in n););
            return r < 0 ? null : (3 === r ? "ms" : 0 <= r ? nr[r] : "") + e
        },
        or = {
            deg: 1,
            rad: 1,
            turn: 1
        },
        sr = {
            grid: 1,
            flex: 1
        },
        ar = function (e, t, i, n) {
            var r;
            return Mn || tn(), t in er && "transform" !== t && ~(t = er[t]).indexOf(",") && (t = t.split(",")[0]), Xn[t] && "transform" !== t ? (r = dr(e, n), r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : pr(en(e, ir)) + " " + r.zOrigin + "px") : (r = e.style[t]) && "auto" !== r && !n && !~(r + "").indexOf("calc(") || (r = cr[t] && cr[t](e, t, i) || en(e, t) || y(e, t) || ("opacity" === t ? 1 : 0)), i && !~(r + "").trim().indexOf(" ") ? cn(e, t, r, i) + i : r
        },
        lr = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        },
        cr = {
            clearProps: function (e, t, i, n, r) {
                if ("isFromStart" !== r.data) {
                    var o = e._pt = new bi(e._pt, t, i, 0, 0, dn);
                    return o.u = n, o.pr = -10, o.tween = r, e._props.push(i), 1
                }
            }
        },
        ur = [1, 0, 0, 1, 0, 0],
        hr = {},
        dr = function (e, t) {
            var i = e._gsap || new qt(e);
            if ("x" in i && !t && !i.uncache) return i;
            var n, r, o, s, a, l, c, u, h, d, p, f, m, g, v, y, b, w, _, E, M, S, T, A, C, L, P, I, O, R, D, k, z = e.style,
                B = i.scaleX < 0,
                N = "deg",
                F = getComputedStyle(e),
                H = en(e, ir) || "0";
            return n = r = o = l = c = u = h = d = p = 0, s = a = 1, i.svg = !(!e.getCTM || !sn(e)), F.translate && ("none" === F.translate && "none" === F.scale && "none" === F.rotate || (z[tr] = ("none" !== F.translate ? "translate3d(" + (F.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== F.rotate ? "rotate(" + F.rotate + ") " : "") + ("none" !== F.scale ? "scale(" + F.scale.split(" ").join(",") + ") " : "") + ("none" !== F[tr] ? F[tr] : "")), z.scale = z.rotate = z.translate = "none"), g = mn(e, i.svg), i.svg && (A = i.uncache ? (C = e.getBBox(), H = i.xOrigin - C.x + "px " + (i.yOrigin - C.y) + "px", "") : !t && e.getAttribute("data-svg-origin"), gn(e, A || H, !!A || i.originIsAbsolute, !1 !== i.smooth, g)), f = i.xOrigin || 0, m = i.yOrigin || 0, g !== ur && (w = g[0], _ = g[1], E = g[2], M = g[3], n = S = g[4], r = T = g[5], 6 === g.length ? (s = Math.sqrt(w * w + _ * _), a = Math.sqrt(M * M + E * E), l = w || _ ? Qn(_, w) * Yn : 0, (h = E || M ? Qn(E, M) * Yn + l : 0) && (a *= Math.abs(Math.cos(h * Zn))), i.svg && (n -= f - (f * w + m * E), r -= m - (f * _ + m * M))) : (k = g[6], R = g[7], P = g[8], I = g[9], O = g[10], D = g[11], n = g[12], r = g[13], o = g[14], c = (v = Qn(k, O)) * Yn, v && (A = S * (y = Math.cos(-v)) + P * (b = Math.sin(-v)), C = T * y + I * b, L = k * y + O * b, P = S * -b + P * y, I = T * -b + I * y, O = k * -b + O * y, D = R * -b + D * y, S = A, T = C, k = L), u = (v = Qn(-E, O)) * Yn, v && (y = Math.cos(-v), D = M * (b = Math.sin(-v)) + D * y, w = A = w * y - P * b, _ = C = _ * y - I * b, E = L = E * y - O * b), l = (v = Qn(_, w)) * Yn, v && (A = w * (y = Math.cos(v)) + _ * (b = Math.sin(v)), C = S * y + T * b, _ = _ * y - w * b, T = T * y - S * b, w = A, S = C), c && 359.9 < Math.abs(c) + Math.abs(l) && (c = l = 0, u = 180 - u), s = x(Math.sqrt(w * w + _ * _ + E * E)), a = x(Math.sqrt(T * T + k * k)), v = Qn(S, T), h = 2e-4 < Math.abs(v) ? v * Yn : 0, p = D ? 1 / (D < 0 ? -D : D) : 0), i.svg && (A = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !pn(en(e, tr)), A && e.setAttribute("transform", A))), 90 < Math.abs(h) && Math.abs(h) < 270 && (B ? (s *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (a *= -1, h += h <= 0 ? 180 : -180)), t = t || i.uncache, i.x = n - ((i.xPercent = n && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-n) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + "px", i.y = r - ((i.yPercent = r && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + "px", i.z = o + "px", i.scaleX = x(s), i.scaleY = x(a), i.rotation = x(l) + N, i.rotationX = x(c) + N, i.rotationY = x(u) + N, i.skewX = h + N, i.skewY = d + N, i.transformPerspective = p + "px", (i.zOrigin = parseFloat(H.split(" ")[2]) || 0) && (z[ir] = pr(H)), i.xOffset = i.yOffset = 0, i.force3D = We.force3D, i.renderTransform = i.svg ? br : Cn ? yr : fr, i.uncache = 0, i
        },
        pr = function (e) {
            return (e = e.split(" "))[0] + " " + e[1]
        },
        fr = function (e, t) {
            t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, yr(e, t)
        },
        mr = "0deg",
        gr = "0px",
        vr = ") ",
        yr = function (e, t) {
            var i = t || this,
                n = i.xPercent,
                r = i.yPercent,
                o = i.x,
                s = i.y,
                a = i.z,
                l = i.rotation,
                c = i.rotationY,
                u = i.rotationX,
                h = i.skewX,
                d = i.skewY,
                p = i.scaleX,
                f = i.scaleY,
                m = i.transformPerspective,
                g = i.force3D,
                v = i.target,
                y = i.zOrigin,
                b = "",
                x = "auto" === g && e && 1 !== e || !0 === g;
            if (y && (u !== mr || c !== mr)) {
                var w, _ = parseFloat(c) * Zn,
                    E = Math.sin(_),
                    M = Math.cos(_);
                _ = parseFloat(u) * Zn, o = vn(v, o, E * (w = Math.cos(_)) * -y), s = vn(v, s, -Math.sin(_) * -y), a = vn(v, a, M * w * -y + y)
            }
            m !== gr && (b += "perspective(" + m + vr), (n || r) && (b += "translate(" + n + "%, " + r + "%) "), !x && o === gr && s === gr && a === gr || (b += a !== gr || x ? "translate3d(" + o + ", " + s + ", " + a + ") " : "translate(" + o + ", " + s + vr), l !== mr && (b += "rotate(" + l + vr), c !== mr && (b += "rotateY(" + c + vr), u !== mr && (b += "rotateX(" + u + vr), h === mr && d === mr || (b += "skew(" + h + ", " + d + vr), 1 === p && 1 === f || (b += "scale(" + p + ", " + f + vr), v.style[tr] = b || "translate(0, 0)"
        },
        br = function (e, t) {
            var i, n, r, o, s, a = t || this,
                l = a.xPercent,
                c = a.yPercent,
                u = a.x,
                h = a.y,
                d = a.rotation,
                p = a.skewX,
                f = a.skewY,
                m = a.scaleX,
                g = a.scaleY,
                v = a.target,
                y = a.xOrigin,
                b = a.yOrigin,
                w = a.xOffset,
                _ = a.yOffset,
                E = a.forceCSS,
                M = parseFloat(u),
                S = parseFloat(h);
            d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= Zn, p *= Zn, i = Math.cos(d) * m, n = Math.sin(d) * m, r = Math.sin(d - p) * -g, o = Math.cos(d - p) * g, p && (f *= Zn, s = Math.tan(p - f), r *= s = Math.sqrt(1 + s * s), o *= s, f && (s = Math.tan(f), i *= s = Math.sqrt(1 + s * s), n *= s)), i = x(i), n = x(n), r = x(r), o = x(o)) : (i = m, o = g, n = r = 0), (M && !~(u + "").indexOf("px") || S && !~(h + "").indexOf("px")) && (M = cn(v, "x", u, "px"), S = cn(v, "y", h, "px")), (y || b || w || _) && (M = x(M + y - (y * i + b * r) + w), S = x(S + b - (y * n + b * o) + _)), (l || c) && (M = x(M + l / 100 * (s = v.getBBox()).width), S = x(S + c / 100 * s.height)), s = "matrix(" + i + "," + n + "," + r + "," + o + "," + M + "," + S + ")", v.setAttribute("transform", s), E && (v.style[tr] = s)
        };
    b("padding,margin,Width,Radius", (function (e, t) {
        var i = "Right",
            n = "Bottom",
            r = "Left",
            o = (t < 3 ? ["Top", i, n, r] : ["Top" + r, "Top" + i, n + i, n + r]).map((function (i) {
                return t < 2 ? e + i : "border" + i + e
            }));
        cr[1 < t ? "border" + e : e] = function (e, t, i, n, r) {
            var s, a;
            if (arguments.length < 4) return s = o.map((function (t) {
                return ar(e, t, i)
            })), 5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a;
            s = (n + "").split(" "), a = {}, o.forEach((function (e, t) {
                return a[e] = s[t] = s[t] || s[(t - 1) / 2 | 0]
            })), e.init(t, a, r)
        }
    }));
    var xr, wr, _r = {
        name: "css",
        register: tn,
        targetTest: function (e) {
            return e.style && e.nodeType
        },
        init: function (e, t, i, r, o) {
            var s, a, l, c, u, h, p, f, m, g, v, y, b, x, w, E, M = this._props,
                S = e.style,
                T = i.vars.startAt;
            for (p in Mn || tn(), this.styles = this.styles || Ki(e), E = this.styles.props, this.tween = i, t)
                if ("autoRound" !== p && (a = t[p], !vt[p] || !Qt(p, t, i, r, e, o)))
                    if (u = typeof a, h = cr[p], "function" === u && (u = typeof (a = a.call(i, r, e, o))), "string" === u && ~a.indexOf("random(") && (a = re(a)), h) h(this, e, p, a, i) && (w = 1);
                    else if ("--" === p.substr(0, 2)) s = (getComputedStyle(e).getPropertyValue(p) + "").trim(), a += "", Dt.lastIndex = 0, Dt.test(s) || (f = Z(s), m = Z(a)), m ? f !== m && (s = cn(e, p, s, m) + m) : f && (a += f), this.add(S, "setProperty", s, a, r, o, 0, 0, p), M.push(p), E.push(p, 0, S[p]);
            else if ("undefined" !== u) {
                if (T && p in T ? (n(s = "function" == typeof T[p] ? T[p].call(i, r, e, o) : T[p]) && ~s.indexOf("random(") && (s = re(s)), Z(s + "") || (s += We.units[p] || Z(ar(e, p)) || ""), "=" === (s + "").charAt(1) && (s = ar(e, p))) : s = ar(e, p), c = parseFloat(s), (g = "string" === u && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)), l = parseFloat(a), p in er && ("autoAlpha" === p && (1 === c && "hidden" === ar(e, "visibility") && l && (c = 0), E.push("visibility", 0, S.visibility), ln(this, S, "visibility", c ? "inherit" : "hidden", l ? "inherit" : "hidden", !l)), "scale" !== p && "transform" !== p && ~(p = er[p]).indexOf(",") && (p = p.split(",")[0])), v = p in Xn)
                    if (this.styles.save(p), y || ((b = e._gsap).renderTransform && !t.parseTransform || dr(e, t.parseTransform), x = !1 !== t.smoothOrigin && b.smooth, (y = this._pt = new bi(this._pt, S, tr, 0, 1, b.renderTransform, b, 0, -1)).dep = 1), "scale" === p) this._pt = new bi(this._pt, b, "scaleY", b.scaleY, (g ? _(b.scaleY, g + l) : l) - b.scaleY || 0, Bi), this._pt.u = 0, M.push("scaleY", p), p += "X";
                    else {
                        if ("transformOrigin" === p) {
                            E.push(ir, 0, S[ir]), a = hn(a), b.svg ? gn(e, a, 0, x, 0, this) : ((m = parseFloat(a.split(" ")[2]) || 0) !== b.zOrigin && ln(this, b, "zOrigin", b.zOrigin, m), ln(this, S, p, pr(s), pr(a)));
                            continue
                        }
                        if ("svgOrigin" === p) {
                            gn(e, a, 1, x, 0, this);
                            continue
                        }
                        if (p in hr) {
                            yn(this, b, p, c, g ? _(c, g + a) : a);
                            continue
                        }
                        if ("smoothOrigin" === p) {
                            ln(this, b, "smooth", b.smooth, a);
                            continue
                        }
                        if ("force3D" === p) {
                            b[p] = a;
                            continue
                        }
                        if ("transform" === p) {
                            xn(this, a, e);
                            continue
                        }
                    }
                else p in S || (p = rr(p) || p);
                if (v || (l || 0 === l) && (c || 0 === c) && !$n.test(a) && p in S) l = l || 0, (f = (s + "").substr((c + "").length)) !== (m = Z(a) || (p in We.units ? We.units[p] : f)) && (c = cn(e, p, s, m)), this._pt = new bi(this._pt, v ? b : S, p, c, (g ? _(c, g + l) : l) - c, v || "px" !== m && "zIndex" !== p || !1 === t.autoRound ? Bi : Hi), this._pt.u = m || 0, f !== m && "%" !== m && (this._pt.b = s, this._pt.r = Fi);
                else if (p in S) un.call(this, e, p, s, g ? g + a : a);
                else if (p in e) this.add(e, p, s || e[p], g ? g + a : a, r, o);
                else if ("parseTransform" !== p) {
                    d(p, a);
                    continue
                }
                v || (p in S ? E.push(p, 0, S[p]) : E.push(p, 1, s || e[p])), M.push(p)
            }
            w && yi(this)
        },
        render: function (e, t) {
            if (t.tween._time || !An())
                for (var i = t._pt; i;) i.r(e, i.d), i = i._next;
            else t.styles.revert()
        },
        get: ar,
        aliases: er,
        getSetter: function (e, t, i) {
            var n = er[t];
            return n && n.indexOf(",") < 0 && (t = n), t in Xn && t !== ir && (e._gsap.x || ar(e, "x")) ? i && Tn === i ? "scale" === t ? qi : Wi : (Tn = i || {}) && ("scale" === t ? Xi : Yi) : e.style && !s(e.style[t]) ? Gi : ~t.indexOf("-") ? Vi : hi(e, t)
        },
        core: {
            _removeProperty: an,
            _getMatrix: mn
        }
    };
    zi.utils.checkPrefix = rr, zi.core.getStyleSaver = Ki, wr = b("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + (xr = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (e) {
        Xn[e] = 1
    })), b(xr, (function (e) {
        We.units[e] = "deg", hr[e] = 1
    })), er[wr[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + xr, b("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (e) {
        var t = e.split(":");
        er[t[1]] = wr[t[0]]
    })), b("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (e) {
        We.units[e] = "px"
    })), zi.registerPlugin(_r);
    var Er = zi.registerPlugin(_r) || zi,
        Mr = Er.core.Tween;
    e.Back = Un, e.Bounce = Gn, e.CSSPlugin = _r, e.Circ = qn, e.Cubic = zn, e.Elastic = Hn, e.Expo = Wn, e.Linear = Dn, e.Power0 = Ln, e.Power1 = Pn, e.Power2 = In, e.Power3 = On, e.Power4 = Rn, e.Quad = kn, e.Quart = Bn, e.Quint = Nn, e.Sine = Vn, e.SteppedEase = jn, e.Strong = Fn, e.TimelineLite = Zt, e.TimelineMax = Zt, e.TweenLite = oi, e.TweenMax = Mr, e.default = Er, e.gsap = Er, "undefined" == typeof window || window !== e ? Object.defineProperty(e, "__esModule", {
        value: !0
    }) : delete e.default
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" == typeof module && module.exports ? module.exports = t() : e.EvEmitter = t()
}("undefined" != typeof window ? window : this, (function () {
    function e() {}
    var t = e.prototype;
    return t.on = function (e, t) {
        if (e && t) {
            var i = this._events = this._events || {},
                n = i[e] = i[e] || [];
            return -1 == n.indexOf(t) && n.push(t), this
        }
    }, t.once = function (e, t) {
        if (e && t) {
            this.on(e, t);
            var i = this._onceEvents = this._onceEvents || {};
            return (i[e] = i[e] || {})[t] = !0, this
        }
    }, t.off = function (e, t) {
        var i = this._events && this._events[e];
        if (i && i.length) {
            var n = i.indexOf(t);
            return -1 != n && i.splice(n, 1), this
        }
    }, t.emitEvent = function (e, t) {
        var i = this._events && this._events[e];
        if (i && i.length) {
            i = i.slice(0), t = t || [];
            for (var n = this._onceEvents && this._onceEvents[e], r = 0; r < i.length; r++) {
                var o = i[r];
                n && n[o] && (this.off(e, o), delete n[o]), o.apply(this, t)
            }
            return this
        }
    }, t.allOff = function () {
        delete this._events, delete this._onceEvents
    }, e
})),
function (e, t) {
    "use strict";
    "function" == typeof define && define.amd ? define(["ev-emitter/ev-emitter"], (function (i) {
        return t(e, i)
    })) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter")) : e.imagesLoaded = t(e, e.EvEmitter)
}("undefined" != typeof window ? window : this, (function (e, t) {
    function i(e, t) {
        for (var i in t) e[i] = t[i];
        return e
    }

    function n(e, t, r) {
        if (!(this instanceof n)) return new n(e, t, r);
        var o, c = e;
        return "string" == typeof e && (c = document.querySelectorAll(e)), c ? (this.elements = (o = c, Array.isArray(o) ? o : "object" == typeof o && "number" == typeof o.length ? l.call(o) : [o]), this.options = i({}, this.options), "function" == typeof t ? r = t : i(this.options, t), r && this.on("always", r), this.getImages(), s && (this.jqDeferred = new s.Deferred), void setTimeout(this.check.bind(this))) : void a.error("Bad element for imagesLoaded " + (c || e))
    }

    function r(e) {
        this.img = e
    }

    function o(e, t) {
        this.url = e, this.element = t, this.img = new Image
    }
    var s = e.jQuery,
        a = e.console,
        l = Array.prototype.slice;
    (n.prototype = Object.create(t.prototype)).options = {}, n.prototype.getImages = function () {
        this.images = [], this.elements.forEach(this.addElementImages, this)
    }, n.prototype.addElementImages = function (e) {
        "IMG" == e.nodeName && this.addImage(e), !0 === this.options.background && this.addElementBackgroundImages(e);
        var t = e.nodeType;
        if (t && c[t]) {
            for (var i = e.querySelectorAll("img"), n = 0; n < i.length; n++) {
                var r = i[n];
                this.addImage(r)
            }
            if ("string" == typeof this.options.background) {
                var o = e.querySelectorAll(this.options.background);
                for (n = 0; n < o.length; n++) {
                    var s = o[n];
                    this.addElementBackgroundImages(s)
                }
            }
        }
    };
    var c = {
        1: !0,
        9: !0,
        11: !0
    };
    return n.prototype.addElementBackgroundImages = function (e) {
        var t = getComputedStyle(e);
        if (t)
            for (var i = /url\((['"])?(.*?)\1\)/gi, n = i.exec(t.backgroundImage); null !== n;) {
                var r = n && n[2];
                r && this.addBackground(r, e), n = i.exec(t.backgroundImage)
            }
    }, n.prototype.addImage = function (e) {
        var t = new r(e);
        this.images.push(t)
    }, n.prototype.addBackground = function (e, t) {
        var i = new o(e, t);
        this.images.push(i)
    }, n.prototype.check = function () {
        function e(e, i, n) {
            setTimeout((function () {
                t.progress(e, i, n)
            }))
        }
        var t = this;
        return this.progressedCount = 0, this.hasAnyBroken = !1, this.images.length ? void this.images.forEach((function (t) {
            t.once("progress", e), t.check()
        })) : void this.complete()
    }, n.prototype.progress = function (e, t, i) {
        this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !e.isLoaded, this.emitEvent("progress", [this, e, t]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, e), this.progressedCount == this.images.length && this.complete(), this.options.debug && a && a.log("progress: " + i, e, t)
    }, n.prototype.complete = function () {
        var e = this.hasAnyBroken ? "fail" : "done";
        if (this.isComplete = !0, this.emitEvent(e, [this]), this.emitEvent("always", [this]), this.jqDeferred) {
            var t = this.hasAnyBroken ? "reject" : "resolve";
            this.jqDeferred[t](this)
        }
    }, (r.prototype = Object.create(t.prototype)).check = function () {
        return this.getIsImageComplete() ? void this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image, this.proxyImage.addEventListener("load", this), this.proxyImage.addEventListener("error", this), this.img.addEventListener("load", this), this.img.addEventListener("error", this), void(this.proxyImage.src = this.img.src))
    }, r.prototype.getIsImageComplete = function () {
        return this.img.complete && this.img.naturalWidth
    }, r.prototype.confirm = function (e, t) {
        this.isLoaded = e, this.emitEvent("progress", [this, this.img, t])
    }, r.prototype.handleEvent = function (e) {
        var t = "on" + e.type;
        this[t] && this[t](e)
    }, r.prototype.onload = function () {
        this.confirm(!0, "onload"), this.unbindEvents()
    }, r.prototype.onerror = function () {
        this.confirm(!1, "onerror"), this.unbindEvents()
    }, r.prototype.unbindEvents = function () {
        this.proxyImage.removeEventListener("load", this), this.proxyImage.removeEventListener("error", this), this.img.removeEventListener("load", this), this.img.removeEventListener("error", this)
    }, (o.prototype = Object.create(r.prototype)).check = function () {
        this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.img.src = this.url, this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"), this.unbindEvents())
    }, o.prototype.unbindEvents = function () {
        this.img.removeEventListener("load", this), this.img.removeEventListener("error", this)
    }, o.prototype.confirm = function (e, t) {
        this.isLoaded = e, this.emitEvent("progress", [this, this.element, t])
    }, n.makeJQueryPlugin = function (t) {
        (t = t || e.jQuery) && ((s = t).fn.imagesLoaded = function (e, t) {
            return new n(this, e, t).jqDeferred.promise(s(this))
        })
    }, n.makeJQueryPlugin(), n
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("jquery-bridget/jquery-bridget", ["jquery"], (function (i) {
        return t(e, i)
    })) : "object" == typeof module && module.exports ? module.exports = t(e, require("jquery")) : e.jQueryBridget = t(e, e.jQuery)
}(window, (function (e, t) {
    "use strict";

    function i(i, o, a) {
        (a = a || t || e.jQuery) && (o.prototype.option || (o.prototype.option = function (e) {
            a.isPlainObject(e) && (this.options = a.extend(!0, this.options, e))
        }), a.fn[i] = function (e) {
            if ("string" != typeof e) return h = e, this.each((function (e, t) {
                var n = a.data(t, i);
                n ? (n.option(h), n._init()) : (n = new o(t, h), a.data(t, i, n))
            })), this;
            var t, n, l, c, u, h, d = r.call(arguments, 1);
            return l = d, u = "$()." + i + '("' + (n = e) + '")', (t = this).each((function (e, t) {
                var r = a.data(t, i);
                if (r) {
                    var o = r[n];
                    if (o && "_" != n.charAt(0)) {
                        var h = o.apply(r, l);
                        c = void 0 === c ? h : c
                    } else s(u + " is not a valid method")
                } else s(i + " not initialized. Cannot call methods, i.e. " + u)
            })), void 0 !== c ? c : t
        }, n(a))
    }

    function n(e) {
        !e || e && e.bridget || (e.bridget = i)
    }
    var r = Array.prototype.slice,
        o = e.console,
        s = void 0 === o ? function () {} : function (e) {
            o.error(e)
        };
    return n(t || e.jQuery), i
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" == typeof module && module.exports ? module.exports = t() : e.EvEmitter = t()
}("undefined" != typeof window ? window : this, (function () {
    function e() {}
    var t = e.prototype;
    return t.on = function (e, t) {
        if (e && t) {
            var i = this._events = this._events || {},
                n = i[e] = i[e] || [];
            return -1 == n.indexOf(t) && n.push(t), this
        }
    }, t.once = function (e, t) {
        if (e && t) {
            this.on(e, t);
            var i = this._onceEvents = this._onceEvents || {};
            return (i[e] = i[e] || {})[t] = !0, this
        }
    }, t.off = function (e, t) {
        var i = this._events && this._events[e];
        if (i && i.length) {
            var n = i.indexOf(t);
            return -1 != n && i.splice(n, 1), this
        }
    }, t.emitEvent = function (e, t) {
        var i = this._events && this._events[e];
        if (i && i.length) {
            i = i.slice(0), t = t || [];
            for (var n = this._onceEvents && this._onceEvents[e], r = 0; r < i.length; r++) {
                var o = i[r];
                n && n[o] && (this.off(e, o), delete n[o]), o.apply(this, t)
            }
            return this
        }
    }, t.allOff = function () {
        delete this._events, delete this._onceEvents
    }, e
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("get-size/get-size", t) : "object" == typeof module && module.exports ? module.exports = t() : e.getSize = t()
}(window, (function () {
    "use strict";

    function e(e) {
        var t = parseFloat(e);
        return -1 == e.indexOf("%") && !isNaN(t) && t
    }

    function t(e) {
        var t = getComputedStyle(e);
        return t || n("Style returned " + t + ". Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1"), t
    }
    var i, n = "undefined" == typeof console ? function () {} : function (e) {
            console.error(e)
        },
        r = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"],
        o = r.length,
        s = !1;
    return function n(a) {
        if (function () {
                if (!s) {
                    s = !0;
                    var r = document.createElement("div");
                    r.style.width = "200px", r.style.padding = "1px 2px 3px 4px", r.style.borderStyle = "solid", r.style.borderWidth = "1px 2px 3px 4px", r.style.boxSizing = "border-box";
                    var o = document.body || document.documentElement;
                    o.appendChild(r);
                    var a = t(r);
                    i = 200 == Math.round(e(a.width)), n.isBoxSizeOuter = i, o.removeChild(r)
                }
            }(), "string" == typeof a && (a = document.querySelector(a)), a && "object" == typeof a && a.nodeType) {
            var l = t(a);
            if ("none" == l.display) return function () {
                for (var e = {
                        width: 0,
                        height: 0,
                        innerWidth: 0,
                        innerHeight: 0,
                        outerWidth: 0,
                        outerHeight: 0
                    }, t = 0; t < o; t++) e[r[t]] = 0;
                return e
            }();
            var c = {};
            c.width = a.offsetWidth, c.height = a.offsetHeight;
            for (var u = c.isBorderBox = "border-box" == l.boxSizing, h = 0; h < o; h++) {
                var d = r[h],
                    p = l[d],
                    f = parseFloat(p);
                c[d] = isNaN(f) ? 0 : f
            }
            var m = c.paddingLeft + c.paddingRight,
                g = c.paddingTop + c.paddingBottom,
                v = c.marginLeft + c.marginRight,
                y = c.marginTop + c.marginBottom,
                b = c.borderLeftWidth + c.borderRightWidth,
                x = c.borderTopWidth + c.borderBottomWidth,
                w = u && i,
                _ = e(l.width);
            !1 !== _ && (c.width = _ + (w ? 0 : m + b));
            var E = e(l.height);
            return !1 !== E && (c.height = E + (w ? 0 : g + x)), c.innerWidth = c.width - (m + b), c.innerHeight = c.height - (g + x), c.outerWidth = c.width + v, c.outerHeight = c.height + y, c
        }
    }
})),
function (e, t) {
    "use strict";
    "function" == typeof define && define.amd ? define("desandro-matches-selector/matches-selector", t) : "object" == typeof module && module.exports ? module.exports = t() : e.matchesSelector = t()
}(window, (function () {
    "use strict";
    var e = function () {
        var e = window.Element.prototype;
        if (e.matches) return "matches";
        if (e.matchesSelector) return "matchesSelector";
        for (var t = ["webkit", "moz", "ms", "o"], i = 0; i < t.length; i++) {
            var n = t[i] + "MatchesSelector";
            if (e[n]) return n
        }
    }();
    return function (t, i) {
        return t[e](i)
    }
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], (function (i) {
        return t(e, i)
    })) : "object" == typeof module && module.exports ? module.exports = t(e, require("desandro-matches-selector")) : e.fizzyUIUtils = t(e, e.matchesSelector)
}(window, (function (e, t) {
    var i = {
            extend: function (e, t) {
                for (var i in t) e[i] = t[i];
                return e
            },
            modulo: function (e, t) {
                return (e % t + t) % t
            }
        },
        n = Array.prototype.slice;
    i.makeArray = function (e) {
        return Array.isArray(e) ? e : null == e ? [] : "object" == typeof e && "number" == typeof e.length ? n.call(e) : [e]
    }, i.removeFrom = function (e, t) {
        var i = e.indexOf(t); - 1 != i && e.splice(i, 1)
    }, i.getParent = function (e, i) {
        for (; e.parentNode && e != document.body;)
            if (e = e.parentNode, t(e, i)) return e
    }, i.getQueryElement = function (e) {
        return "string" == typeof e ? document.querySelector(e) : e
    }, i.handleEvent = function (e) {
        var t = "on" + e.type;
        this[t] && this[t](e)
    }, i.filterFindElements = function (e, n) {
        e = i.makeArray(e);
        var r = [];
        return e.forEach((function (e) {
            if (e instanceof HTMLElement) {
                if (!n) return void r.push(e);
                t(e, n) && r.push(e);
                for (var i = e.querySelectorAll(n), o = 0; o < i.length; o++) r.push(i[o])
            }
        })), r
    }, i.debounceMethod = function (e, t, i) {
        i = i || 100;
        var n = e.prototype[t],
            r = t + "Timeout";
        e.prototype[t] = function () {
            var e = this[r];
            clearTimeout(e);
            var t = arguments,
                o = this;
            this[r] = setTimeout((function () {
                n.apply(o, t), delete o[r]
            }), i)
        }
    }, i.docReady = function (e) {
        var t = document.readyState;
        "complete" == t || "interactive" == t ? setTimeout(e) : document.addEventListener("DOMContentLoaded", e)
    }, i.toDashed = function (e) {
        return e.replace(/(.)([A-Z])/g, (function (e, t, i) {
            return t + "-" + i
        })).toLowerCase()
    };
    var r = e.console;
    return i.htmlInit = function (t, n) {
        i.docReady((function () {
            var o = i.toDashed(n),
                s = "data-" + o,
                a = document.querySelectorAll("[" + s + "]"),
                l = document.querySelectorAll(".js-" + o),
                c = i.makeArray(a).concat(i.makeArray(l)),
                u = s + "-options",
                h = e.jQuery;
            c.forEach((function (e) {
                var i, o = e.getAttribute(s) || e.getAttribute(u);
                try {
                    i = o && JSON.parse(o)
                } catch (i) {
                    return void(r && r.error("Error parsing " + s + " on " + e.className + ": " + i))
                }
                var a = new t(e, i);
                h && h.data(e, n, a)
            }))
        }))
    }, i
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("outlayer/item", ["ev-emitter/ev-emitter", "get-size/get-size"], t) : "object" == typeof module && module.exports ? module.exports = t(require("ev-emitter"), require("get-size")) : (e.Outlayer = {}, e.Outlayer.Item = t(e.EvEmitter, e.getSize))
}(window, (function (e, t) {
    "use strict";

    function i(e, t) {
        e && (this.element = e, this.layout = t, this.position = {
            x: 0,
            y: 0
        }, this._create())
    }
    var n = document.documentElement.style,
        r = "string" == typeof n.transition ? "transition" : "WebkitTransition",
        o = "string" == typeof n.transform ? "transform" : "WebkitTransform",
        s = {
            WebkitTransition: "webkitTransitionEnd",
            transition: "transitionend"
        } [r],
        a = {
            transform: o,
            transition: r,
            transitionDuration: r + "Duration",
            transitionProperty: r + "Property",
            transitionDelay: r + "Delay"
        },
        l = i.prototype = Object.create(e.prototype);
    l.constructor = i, l._create = function () {
        this._transn = {
            ingProperties: {},
            clean: {},
            onEnd: {}
        }, this.css({
            position: "absolute"
        })
    }, l.handleEvent = function (e) {
        var t = "on" + e.type;
        this[t] && this[t](e)
    }, l.getSize = function () {
        this.size = t(this.element)
    }, l.css = function (e) {
        var t = this.element.style;
        for (var i in e) t[a[i] || i] = e[i]
    }, l.getPosition = function () {
        var e = getComputedStyle(this.element),
            t = this.layout._getOption("originLeft"),
            i = this.layout._getOption("originTop"),
            n = e[t ? "left" : "right"],
            r = e[i ? "top" : "bottom"],
            o = parseFloat(n),
            s = parseFloat(r),
            a = this.layout.size; - 1 != n.indexOf("%") && (o = o / 100 * a.width), -1 != r.indexOf("%") && (s = s / 100 * a.height), o = isNaN(o) ? 0 : o, s = isNaN(s) ? 0 : s, o -= t ? a.paddingLeft : a.paddingRight, s -= i ? a.paddingTop : a.paddingBottom, this.position.x = o, this.position.y = s
    }, l.layoutPosition = function () {
        var e = this.layout.size,
            t = {},
            i = this.layout._getOption("originLeft"),
            n = this.layout._getOption("originTop"),
            r = i ? "paddingLeft" : "paddingRight",
            o = i ? "left" : "right",
            s = i ? "right" : "left",
            a = this.position.x + e[r];
        t[o] = this.getXValue(a), t[s] = "";
        var l = n ? "paddingTop" : "paddingBottom",
            c = n ? "top" : "bottom",
            u = n ? "bottom" : "top",
            h = this.position.y + e[l];
        t[c] = this.getYValue(h), t[u] = "", this.css(t), this.emitEvent("layout", [this])
    }, l.getXValue = function (e) {
        var t = this.layout._getOption("horizontal");
        return this.layout.options.percentPosition && !t ? e / this.layout.size.width * 100 + "%" : e + "px"
    }, l.getYValue = function (e) {
        var t = this.layout._getOption("horizontal");
        return this.layout.options.percentPosition && t ? e / this.layout.size.height * 100 + "%" : e + "px"
    }, l._transitionTo = function (e, t) {
        this.getPosition();
        var i = this.position.x,
            n = this.position.y,
            r = e == this.position.x && t == this.position.y;
        if (this.setPosition(e, t), !r || this.isTransitioning) {
            var o = e - i,
                s = t - n,
                a = {};
            a.transform = this.getTranslate(o, s), this.transition({
                to: a,
                onTransitionEnd: {
                    transform: this.layoutPosition
                },
                isCleaning: !0
            })
        } else this.layoutPosition()
    }, l.getTranslate = function (e, t) {
        return "translate3d(" + (e = this.layout._getOption("originLeft") ? e : -e) + "px, " + (t = this.layout._getOption("originTop") ? t : -t) + "px, 0)"
    }, l.goTo = function (e, t) {
        this.setPosition(e, t), this.layoutPosition()
    }, l.moveTo = l._transitionTo, l.setPosition = function (e, t) {
        this.position.x = parseFloat(e), this.position.y = parseFloat(t)
    }, l._nonTransition = function (e) {
        for (var t in this.css(e.to), e.isCleaning && this._removeStyles(e.to), e.onTransitionEnd) e.onTransitionEnd[t].call(this)
    }, l.transition = function (e) {
        if (parseFloat(this.layout.options.transitionDuration)) {
            var t = this._transn;
            for (var i in e.onTransitionEnd) t.onEnd[i] = e.onTransitionEnd[i];
            for (i in e.to) t.ingProperties[i] = !0, e.isCleaning && (t.clean[i] = !0);
            e.from && (this.css(e.from), this.element.offsetHeight), this.enableTransition(e.to), this.css(e.to), this.isTransitioning = !0
        } else this._nonTransition(e)
    };
    var c = "opacity," + o.replace(/([A-Z])/g, (function (e) {
        return "-" + e.toLowerCase()
    }));
    l.enableTransition = function () {
        if (!this.isTransitioning) {
            var e = this.layout.options.transitionDuration;
            e = "number" == typeof e ? e + "ms" : e, this.css({
                transitionProperty: c,
                transitionDuration: e,
                transitionDelay: this.staggerDelay || 0
            }), this.element.addEventListener(s, this, !1)
        }
    }, l.onwebkitTransitionEnd = function (e) {
        this.ontransitionend(e)
    }, l.onotransitionend = function (e) {
        this.ontransitionend(e)
    };
    var u = {
        "-webkit-transform": "transform"
    };
    l.ontransitionend = function (e) {
        if (e.target === this.element) {
            var t = this._transn,
                i = u[e.propertyName] || e.propertyName;
            delete t.ingProperties[i],
                function (e) {
                    for (var t in e) return !1;
                    return !0
                }(t.ingProperties) && this.disableTransition(), i in t.clean && (this.element.style[e.propertyName] = "", delete t.clean[i]), i in t.onEnd && (t.onEnd[i].call(this), delete t.onEnd[i]), this.emitEvent("transitionEnd", [this])
        }
    }, l.disableTransition = function () {
        this.removeTransitionStyles(), this.element.removeEventListener(s, this, !1), this.isTransitioning = !1
    }, l._removeStyles = function (e) {
        var t = {};
        for (var i in e) t[i] = "";
        this.css(t)
    };
    var h = {
        transitionProperty: "",
        transitionDuration: "",
        transitionDelay: ""
    };
    return l.removeTransitionStyles = function () {
        this.css(h)
    }, l.stagger = function (e) {
        e = isNaN(e) ? 0 : e, this.staggerDelay = e + "ms"
    }, l.removeElem = function () {
        this.element.parentNode.removeChild(this.element), this.css({
            display: ""
        }), this.emitEvent("remove", [this])
    }, l.remove = function () {
        return r && parseFloat(this.layout.options.transitionDuration) ? (this.once("transitionEnd", (function () {
            this.removeElem()
        })), void this.hide()) : void this.removeElem()
    }, l.reveal = function () {
        delete this.isHidden, this.css({
            display: ""
        });
        var e = this.layout.options,
            t = {};
        t[this.getHideRevealTransitionEndProperty("visibleStyle")] = this.onRevealTransitionEnd, this.transition({
            from: e.hiddenStyle,
            to: e.visibleStyle,
            isCleaning: !0,
            onTransitionEnd: t
        })
    }, l.onRevealTransitionEnd = function () {
        this.isHidden || this.emitEvent("reveal")
    }, l.getHideRevealTransitionEndProperty = function (e) {
        var t = this.layout.options[e];
        if (t.opacity) return "opacity";
        for (var i in t) return i
    }, l.hide = function () {
        this.isHidden = !0, this.css({
            display: ""
        });
        var e = this.layout.options,
            t = {};
        t[this.getHideRevealTransitionEndProperty("hiddenStyle")] = this.onHideTransitionEnd, this.transition({
            from: e.visibleStyle,
            to: e.hiddenStyle,
            isCleaning: !0,
            onTransitionEnd: t
        })
    }, l.onHideTransitionEnd = function () {
        this.isHidden && (this.css({
            display: "none"
        }), this.emitEvent("hide"))
    }, l.destroy = function () {
        this.css({
            position: "",
            left: "",
            right: "",
            top: "",
            bottom: "",
            transition: "",
            transform: ""
        })
    }, i
})),
function (e, t) {
    "use strict";
    "function" == typeof define && define.amd ? define("outlayer/outlayer", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./item"], (function (i, n, r, o) {
        return t(e, i, n, r, o)
    })) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./item")) : e.Outlayer = t(e, e.EvEmitter, e.getSize, e.fizzyUIUtils, e.Outlayer.Item)
}(window, (function (e, t, i, n, r) {
    "use strict";

    function o(e, t) {
        var i = n.getQueryElement(e);
        if (i) {
            this.element = i, l && (this.$element = l(this.element)), this.options = n.extend({}, this.constructor.defaults), this.option(t);
            var r = ++u;
            this.element.outlayerGUID = r, (h[r] = this)._create(), this._getOption("initLayout") && this.layout()
        } else a && a.error("Bad element for " + this.constructor.namespace + ": " + (i || e))
    }

    function s(e) {
        function t() {
            e.apply(this, arguments)
        }
        return (t.prototype = Object.create(e.prototype)).constructor = t
    }
    var a = e.console,
        l = e.jQuery,
        c = function () {},
        u = 0,
        h = {};
    o.namespace = "outlayer", o.Item = r, o.defaults = {
        containerStyle: {
            position: "relative"
        },
        initLayout: !0,
        originLeft: !0,
        originTop: !0,
        resize: !0,
        resizeContainer: !0,
        transitionDuration: "0.4s",
        hiddenStyle: {
            opacity: 0,
            transform: "scale(0.001)"
        },
        visibleStyle: {
            opacity: 1,
            transform: "scale(1)"
        }
    };
    var d = o.prototype;
    n.extend(d, t.prototype), d.option = function (e) {
        n.extend(this.options, e)
    }, d._getOption = function (e) {
        var t = this.constructor.compatOptions[e];
        return t && void 0 !== this.options[t] ? this.options[t] : this.options[e]
    }, o.compatOptions = {
        initLayout: "isInitLayout",
        horizontal: "isHorizontal",
        layoutInstant: "isLayoutInstant",
        originLeft: "isOriginLeft",
        originTop: "isOriginTop",
        resize: "isResizeBound",
        resizeContainer: "isResizingContainer"
    }, d._create = function () {
        this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), n.extend(this.element.style, this.options.containerStyle), this._getOption("resize") && this.bindResize()
    }, d.reloadItems = function () {
        this.items = this._itemize(this.element.children)
    }, d._itemize = function (e) {
        for (var t = this._filterFindItemElements(e), i = this.constructor.Item, n = [], r = 0; r < t.length; r++) {
            var o = new i(t[r], this);
            n.push(o)
        }
        return n
    }, d._filterFindItemElements = function (e) {
        return n.filterFindElements(e, this.options.itemSelector)
    }, d.getItemElements = function () {
        return this.items.map((function (e) {
            return e.element
        }))
    }, d.layout = function () {
        this._resetLayout(), this._manageStamps();
        var e = this._getOption("layoutInstant"),
            t = void 0 !== e ? e : !this._isLayoutInited;
        this.layoutItems(this.items, t), this._isLayoutInited = !0
    }, d._init = d.layout, d._resetLayout = function () {
        this.getSize()
    }, d.getSize = function () {
        this.size = i(this.element)
    }, d._getMeasurement = function (e, t) {
        var n, r = this.options[e];
        r ? ("string" == typeof r ? n = this.element.querySelector(r) : r instanceof HTMLElement && (n = r), this[e] = n ? i(n)[t] : r) : this[e] = 0
    }, d.layoutItems = function (e, t) {
        e = this._getItemsForLayout(e), this._layoutItems(e, t), this._postLayout()
    }, d._getItemsForLayout = function (e) {
        return e.filter((function (e) {
            return !e.isIgnored
        }))
    }, d._layoutItems = function (e, t) {
        if (this._emitCompleteOnItems("layout", e), e && e.length) {
            var i = [];
            e.forEach((function (e) {
                var n = this._getItemLayoutPosition(e);
                n.item = e, n.isInstant = t || e.isLayoutInstant, i.push(n)
            }), this), this._processLayoutQueue(i)
        }
    }, d._getItemLayoutPosition = function () {
        return {
            x: 0,
            y: 0
        }
    }, d._processLayoutQueue = function (e) {
        this.updateStagger(), e.forEach((function (e, t) {
            this._positionItem(e.item, e.x, e.y, e.isInstant, t)
        }), this)
    }, d.updateStagger = function () {
        var e = this.options.stagger;
        return null == e ? void(this.stagger = 0) : (this.stagger = function (e) {
            if ("number" == typeof e) return e;
            var t = e.match(/(^\d*\.?\d*)(\w*)/),
                i = t && t[1],
                n = t && t[2];
            return i.length ? (i = parseFloat(i)) * (p[n] || 1) : 0
        }(e), this.stagger)
    }, d._positionItem = function (e, t, i, n, r) {
        n ? e.goTo(t, i) : (e.stagger(r * this.stagger), e.moveTo(t, i))
    }, d._postLayout = function () {
        this.resizeContainer()
    }, d.resizeContainer = function () {
        if (this._getOption("resizeContainer")) {
            var e = this._getContainerSize();
            e && (this._setContainerMeasure(e.width, !0), this._setContainerMeasure(e.height, !1))
        }
    }, d._getContainerSize = c, d._setContainerMeasure = function (e, t) {
        if (void 0 !== e) {
            var i = this.size;
            i.isBorderBox && (e += t ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i.borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i.borderBottomWidth), e = Math.max(e, 0), this.element.style[t ? "width" : "height"] = e + "px"
        }
    }, d._emitCompleteOnItems = function (e, t) {
        function i() {
            r.dispatchEvent(e + "Complete", null, [t])
        }

        function n() {
            ++s == o && i()
        }
        var r = this,
            o = t.length;
        if (t && o) {
            var s = 0;
            t.forEach((function (t) {
                t.once(e, n)
            }))
        } else i()
    }, d.dispatchEvent = function (e, t, i) {
        var n = t ? [t].concat(i) : i;
        if (this.emitEvent(e, n), l)
            if (this.$element = this.$element || l(this.element), t) {
                var r = l.Event(t);
                r.type = e, this.$element.trigger(r, i)
            } else this.$element.trigger(e, i)
    }, d.ignore = function (e) {
        var t = this.getItem(e);
        t && (t.isIgnored = !0)
    }, d.unignore = function (e) {
        var t = this.getItem(e);
        t && delete t.isIgnored
    }, d.stamp = function (e) {
        (e = this._find(e)) && (this.stamps = this.stamps.concat(e), e.forEach(this.ignore, this))
    }, d.unstamp = function (e) {
        (e = this._find(e)) && e.forEach((function (e) {
            n.removeFrom(this.stamps, e), this.unignore(e)
        }), this)
    }, d._find = function (e) {
        if (e) return "string" == typeof e && (e = this.element.querySelectorAll(e)), n.makeArray(e)
    }, d._manageStamps = function () {
        this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this._manageStamp, this))
    }, d._getBoundingRect = function () {
        var e = this.element.getBoundingClientRect(),
            t = this.size;
        this._boundingRect = {
            left: e.left + t.paddingLeft + t.borderLeftWidth,
            top: e.top + t.paddingTop + t.borderTopWidth,
            right: e.right - (t.paddingRight + t.borderRightWidth),
            bottom: e.bottom - (t.paddingBottom + t.borderBottomWidth)
        }
    }, d._manageStamp = c, d._getElementOffset = function (e) {
        var t = e.getBoundingClientRect(),
            n = this._boundingRect,
            r = i(e);
        return {
            left: t.left - n.left - r.marginLeft,
            top: t.top - n.top - r.marginTop,
            right: n.right - t.right - r.marginRight,
            bottom: n.bottom - t.bottom - r.marginBottom
        }
    }, d.handleEvent = n.handleEvent, d.bindResize = function () {
        e.addEventListener("resize", this), this.isResizeBound = !0
    }, d.unbindResize = function () {
        e.removeEventListener("resize", this), this.isResizeBound = !1
    }, d.onresize = function () {
        this.resize()
    }, n.debounceMethod(o, "onresize", 100), d.resize = function () {
        this.isResizeBound && this.needsResizeLayout() && this.layout()
    }, d.needsResizeLayout = function () {
        var e = i(this.element);
        return this.size && e && e.innerWidth !== this.size.innerWidth
    }, d.addItems = function (e) {
        var t = this._itemize(e);
        return t.length && (this.items = this.items.concat(t)), t
    }, d.appended = function (e) {
        var t = this.addItems(e);
        t.length && (this.layoutItems(t, !0), this.reveal(t))
    }, d.prepended = function (e) {
        var t = this._itemize(e);
        if (t.length) {
            var i = this.items.slice(0);
            this.items = t.concat(i), this._resetLayout(), this._manageStamps(), this.layoutItems(t, !0), this.reveal(t), this.layoutItems(i)
        }
    }, d.reveal = function (e) {
        if (this._emitCompleteOnItems("reveal", e), e && e.length) {
            var t = this.updateStagger();
            e.forEach((function (e, i) {
                e.stagger(i * t), e.reveal()
            }))
        }
    }, d.hide = function (e) {
        if (this._emitCompleteOnItems("hide", e), e && e.length) {
            var t = this.updateStagger();
            e.forEach((function (e, i) {
                e.stagger(i * t), e.hide()
            }))
        }
    }, d.revealItemElements = function (e) {
        var t = this.getItems(e);
        this.reveal(t)
    }, d.hideItemElements = function (e) {
        var t = this.getItems(e);
        this.hide(t)
    }, d.getItem = function (e) {
        for (var t = 0; t < this.items.length; t++) {
            var i = this.items[t];
            if (i.element == e) return i
        }
    }, d.getItems = function (e) {
        e = n.makeArray(e);
        var t = [];
        return e.forEach((function (e) {
            var i = this.getItem(e);
            i && t.push(i)
        }), this), t
    }, d.remove = function (e) {
        var t = this.getItems(e);
        this._emitCompleteOnItems("remove", t), t && t.length && t.forEach((function (e) {
            e.remove(), n.removeFrom(this.items, e)
        }), this)
    }, d.destroy = function () {
        var e = this.element.style;
        e.height = "", e.position = "", e.width = "", this.items.forEach((function (e) {
            e.destroy()
        })), this.unbindResize();
        var t = this.element.outlayerGUID;
        delete h[t], delete this.element.outlayerGUID, l && l.removeData(this.element, this.constructor.namespace)
    }, o.data = function (e) {
        var t = (e = n.getQueryElement(e)) && e.outlayerGUID;
        return t && h[t]
    }, o.create = function (e, t) {
        var i = s(o);
        return i.defaults = n.extend({}, o.defaults), n.extend(i.defaults, t), i.compatOptions = n.extend({}, o.compatOptions), i.namespace = e, i.data = o.data, i.Item = s(r), n.htmlInit(i, e), l && l.bridget && l.bridget(e, i), i
    };
    var p = {
        ms: 1,
        s: 1e3
    };
    return o.Item = r, o
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("isotope-layout/js/item", ["outlayer/outlayer"], t) : "object" == typeof module && module.exports ? module.exports = t(require("outlayer")) : (e.Isotope = e.Isotope || {}, e.Isotope.Item = t(e.Outlayer))
}(window, (function (e) {
    "use strict";

    function t() {
        e.Item.apply(this, arguments)
    }
    var i = t.prototype = Object.create(e.Item.prototype),
        n = i._create;
    i._create = function () {
        this.id = this.layout.itemGUID++, n.call(this), this.sortData = {}
    }, i.updateSortData = function () {
        if (!this.isIgnored) {
            this.sortData.id = this.id, this.sortData["original-order"] = this.id, this.sortData.random = Math.random();
            var e = this.layout.options.getSortData,
                t = this.layout._sorters;
            for (var i in e) {
                var n = t[i];
                this.sortData[i] = n(this.element, this)
            }
        }
    };
    var r = i.destroy;
    return i.destroy = function () {
        r.apply(this, arguments), this.css({
            display: ""
        })
    }, t
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("isotope-layout/js/layout-mode", ["get-size/get-size", "outlayer/outlayer"], t) : "object" == typeof module && module.exports ? module.exports = t(require("get-size"), require("outlayer")) : (e.Isotope = e.Isotope || {}, e.Isotope.LayoutMode = t(e.getSize, e.Outlayer))
}(window, (function (e, t) {
    "use strict";

    function i(e) {
        (this.isotope = e) && (this.options = e.options[this.namespace], this.element = e.element, this.items = e.filteredItems, this.size = e.size)
    }
    var n = i.prototype;
    return ["_resetLayout", "_getItemLayoutPosition", "_manageStamp", "_getContainerSize", "_getElementOffset", "needsResizeLayout", "_getOption"].forEach((function (e) {
        n[e] = function () {
            return t.prototype[e].apply(this.isotope, arguments)
        }
    })), n.needsVerticalResizeLayout = function () {
        var t = e(this.isotope.element);
        return this.isotope.size && t && t.innerHeight != this.isotope.size.innerHeight
    }, n._getMeasurement = function () {
        this.isotope._getMeasurement.apply(this, arguments)
    }, n.getColumnWidth = function () {
        this.getSegmentSize("column", "Width")
    }, n.getRowHeight = function () {
        this.getSegmentSize("row", "Height")
    }, n.getSegmentSize = function (e, t) {
        var i = e + t,
            n = "outer" + t;
        if (this._getMeasurement(i, n), !this[i]) {
            var r = this.getFirstItemSize();
            this[i] = r && r[n] || this.isotope.size["inner" + t]
        }
    }, n.getFirstItemSize = function () {
        var t = this.isotope.filteredItems[0];
        return t && t.element && e(t.element)
    }, n.layout = function () {
        this.isotope.layout.apply(this.isotope, arguments)
    }, n.getSize = function () {
        this.isotope.getSize(), this.size = this.isotope.size
    }, i.modes = {}, i.create = function (e, t) {
        function r() {
            i.apply(this, arguments)
        }
        return (r.prototype = Object.create(n)).constructor = r, t && (r.options = t), i.modes[r.prototype.namespace = e] = r
    }, i
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("masonry-layout/masonry", ["outlayer/outlayer", "get-size/get-size"], t) : "object" == typeof module && module.exports ? module.exports = t(require("outlayer"), require("get-size")) : e.Masonry = t(e.Outlayer, e.getSize)
}(window, (function (e, t) {
    var i = e.create("masonry");
    i.compatOptions.fitWidth = "isFitWidth";
    var n = i.prototype;
    return n._resetLayout = function () {
        this.getSize(), this._getMeasurement("columnWidth", "outerWidth"), this._getMeasurement("gutter", "outerWidth"), this.measureColumns(), this.colYs = [];
        for (var e = 0; e < this.cols; e++) this.colYs.push(0);
        this.maxY = 0, this.horizontalColIndex = 0
    }, n.measureColumns = function () {
        if (this.getContainerWidth(), !this.columnWidth) {
            var e = this.items[0],
                i = e && e.element;
            this.columnWidth = i && t(i).outerWidth || this.containerWidth
        }
        var n = this.columnWidth += this.gutter,
            r = this.containerWidth + this.gutter,
            o = r / n,
            s = n - r % n;
        o = Math[s && s < 1 ? "round" : "floor"](o), this.cols = Math.max(o, 1)
    }, n.getContainerWidth = function () {
        var e = this._getOption("fitWidth") ? this.element.parentNode : this.element,
            i = t(e);
        this.containerWidth = i && i.innerWidth
    }, n._getItemLayoutPosition = function (e) {
        e.getSize();
        var t = e.size.outerWidth % this.columnWidth,
            i = Math[t && t < 1 ? "round" : "ceil"](e.size.outerWidth / this.columnWidth);
        i = Math.min(i, this.cols);
        for (var n = this[this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition"](i, e), r = {
                x: this.columnWidth * n.col,
                y: n.y
            }, o = n.y + e.size.outerHeight, s = i + n.col, a = n.col; a < s; a++) this.colYs[a] = o;
        return r
    }, n._getTopColPosition = function (e) {
        var t = this._getTopColGroup(e),
            i = Math.min.apply(Math, t);
        return {
            col: t.indexOf(i),
            y: i
        }
    }, n._getTopColGroup = function (e) {
        if (e < 2) return this.colYs;
        for (var t = [], i = this.cols + 1 - e, n = 0; n < i; n++) t[n] = this._getColGroupY(n, e);
        return t
    }, n._getColGroupY = function (e, t) {
        if (t < 2) return this.colYs[e];
        var i = this.colYs.slice(e, e + t);
        return Math.max.apply(Math, i)
    }, n._getHorizontalColPosition = function (e, t) {
        var i = this.horizontalColIndex % this.cols;
        i = 1 < e && i + e > this.cols ? 0 : i;
        var n = t.size.outerWidth && t.size.outerHeight;
        return this.horizontalColIndex = n ? i + e : this.horizontalColIndex, {
            col: i,
            y: this._getColGroupY(i, e)
        }
    }, n._manageStamp = function (e) {
        var i = t(e),
            n = this._getElementOffset(e),
            r = this._getOption("originLeft") ? n.left : n.right,
            o = r + i.outerWidth,
            s = Math.floor(r / this.columnWidth);
        s = Math.max(0, s);
        var a = Math.floor(o / this.columnWidth);
        a -= o % this.columnWidth ? 0 : 1, a = Math.min(this.cols - 1, a);
        for (var l = (this._getOption("originTop") ? n.top : n.bottom) + i.outerHeight, c = s; c <= a; c++) this.colYs[c] = Math.max(l, this.colYs[c])
    }, n._getContainerSize = function () {
        this.maxY = Math.max.apply(Math, this.colYs);
        var e = {
            height: this.maxY
        };
        return this._getOption("fitWidth") && (e.width = this._getContainerFitWidth()), e
    }, n._getContainerFitWidth = function () {
        for (var e = 0, t = this.cols; --t && 0 === this.colYs[t];) e++;
        return (this.cols - e) * this.columnWidth - this.gutter
    }, n.needsResizeLayout = function () {
        var e = this.containerWidth;
        return this.getContainerWidth(), e != this.containerWidth
    }, i
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/masonry", ["../layout-mode", "masonry-layout/masonry"], t) : "object" == typeof module && module.exports ? module.exports = t(require("../layout-mode"), require("masonry-layout")) : t(e.Isotope.LayoutMode, e.Masonry)
}(window, (function (e, t) {
    "use strict";
    var i = e.create("masonry"),
        n = i.prototype,
        r = {
            _getElementOffset: !0,
            layout: !0,
            _getMeasurement: !0
        };
    for (var o in t.prototype) r[o] || (n[o] = t.prototype[o]);
    var s = n.measureColumns;
    n.measureColumns = function () {
        this.items = this.isotope.filteredItems, s.call(this)
    };
    var a = n._getOption;
    return n._getOption = function (e) {
        return "fitWidth" == e ? void 0 !== this.options.isFitWidth ? this.options.isFitWidth : this.options.fitWidth : a.apply(this.isotope, arguments)
    }, i
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/fit-rows", ["../layout-mode"], t) : "object" == typeof exports ? module.exports = t(require("../layout-mode")) : t(e.Isotope.LayoutMode)
}(window, (function (e) {
    "use strict";
    var t = e.create("fitRows"),
        i = t.prototype;
    return i._resetLayout = function () {
        this.x = 0, this.y = 0, this.maxY = 0, this._getMeasurement("gutter", "outerWidth")
    }, i._getItemLayoutPosition = function (e) {
        e.getSize();
        var t = e.size.outerWidth + this.gutter,
            i = this.isotope.size.innerWidth + this.gutter;
        0 !== this.x && t + this.x > i && (this.x = 0, this.y = this.maxY);
        var n = {
            x: this.x,
            y: this.y
        };
        return this.maxY = Math.max(this.maxY, this.y + e.size.outerHeight), this.x += t, n
    }, i._getContainerSize = function () {
        return {
            height: this.maxY
        }
    }, t
})),
function (e, t) {
    "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/vertical", ["../layout-mode"], t) : "object" == typeof module && module.exports ? module.exports = t(require("../layout-mode")) : t(e.Isotope.LayoutMode)
}(window, (function (e) {
    "use strict";
    var t = e.create("vertical", {
            horizontalAlignment: 0
        }),
        i = t.prototype;
    return i._resetLayout = function () {
        this.y = 0
    }, i._getItemLayoutPosition = function (e) {
        e.getSize();
        var t = (this.isotope.size.innerWidth - e.size.outerWidth) * this.options.horizontalAlignment,
            i = this.y;
        return this.y += e.size.outerHeight, {
            x: t,
            y: i
        }
    }, i._getContainerSize = function () {
        return {
            height: this.y
        }
    }, t
})),
function (e, t) {
    "function" == typeof define && define.amd ? define(["outlayer/outlayer", "get-size/get-size", "desandro-matches-selector/matches-selector", "fizzy-ui-utils/utils", "isotope-layout/js/item", "isotope-layout/js/layout-mode", "isotope-layout/js/layout-modes/masonry", "isotope-layout/js/layout-modes/fit-rows", "isotope-layout/js/layout-modes/vertical"], (function (i, n, r, o, s, a) {
        return t(e, i, n, r, o, s, a)
    })) : "object" == typeof module && module.exports ? module.exports = t(e, require("outlayer"), require("get-size"), require("desandro-matches-selector"), require("fizzy-ui-utils"), require("isotope-layout/js/item"), require("isotope-layout/js/layout-mode"), require("isotope-layout/js/layout-modes/masonry"), require("isotope-layout/js/layout-modes/fit-rows"), require("isotope-layout/js/layout-modes/vertical")) : e.Isotope = t(e, e.Outlayer, e.getSize, e.matchesSelector, e.fizzyUIUtils, e.Isotope.Item, e.Isotope.LayoutMode)
}(window, (function (e, t, i, n, r, o, s) {
    var a = e.jQuery,
        l = String.prototype.trim ? function (e) {
            return e.trim()
        } : function (e) {
            return e.replace(/^\s+|\s+$/g, "")
        },
        c = t.create("isotope", {
            layoutMode: "masonry",
            isJQueryFiltering: !0,
            sortAscending: !0
        });
    c.Item = o, c.LayoutMode = s;
    var u = c.prototype;
    u._create = function () {
        for (var e in this.itemGUID = 0, this._sorters = {}, this._getSorters(), t.prototype._create.call(this), this.modes = {}, this.filteredItems = this.items, this.sortHistory = ["original-order"], s.modes) this._initLayoutMode(e)
    }, u.reloadItems = function () {
        this.itemGUID = 0, t.prototype.reloadItems.call(this)
    }, u._itemize = function () {
        for (var e = t.prototype._itemize.apply(this, arguments), i = 0; i < e.length; i++) e[i].id = this.itemGUID++;
        return this._updateItemsSortData(e), e
    }, u._initLayoutMode = function (e) {
        var t = s.modes[e],
            i = this.options[e] || {};
        this.options[e] = t.options ? r.extend(t.options, i) : i, this.modes[e] = new t(this)
    }, u.layout = function () {
        return !this._isLayoutInited && this._getOption("initLayout") ? void this.arrange() : void this._layout()
    }, u._layout = function () {
        var e = this._getIsInstant();
        this._resetLayout(), this._manageStamps(), this.layoutItems(this.filteredItems, e), this._isLayoutInited = !0
    }, u.arrange = function (e) {
        this.option(e), this._getIsInstant();
        var t = this._filter(this.items);
        this.filteredItems = t.matches, this._bindArrangeComplete(), this._isInstant ? this._noTransition(this._hideReveal, [t]) : this._hideReveal(t), this._sort(), this._layout()
    }, u._init = u.arrange, u._hideReveal = function (e) {
        this.reveal(e.needReveal), this.hide(e.needHide)
    }, u._getIsInstant = function () {
        var e = this._getOption("layoutInstant"),
            t = void 0 !== e ? e : !this._isLayoutInited;
        return this._isInstant = t
    }, u._bindArrangeComplete = function () {
        function e() {
            t && i && n && r.dispatchEvent("arrangeComplete", null, [r.filteredItems])
        }
        var t, i, n, r = this;
        this.once("layoutComplete", (function () {
            t = !0, e()
        })), this.once("hideComplete", (function () {
            i = !0, e()
        })), this.once("revealComplete", (function () {
            n = !0, e()
        }))
    }, u._filter = function (e) {
        var t = this.options.filter;
        t = t || "*";
        for (var i = [], n = [], r = [], o = this._getFilterTest(t), s = 0; s < e.length; s++) {
            var a = e[s];
            if (!a.isIgnored) {
                var l = o(a);
                l && i.push(a), l && a.isHidden ? n.push(a) : l || a.isHidden || r.push(a)
            }
        }
        return {
            matches: i,
            needReveal: n,
            needHide: r
        }
    }, u._getFilterTest = function (e) {
        return a && this.options.isJQueryFiltering ? function (t) {
            return a(t.element).is(e)
        } : "function" == typeof e ? function (t) {
            return e(t.element)
        } : function (t) {
            return n(t.element, e)
        }
    }, u.updateSortData = function (e) {
        var t;
        t = e ? (e = r.makeArray(e), this.getItems(e)) : this.items, this._getSorters(), this._updateItemsSortData(t)
    }, u._getSorters = function () {
        var e = this.options.getSortData;
        for (var t in e) {
            var i = e[t];
            this._sorters[t] = h(i)
        }
    }, u._updateItemsSortData = function (e) {
        for (var t = e && e.length, i = 0; t && i < t; i++) e[i].updateSortData()
    };
    var h = function (e) {
        if ("string" != typeof e) return e;
        var t, i, n = l(e).split(" "),
            r = n[0],
            o = r.match(/^\[(.+)\]$/),
            s = o && o[1],
            a = (i = r, (t = s) ? function (e) {
                return e.getAttribute(t)
            } : function (e) {
                var t = e.querySelector(i);
                return t && t.textContent
            }),
            u = c.sortDataParsers[n[1]];
        return u ? function (e) {
            return e && u(a(e))
        } : function (e) {
            return e && a(e)
        }
    };
    c.sortDataParsers = {
        parseInt: function (e) {
            return parseInt(e, 10)
        },
        parseFloat: function (e) {
            return parseFloat(e)
        }
    }, u._sort = function () {
        if (this.options.sortBy) {
            var e = r.makeArray(this.options.sortBy);
            this._getIsSameSortBy(e) || (this.sortHistory = e.concat(this.sortHistory));
            var t = (i = this.sortHistory, n = this.options.sortAscending, function (e, t) {
                for (var r = 0; r < i.length; r++) {
                    var o = i[r],
                        s = e.sortData[o],
                        a = t.sortData[o];
                    if (a < s || s < a) return (a < s ? 1 : -1) * ((void 0 !== n[o] ? n[o] : n) ? 1 : -1)
                }
                return 0
            });
            this.filteredItems.sort(t)
        }
        var i, n
    }, u._getIsSameSortBy = function (e) {
        for (var t = 0; t < e.length; t++)
            if (e[t] != this.sortHistory[t]) return !1;
        return !0
    }, u._mode = function () {
        var e = this.options.layoutMode,
            t = this.modes[e];
        if (!t) throw new Error("No layout mode: " + e);
        return t.options = this.options[e], t
    }, u._resetLayout = function () {
        t.prototype._resetLayout.call(this), this._mode()._resetLayout()
    }, u._getItemLayoutPosition = function (e) {
        return this._mode()._getItemLayoutPosition(e)
    }, u._manageStamp = function (e) {
        this._mode()._manageStamp(e)
    }, u._getContainerSize = function () {
        return this._mode()._getContainerSize()
    }, u.needsResizeLayout = function () {
        return this._mode().needsResizeLayout()
    }, u.appended = function (e) {
        var t = this.addItems(e);
        if (t.length) {
            var i = this._filterRevealAdded(t);
            this.filteredItems = this.filteredItems.concat(i)
        }
    }, u.prepended = function (e) {
        var t = this._itemize(e);
        if (t.length) {
            this._resetLayout(), this._manageStamps();
            var i = this._filterRevealAdded(t);
            this.layoutItems(this.filteredItems), this.filteredItems = i.concat(this.filteredItems), this.items = t.concat(this.items)
        }
    }, u._filterRevealAdded = function (e) {
        var t = this._filter(e);
        return this.hide(t.needHide), this.reveal(t.matches), this.layoutItems(t.matches, !0), t.matches
    }, u.insert = function (e) {
        var t = this.addItems(e);
        if (t.length) {
            var i, n, r = t.length;
            for (i = 0; i < r; i++) n = t[i], this.element.appendChild(n.element);
            var o = this._filter(t).matches;
            for (i = 0; i < r; i++) t[i].isLayoutInstant = !0;
            for (this.arrange(), i = 0; i < r; i++) delete t[i].isLayoutInstant;
            this.reveal(o)
        }
    };
    var d = u.remove;
    return u.remove = function (e) {
        e = r.makeArray(e);
        var t = this.getItems(e);
        d.call(this, e);
        for (var i = t && t.length, n = 0; i && n < i; n++) {
            var o = t[n];
            r.removeFrom(this.filteredItems, o)
        }
    }, u.shuffle = function () {
        for (var e = 0; e < this.items.length; e++) this.items[e].sortData.random = Math.random();
        this.options.sortBy = "random", this._sort(), this._layout()
    }, u._noTransition = function (e, t) {
        var i = this.options.transitionDuration;
        this.options.transitionDuration = 0;
        var n = e.apply(this, t);
        return this.options.transitionDuration = i, n
    }, u.getFilteredItemElements = function () {
        return this.filteredItems.map((function (e) {
            return e.element
        }))
    }, c
})),
function (e) {
    "function" == typeof define && define.amd ? define(["jquery"], e) : e(jQuery)
}((function (e) {
    e.ui = e.ui || {}, e.ui.version = "1.12.1";
    var t, i = 0,
        n = Array.prototype.slice;
    e.cleanData = (t = e.cleanData, function (i) {
        for (var n, r, o = 0; null != (r = i[o]); o++) try {
            (n = e._data(r, "events")) && n.remove && e(r).triggerHandler("remove")
        } catch (i) {}
        t(i)
    }), e.widget = function (t, i, n) {
        var r, o, s, a = {},
            l = t.split(".")[0],
            c = l + "-" + (t = t.split(".")[1]);
        return n || (n = i, i = e.Widget), e.isArray(n) && (n = e.extend.apply(null, [{}].concat(n))), e.expr[":"][c.toLowerCase()] = function (t) {
            return !!e.data(t, c)
        }, e[l] = e[l] || {}, r = e[l][t], o = e[l][t] = function (e, t) {
            if (!this._createWidget) return new o(e, t);
            arguments.length && this._createWidget(e, t)
        }, e.extend(o, r, {
            version: n.version,
            _proto: e.extend({}, n),
            _childConstructors: []
        }), (s = new i).options = e.widget.extend({}, s.options), e.each(n, (function (t, n) {
            function r() {
                return i.prototype[t].apply(this, arguments)
            }

            function o(e) {
                return i.prototype[t].apply(this, e)
            }
            e.isFunction(n) ? a[t] = function () {
                var e, t = this._super,
                    i = this._superApply;
                return this._super = r, this._superApply = o, e = n.apply(this, arguments), this._super = t, this._superApply = i, e
            } : a[t] = n
        })), o.prototype = e.widget.extend(s, {
            widgetEventPrefix: r && s.widgetEventPrefix || t
        }, a, {
            constructor: o,
            namespace: l,
            widgetName: t,
            widgetFullName: c
        }), r ? (e.each(r._childConstructors, (function (t, i) {
            var n = i.prototype;
            e.widget(n.namespace + "." + n.widgetName, o, i._proto)
        })), delete r._childConstructors) : i._childConstructors.push(o), e.widget.bridge(t, o), o
    }, e.widget.extend = function (t) {
        for (var i, r, o = n.call(arguments, 1), s = 0, a = o.length; s < a; s++)
            for (i in o[s]) r = o[s][i], o[s].hasOwnProperty(i) && void 0 !== r && (e.isPlainObject(r) ? t[i] = e.isPlainObject(t[i]) ? e.widget.extend({}, t[i], r) : e.widget.extend({}, r) : t[i] = r);
        return t
    }, e.widget.bridge = function (t, i) {
        var r = i.prototype.widgetFullName || t;
        e.fn[t] = function (o) {
            var s = "string" == typeof o,
                a = n.call(arguments, 1),
                l = this;
            return s ? this.length || "instance" !== o ? this.each((function () {
                var i, n = e.data(this, r);
                return "instance" === o ? (l = n, !1) : n ? e.isFunction(n[o]) && "_" !== o.charAt(0) ? (i = n[o].apply(n, a)) !== n && void 0 !== i ? (l = i && i.jquery ? l.pushStack(i.get()) : i, !1) : void 0 : e.error("no such method '" + o + "' for " + t + " widget instance") : e.error("cannot call methods on " + t + " prior to initialization; attempted to call method '" + o + "'")
            })) : l = void 0 : (a.length && (o = e.widget.extend.apply(null, [o].concat(a))), this.each((function () {
                var t = e.data(this, r);
                t ? (t.option(o || {}), t._init && t._init()) : e.data(this, r, new i(o, this))
            }))), l
        }
    }, e.Widget = function () {}, e.Widget._childConstructors = [], e.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            classes: {},
            disabled: !1,
            create: null
        },
        _createWidget: function (t, n) {
            n = e(n || this.defaultElement || this)[0], this.element = e(n), this.uuid = i++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = e(), this.hoverable = e(), this.focusable = e(), this.classesElementLookup = {}, n !== this && (e.data(n, this.widgetFullName, this), this._on(!0, this.element, {
                remove: function (e) {
                    e.target === n && this.destroy()
                }
            }), this.document = e(n.style ? n.ownerDocument : n.document || n), this.window = e(this.document[0].defaultView || this.document[0].parentWindow)), this.options = e.widget.extend({}, this.options, this._getCreateOptions(), t), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init()
        },
        _getCreateOptions: function () {
            return {}
        },
        _getCreateEventData: e.noop,
        _create: e.noop,
        _init: e.noop,
        destroy: function () {
            var t = this;
            this._destroy(), e.each(this.classesElementLookup, (function (e, i) {
                t._removeClass(i, e)
            })), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace)
        },
        _destroy: e.noop,
        widget: function () {
            return this.element
        },
        option: function (t, i) {
            var n, r, o, s = t;
            if (0 === arguments.length) return e.widget.extend({}, this.options);
            if ("string" == typeof t)
                if (s = {}, t = (n = t.split(".")).shift(), n.length) {
                    for (r = s[t] = e.widget.extend({}, this.options[t]), o = 0; o < n.length - 1; o++) r[n[o]] = r[n[o]] || {}, r = r[n[o]];
                    if (t = n.pop(), 1 === arguments.length) return void 0 === r[t] ? null : r[t];
                    r[t] = i
                } else {
                    if (1 === arguments.length) return void 0 === this.options[t] ? null : this.options[t];
                    s[t] = i
                } return this._setOptions(s), this
        },
        _setOptions: function (e) {
            for (var t in e) this._setOption(t, e[t]);
            return this
        },
        _setOption: function (e, t) {
            return "classes" === e && this._setOptionClasses(t), this.options[e] = t, "disabled" === e && this._setOptionDisabled(t), this
        },
        _setOptionClasses: function (t) {
            var i, n, r;
            for (i in t) r = this.classesElementLookup[i], t[i] !== this.options.classes[i] && r && r.length && (n = e(r.get()), this._removeClass(r, i), n.addClass(this._classes({
                element: n,
                keys: i,
                classes: t,
                add: !0
            })))
        },
        _setOptionDisabled: function (e) {
            this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!e), e && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus"))
        },
        enable: function () {
            return this._setOptions({
                disabled: !1
            })
        },
        disable: function () {
            return this._setOptions({
                disabled: !0
            })
        },
        _classes: function (t) {
            var i = [],
                n = this;

            function r(r, o) {
                for (var s, a = 0; a < r.length; a++) s = n.classesElementLookup[r[a]] || e(), s = t.add ? e(e.unique(s.get().concat(t.element.get()))) : e(s.not(t.element).get()), n.classesElementLookup[r[a]] = s, i.push(r[a]), o && t.classes[r[a]] && i.push(t.classes[r[a]])
            }
            return t = e.extend({
                element: this.element,
                classes: this.options.classes || {}
            }, t), this._on(t.element, {
                remove: "_untrackClassesElement"
            }), t.keys && r(t.keys.match(/\S+/g) || [], !0), t.extra && r(t.extra.match(/\S+/g) || []), i.join(" ")
        },
        _untrackClassesElement: function (t) {
            var i = this;
            e.each(i.classesElementLookup, (function (n, r) {
                -1 !== e.inArray(t.target, r) && (i.classesElementLookup[n] = e(r.not(t.target).get()))
            }))
        },
        _removeClass: function (e, t, i) {
            return this._toggleClass(e, t, i, !1)
        },
        _addClass: function (e, t, i) {
            return this._toggleClass(e, t, i, !0)
        },
        _toggleClass: function (e, t, i, n) {
            n = "boolean" == typeof n ? n : i;
            var r = "string" == typeof e || null === e;
            return (e = {
                extra: r ? t : i,
                keys: r ? e : t,
                element: r ? this.element : e,
                add: n
            }).element.toggleClass(this._classes(e), n), this
        },
        _on: function (t, i, n) {
            var r, o = this;
            "boolean" != typeof t && (n = i, i = t, t = !1), n ? (i = r = e(i), this.bindings = this.bindings.add(i)) : (n = i, i = this.element, r = this.widget()), e.each(n, (function (n, s) {
                function a() {
                    if (t || !0 !== o.options.disabled && !e(this).hasClass("ui-state-disabled")) return ("string" == typeof s ? o[s] : s).apply(o, arguments)
                }
                var l;
                "string" != typeof s && (a.guid = s.guid = s.guid || a.guid || e.guid++), n = (l = n.match(/^([\w:-]*)\s*(.*)$/))[1] + o.eventNamespace, (l = l[2]) ? r.on(n, l, a) : i.on(n, a)
            }))
        },
        _off: function (t, i) {
            i = (i || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, t.off(i).off(i), this.bindings = e(this.bindings.not(t).get()), this.focusable = e(this.focusable.not(t).get()), this.hoverable = e(this.hoverable.not(t).get())
        },
        _delay: function (e, t) {
            var i = this;
            return setTimeout((function () {
                return ("string" == typeof e ? i[e] : e).apply(i, arguments)
            }), t || 0)
        },
        _hoverable: function (t) {
            this.hoverable = this.hoverable.add(t), this._on(t, {
                mouseenter: function (t) {
                    this._addClass(e(t.currentTarget), null, "ui-state-hover")
                },
                mouseleave: function (t) {
                    this._removeClass(e(t.currentTarget), null, "ui-state-hover")
                }
            })
        },
        _focusable: function (t) {
            this.focusable = this.focusable.add(t), this._on(t, {
                focusin: function (t) {
                    this._addClass(e(t.currentTarget), null, "ui-state-focus")
                },
                focusout: function (t) {
                    this._removeClass(e(t.currentTarget), null, "ui-state-focus")
                }
            })
        },
        _trigger: function (t, i, n) {
            var r, o, s = this.options[t];
            if (n = n || {}, (i = e.Event(i)).type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(), i.target = this.element[0], o = i.originalEvent)
                for (r in o) r in i || (i[r] = o[r]);
            return this.element.trigger(i, n), !(e.isFunction(s) && !1 === s.apply(this.element[0], [i].concat(n)) || i.isDefaultPrevented())
        }
    }, e.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, (function (t, i) {
        e.Widget.prototype["_" + t] = function (n, r, o) {
            var s;
            "string" == typeof r && (r = {
                effect: r
            });
            var a = r ? !0 !== r && "number" != typeof r && r.effect || i : t;
            "number" == typeof (r = r || {}) && (r = {
                duration: r
            }), s = !e.isEmptyObject(r), r.complete = o, r.delay && n.delay(r.delay), s && e.effects && e.effects.effect[a] ? n[t](r) : a !== t && n[a] ? n[a](r.duration, r.easing, o) : n.queue((function (i) {
                e(this)[t](), o && o.call(n[0]), i()
            }))
        }
    })), e.widget, e.ui.keyCode = {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
    }, e.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    var r = !1;
    e(document).on("mouseup", (function () {
        r = !1
    })), e.widget("ui.mouse", {
        version: "1.12.1",
        options: {
            cancel: "input, textarea, button, select, option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function () {
            var t = this;
            this.element.on("mousedown." + this.widgetName, (function (e) {
                return t._mouseDown(e)
            })).on("click." + this.widgetName, (function (i) {
                if (!0 === e.data(i.target, t.widgetName + ".preventClickEvent")) return e.removeData(i.target, t.widgetName + ".preventClickEvent"), i.stopImmediatePropagation(), !1
            })), this.started = !1
        },
        _mouseDestroy: function () {
            this.element.off("." + this.widgetName), this._mouseMoveDelegate && this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate)
        },
        _mouseDown: function (t) {
            if (!r) {
                this._mouseMoved = !1, this._mouseStarted && this._mouseUp(t), this._mouseDownEvent = t;
                var i = this,
                    n = 1 === t.which,
                    o = !("string" != typeof this.options.cancel || !t.target.nodeName) && e(t.target).closest(this.options.cancel).length;
                return !(n && !o && this._mouseCapture(t)) || (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout((function () {
                    i.mouseDelayMet = !0
                }), this.options.delay)), this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(t), !this._mouseStarted) ? (t.preventDefault(), !0) : (!0 === e.data(t.target, this.widgetName + ".preventClickEvent") && e.removeData(t.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (e) {
                    return i._mouseMove(e)
                }, this._mouseUpDelegate = function (e) {
                    return i._mouseUp(e)
                }, this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate), t.preventDefault(), r = !0))
            }
        },
        _mouseMove: function (t) {
            if (this._mouseMoved) {
                if (e.ui.ie && (!document.documentMode || document.documentMode < 9) && !t.button) return this._mouseUp(t);
                if (!t.which)
                    if (t.originalEvent.altKey || t.originalEvent.ctrlKey || t.originalEvent.metaKey || t.originalEvent.shiftKey) this.ignoreMissingWhich = !0;
                    else if (!this.ignoreMissingWhich) return this._mouseUp(t)
            }
            return (t.which || t.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(t), t.preventDefault()) : (this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(this._mouseDownEvent, t), this._mouseStarted ? this._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted)
        },
        _mouseUp: function (t) {
            this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, t.target === this._mouseDownEvent.target && e.data(t.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(t)), this._mouseDelayTimer && (clearTimeout(this._mouseDelayTimer), delete this._mouseDelayTimer), this.ignoreMissingWhich = !1, r = !1, t.preventDefault()
        },
        _mouseDistanceMet: function (e) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - e.pageX), Math.abs(this._mouseDownEvent.pageY - e.pageY)) >= this.options.distance
        },
        _mouseDelayMet: function () {
            return this.mouseDelayMet
        },
        _mouseStart: function () {},
        _mouseDrag: function () {},
        _mouseStop: function () {},
        _mouseCapture: function () {
            return !0
        }
    }), e.widget("ui.slider", e.ui.mouse, {
        version: "1.12.1",
        widgetEventPrefix: "slide",
        options: {
            animate: !1,
            classes: {
                "ui-slider": "ui-corner-all",
                "ui-slider-handle": "ui-corner-all",
                "ui-slider-range": "ui-corner-all ui-widget-header"
            },
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: !1,
            step: 1,
            value: 0,
            values: null,
            change: null,
            slide: null,
            start: null,
            stop: null
        },
        numPages: 5,
        _create: function () {
            this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content"), this._refresh(), this._animateOff = !1
        },
        _refresh: function () {
            this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue()
        },
        _createHandles: function () {
            var t, i = this.options,
                n = this.element.find(".ui-slider-handle"),
                r = [],
                o = i.values && i.values.length || 1;
            for (n.length > o && (n.slice(o).remove(), n = n.slice(0, o)), t = n.length; t < o; t++) r.push("<span tabindex='0'></span>");
            this.handles = n.add(e(r.join("")).appendTo(this.element)), this._addClass(this.handles, "ui-slider-handle", "ui-state-default"), this.handle = this.handles.eq(0), this.handles.each((function (t) {
                e(this).data("ui-slider-handle-index", t).attr("tabIndex", 0)
            }))
        },
        _createRange: function () {
            var t = this.options;
            t.range ? (!0 === t.range && (t.values ? t.values.length && 2 !== t.values.length ? t.values = [t.values[0], t.values[0]] : e.isArray(t.values) && (t.values = t.values.slice(0)) : t.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? (this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max"), this.range.css({
                left: "",
                bottom: ""
            })) : (this.range = e("<div>").appendTo(this.element), this._addClass(this.range, "ui-slider-range")), "min" !== t.range && "max" !== t.range || this._addClass(this.range, "ui-slider-range-" + t.range)) : (this.range && this.range.remove(), this.range = null)
        },
        _setupEvents: function () {
            this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), this._focusable(this.handles)
        },
        _destroy: function () {
            this.handles.remove(), this.range && this.range.remove(), this._mouseDestroy()
        },
        _mouseCapture: function (t) {
            var i, n, r, o, s, a, l = this,
                c = this.options;
            return !c.disabled && (this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            }, this.elementOffset = this.element.offset(), a = {
                x: t.pageX,
                y: t.pageY
            }, i = this._normValueFromMouse(a), n = this._valueMax() - this._valueMin() + 1, this.handles.each((function (t) {
                var s = Math.abs(i - l.values(t));
                (s < n || n === s && (t === l._lastChangedValue || l.values(t) === c.min)) && (n = s, r = e(this), o = t)
            })), !1 !== this._start(t, o) && (this._mouseSliding = !0, this._handleIndex = o, this._addClass(r, null, "ui-state-active"), r.trigger("focus"), s = r.offset(), a = !e(t.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = a ? {
                left: 0,
                top: 0
            } : {
                left: t.pageX - s.left - r.width() / 2,
                top: t.pageY - s.top - r.height() / 2 - (parseInt(r.css("borderTopWidth"), 10) || 0) - (parseInt(r.css("borderBottomWidth"), 10) || 0) + (parseInt(r.css("marginTop"), 10) || 0)
            }, this.handles.hasClass("ui-state-hover") || this._slide(t, o, i), this._animateOff = !0))
        },
        _mouseStart: function () {
            return !0
        },
        _mouseDrag: function (e) {
            var t = {
                x: e.pageX,
                y: e.pageY
            };
            return t = this._normValueFromMouse(t), this._slide(e, this._handleIndex, t), !1
        },
        _mouseStop: function (e) {
            return this._removeClass(this.handles, null, "ui-state-active"), this._mouseSliding = !1, this._stop(e, this._handleIndex), this._change(e, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1
        },
        _detectOrientation: function () {
            this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal"
        },
        _normValueFromMouse: function (e) {
            var t;
            return 1 < (e = (e = "horizontal" === this.orientation ? (t = this.elementSize.width, e.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (t = this.elementSize.height, e.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0))) / t) && (e = 1), e < 0 && (e = 0), "vertical" === this.orientation && (e = 1 - e), t = this._valueMax() - this._valueMin(), t = this._valueMin() + e * t, this._trimAlignValue(t)
        },
        _uiHash: function (e, t, i) {
            var n = {
                handle: this.handles[e],
                handleIndex: e,
                value: void 0 !== t ? t : this.value()
            };
            return this._hasMultipleValues() && (n.value = void 0 !== t ? t : this.values(e), n.values = i || this.values()), n
        },
        _hasMultipleValues: function () {
            return this.options.values && this.options.values.length
        },
        _start: function (e, t) {
            return this._trigger("start", e, this._uiHash(t))
        },
        _slide: function (e, t, i) {
            var n, r = this.value(),
                o = this.values();
            this._hasMultipleValues() && (n = this.values(t ? 0 : 1), r = this.values(t), 2 === this.options.values.length && !0 === this.options.range && (i = 0 === t ? Math.min(n, i) : Math.max(n, i)), o[t] = i), i !== r && !1 !== this._trigger("slide", e, this._uiHash(t, i, o)) && (this._hasMultipleValues() ? this.values(t, i) : this.value(i))
        },
        _stop: function (e, t) {
            this._trigger("stop", e, this._uiHash(t))
        },
        _change: function (e, t) {
            this._keySliding || this._mouseSliding || (this._lastChangedValue = t, this._trigger("change", e, this._uiHash(t)))
        },
        value: function (e) {
            return arguments.length ? (this.options.value = this._trimAlignValue(e), this._refreshValue(), void this._change(null, 0)) : this._value()
        },
        values: function (t, i) {
            var n, r, o;
            if (1 < arguments.length) return this.options.values[t] = this._trimAlignValue(i), this._refreshValue(), void this._change(null, t);
            if (!arguments.length) return this._values();
            if (!e.isArray(t)) return this._hasMultipleValues() ? this._values(t) : this.value();
            for (n = this.options.values, r = t, o = 0; o < n.length; o += 1) n[o] = this._trimAlignValue(r[o]), this._change(null, o);
            this._refreshValue()
        },
        _setOption: function (t, i) {
            var n, r = 0;
            switch ("range" === t && !0 === this.options.range && ("min" === i ? (this.options.value = this._values(0), this.options.values = null) : "max" === i && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), e.isArray(this.options.values) && (r = this.options.values.length), this._super(t, i), t) {
                case "orientation":
                    this._detectOrientation(), this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation), this._refreshValue(), this.options.range && this._refreshRange(i), this.handles.css("horizontal" === i ? "bottom" : "left", "");
                    break;
                case "value":
                    this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
                    break;
                case "values":
                    for (this._animateOff = !0, this._refreshValue(), n = r - 1; 0 <= n; n--) this._change(null, n);
                    this._animateOff = !1;
                    break;
                case "step":
                case "min":
                case "max":
                    this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this._animateOff = !1;
                    break;
                case "range":
                    this._animateOff = !0, this._refresh(), this._animateOff = !1
            }
        },
        _setOptionDisabled: function (e) {
            this._super(e), this._toggleClass(null, "ui-state-disabled", !!e)
        },
        _value: function () {
            var e = this.options.value;
            return this._trimAlignValue(e)
        },
        _values: function (e) {
            var t, i, n;
            if (arguments.length) return t = this.options.values[e], this._trimAlignValue(t);
            if (this._hasMultipleValues()) {
                for (i = this.options.values.slice(), n = 0; n < i.length; n += 1) i[n] = this._trimAlignValue(i[n]);
                return i
            }
            return []
        },
        _trimAlignValue: function (e) {
            if (e <= this._valueMin()) return this._valueMin();
            if (e >= this._valueMax()) return this._valueMax();
            var t = 0 < this.options.step ? this.options.step : 1,
                i = (e - this._valueMin()) % t;
            return e -= i, 2 * Math.abs(i) >= t && (e += 0 < i ? t : -t), parseFloat(e.toFixed(5))
        },
        _calculateNewMax: function () {
            var e = this.options.max,
                t = this._valueMin(),
                i = this.options.step;
            (e = Math.round((e - t) / i) * i + t) > this.options.max && (e -= i), this.max = parseFloat(e.toFixed(this._precision()))
        },
        _precision: function () {
            var e = this._precisionOf(this.options.step);
            return null !== this.options.min && (e = Math.max(e, this._precisionOf(this.options.min))), e
        },
        _precisionOf: function (e) {
            var t = e.toString();
            return -1 === (e = t.indexOf(".")) ? 0 : t.length - e - 1
        },
        _valueMin: function () {
            return this.options.min
        },
        _valueMax: function () {
            return this.max
        },
        _refreshRange: function (e) {
            "vertical" === e && this.range.css({
                width: "",
                left: ""
            }), "horizontal" === e && this.range.css({
                height: "",
                bottom: ""
            })
        },
        _refreshValue: function () {
            var t, i, n, r, o, s = this.options.range,
                a = this.options,
                l = this,
                c = !this._animateOff && a.animate,
                u = {};
            this._hasMultipleValues() ? this.handles.each((function (n) {
                i = (l.values(n) - l._valueMin()) / (l._valueMax() - l._valueMin()) * 100, u["horizontal" === l.orientation ? "left" : "bottom"] = i + "%", e(this).stop(1, 1)[c ? "animate" : "css"](u, a.animate), !0 === l.options.range && ("horizontal" === l.orientation ? (0 === n && l.range.stop(1, 1)[c ? "animate" : "css"]({
                    left: i + "%"
                }, a.animate), 1 === n && l.range[c ? "animate" : "css"]({
                    width: i - t + "%"
                }, {
                    queue: !1,
                    duration: a.animate
                })) : (0 === n && l.range.stop(1, 1)[c ? "animate" : "css"]({
                    bottom: i + "%"
                }, a.animate), 1 === n && l.range[c ? "animate" : "css"]({
                    height: i - t + "%"
                }, {
                    queue: !1,
                    duration: a.animate
                }))), t = i
            })) : (n = this.value(), r = this._valueMin(), o = this._valueMax(), i = o !== r ? (n - r) / (o - r) * 100 : 0, u["horizontal" === this.orientation ? "left" : "bottom"] = i + "%", this.handle.stop(1, 1)[c ? "animate" : "css"](u, a.animate), "min" === s && "horizontal" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
                width: i + "%"
            }, a.animate), "max" === s && "horizontal" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
                width: 100 - i + "%"
            }, a.animate), "min" === s && "vertical" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
                height: i + "%"
            }, a.animate), "max" === s && "vertical" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
                height: 100 - i + "%"
            }, a.animate))
        },
        _handleEvents: {
            keydown: function (t) {
                var i, n, r, o = e(t.target).data("ui-slider-handle-index");
                switch (t.keyCode) {
                    case e.ui.keyCode.HOME:
                    case e.ui.keyCode.END:
                    case e.ui.keyCode.PAGE_UP:
                    case e.ui.keyCode.PAGE_DOWN:
                    case e.ui.keyCode.UP:
                    case e.ui.keyCode.RIGHT:
                    case e.ui.keyCode.DOWN:
                    case e.ui.keyCode.LEFT:
                        if (t.preventDefault(), !this._keySliding && (this._keySliding = !0, this._addClass(e(t.target), null, "ui-state-active"), !1 === this._start(t, o))) return
                }
                switch (r = this.options.step, i = n = this._hasMultipleValues() ? this.values(o) : this.value(), t.keyCode) {
                    case e.ui.keyCode.HOME:
                        n = this._valueMin();
                        break;
                    case e.ui.keyCode.END:
                        n = this._valueMax();
                        break;
                    case e.ui.keyCode.PAGE_UP:
                        n = this._trimAlignValue(i + (this._valueMax() - this._valueMin()) / this.numPages);
                        break;
                    case e.ui.keyCode.PAGE_DOWN:
                        n = this._trimAlignValue(i - (this._valueMax() - this._valueMin()) / this.numPages);
                        break;
                    case e.ui.keyCode.UP:
                    case e.ui.keyCode.RIGHT:
                        if (i === this._valueMax()) return;
                        n = this._trimAlignValue(i + r);
                        break;
                    case e.ui.keyCode.DOWN:
                    case e.ui.keyCode.LEFT:
                        if (i === this._valueMin()) return;
                        n = this._trimAlignValue(i - r)
                }
                this._slide(t, o, n)
            },
            keyup: function (t) {
                var i = e(t.target).data("ui-slider-handle-index");
                this._keySliding && (this._keySliding = !1, this._stop(t, i), this._change(t, i), this._removeClass(e(t.target), null, "ui-state-active"))
            }
        }
    })
})),
function () {
    "use strict";

    function e(n) {
        if (!n) throw new Error("No options passed to Waypoint constructor");
        if (!n.element) throw new Error("No element option passed to Waypoint constructor");
        if (!n.handler) throw new Error("No handler option passed to Waypoint constructor");
        this.key = "waypoint-" + t, this.options = e.Adapter.extend({}, e.defaults, n), this.element = this.options.element, this.adapter = new e.Adapter(this.element), this.callback = n.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = e.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        }), this.context = e.Context.findOrCreateByElement(this.options.context), e.offsetAliases[this.options.offset] && (this.options.offset = e.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), i[this.key] = this, t += 1
    }
    var t = 0,
        i = {};
    e.prototype.queueTrigger = function (e) {
        this.group.queueTrigger(this, e)
    }, e.prototype.trigger = function (e) {
        this.enabled && this.callback && this.callback.apply(this, e)
    }, e.prototype.destroy = function () {
        this.context.remove(this), this.group.remove(this), delete i[this.key]
    }, e.prototype.disable = function () {
        return this.enabled = !1, this
    }, e.prototype.enable = function () {
        return this.context.refresh(), this.enabled = !0, this
    }, e.prototype.next = function () {
        return this.group.next(this)
    }, e.prototype.previous = function () {
        return this.group.previous(this)
    }, e.invokeAll = function (e) {
        var t = [];
        for (var n in i) t.push(i[n]);
        for (var r = 0, o = t.length; o > r; r++) t[r][e]()
    }, e.destroyAll = function () {
        e.invokeAll("destroy")
    }, e.disableAll = function () {
        e.invokeAll("disable")
    }, e.enableAll = function () {
        e.invokeAll("enable")
    }, e.refreshAll = function () {
        e.Context.refreshAll()
    }, e.viewportHeight = function () {
        return window.innerHeight || document.documentElement.clientHeight
    }, e.viewportWidth = function () {
        return document.documentElement.clientWidth
    }, e.adapters = [], e.defaults = {
        context: window,
        continuous: !0,
        enabled: !0,
        group: "default",
        horizontal: !1,
        offset: 0
    }, e.offsetAliases = {
        "bottom-in-view": function () {
            return this.context.innerHeight() - this.adapter.outerHeight()
        },
        "right-in-view": function () {
            return this.context.innerWidth() - this.adapter.outerWidth()
        }
    }, window.Waypoint = e
}(),
function () {
    "use strict";

    function e(e) {
        window.setTimeout(e, 1e3 / 60)
    }

    function t(e) {
        this.element = e, this.Adapter = r.Adapter, this.adapter = new this.Adapter(e), this.key = "waypoint-context-" + i, this.didScroll = !1, this.didResize = !1, this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        }, this.waypoints = {
            vertical: {},
            horizontal: {}
        }, e.waypointContextKey = this.key, n[e.waypointContextKey] = this, i += 1, this.createThrottledScrollHandler(), this.createThrottledResizeHandler()
    }
    var i = 0,
        n = {},
        r = window.Waypoint,
        o = window.onload;
    t.prototype.add = function (e) {
        var t = e.options.horizontal ? "horizontal" : "vertical";
        this.waypoints[t][e.key] = e, this.refresh()
    }, t.prototype.checkEmpty = function () {
        var e = this.Adapter.isEmptyObject(this.waypoints.horizontal),
            t = this.Adapter.isEmptyObject(this.waypoints.vertical);
        e && t && (this.adapter.off(".waypoints"), delete n[this.key])
    }, t.prototype.createThrottledResizeHandler = function () {
        function e() {
            t.handleResize(), t.didResize = !1
        }
        var t = this;
        this.adapter.on("resize.waypoints", (function () {
            t.didResize || (t.didResize = !0, r.requestAnimationFrame(e))
        }))
    }, t.prototype.createThrottledScrollHandler = function () {
        function e() {
            t.handleScroll(), t.didScroll = !1
        }
        var t = this;
        this.adapter.on("scroll.waypoints", (function () {
            (!t.didScroll || r.isTouch) && (t.didScroll = !0, r.requestAnimationFrame(e))
        }))
    }, t.prototype.handleResize = function () {
        r.Context.refreshAll()
    }, t.prototype.handleScroll = function () {
        var e = {},
            t = {
                horizontal: {
                    newScroll: this.adapter.scrollLeft(),
                    oldScroll: this.oldScroll.x,
                    forward: "right",
                    backward: "left"
                },
                vertical: {
                    newScroll: this.adapter.scrollTop(),
                    oldScroll: this.oldScroll.y,
                    forward: "down",
                    backward: "up"
                }
            };
        for (var i in t) {
            var n = t[i],
                r = n.newScroll > n.oldScroll ? n.forward : n.backward;
            for (var o in this.waypoints[i]) {
                var s = this.waypoints[i][o],
                    a = n.oldScroll < s.triggerPoint,
                    l = n.newScroll >= s.triggerPoint;
                (a && l || !a && !l) && (s.queueTrigger(r), e[s.group.id] = s.group)
            }
        }
        for (var c in e) e[c].flushTriggers();
        this.oldScroll = {
            x: t.horizontal.newScroll,
            y: t.vertical.newScroll
        }
    }, t.prototype.innerHeight = function () {
        return this.element == this.element.window ? r.viewportHeight() : this.adapter.innerHeight()
    }, t.prototype.remove = function (e) {
        delete this.waypoints[e.axis][e.key], this.checkEmpty()
    }, t.prototype.innerWidth = function () {
        return this.element == this.element.window ? r.viewportWidth() : this.adapter.innerWidth()
    }, t.prototype.destroy = function () {
        var e = [];
        for (var t in this.waypoints)
            for (var i in this.waypoints[t]) e.push(this.waypoints[t][i]);
        for (var n = 0, r = e.length; r > n; n++) e[n].destroy()
    }, t.prototype.refresh = function () {
        var e, t = this.element == this.element.window,
            i = t ? void 0 : this.adapter.offset(),
            n = {};
        for (var o in this.handleScroll(), e = {
                horizontal: {
                    contextOffset: t ? 0 : i.left,
                    contextScroll: t ? 0 : this.oldScroll.x,
                    contextDimension: this.innerWidth(),
                    oldScroll: this.oldScroll.x,
                    forward: "right",
                    backward: "left",
                    offsetProp: "left"
                },
                vertical: {
                    contextOffset: t ? 0 : i.top,
                    contextScroll: t ? 0 : this.oldScroll.y,
                    contextDimension: this.innerHeight(),
                    oldScroll: this.oldScroll.y,
                    forward: "down",
                    backward: "up",
                    offsetProp: "top"
                }
            }) {
            var s = e[o];
            for (var a in this.waypoints[o]) {
                var l, c, u, h, d = this.waypoints[o][a],
                    p = d.options.offset,
                    f = d.triggerPoint,
                    m = 0,
                    g = null == f;
                d.element !== d.element.window && (m = d.adapter.offset()[s.offsetProp]), "function" == typeof p ? p = p.apply(d) : "string" == typeof p && (p = parseFloat(p), d.options.offset.indexOf("%") > -1 && (p = Math.ceil(s.contextDimension * p / 100))), l = s.contextScroll - s.contextOffset, d.triggerPoint = m + l - p, c = f < s.oldScroll, u = d.triggerPoint >= s.oldScroll, h = !c && !u, !g && (c && u) ? (d.queueTrigger(s.backward), n[d.group.id] = d.group) : (!g && h || g && s.oldScroll >= d.triggerPoint) && (d.queueTrigger(s.forward), n[d.group.id] = d.group)
            }
        }
        return r.requestAnimationFrame((function () {
            for (var e in n) n[e].flushTriggers()
        })), this
    }, t.findOrCreateByElement = function (e) {
        return t.findByElement(e) || new t(e)
    }, t.refreshAll = function () {
        for (var e in n) n[e].refresh()
    }, t.findByElement = function (e) {
        return n[e.waypointContextKey]
    }, window.onload = function () {
        o && o(), t.refreshAll()
    }, r.requestAnimationFrame = function (t) {
        (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || e).call(window, t)
    }, r.Context = t
}(),
function () {
    "use strict";

    function e(e, t) {
        return e.triggerPoint - t.triggerPoint
    }

    function t(e, t) {
        return t.triggerPoint - e.triggerPoint
    }

    function i(e) {
        this.name = e.name, this.axis = e.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], this.clearTriggerQueues(), n[this.axis][this.name] = this
    }
    var n = {
            vertical: {},
            horizontal: {}
        },
        r = window.Waypoint;
    i.prototype.add = function (e) {
        this.waypoints.push(e)
    }, i.prototype.clearTriggerQueues = function () {
        this.triggerQueues = {
            up: [],
            down: [],
            left: [],
            right: []
        }
    }, i.prototype.flushTriggers = function () {
        for (var i in this.triggerQueues) {
            var n = this.triggerQueues[i],
                r = "up" === i || "left" === i;
            n.sort(r ? t : e);
            for (var o = 0, s = n.length; s > o; o += 1) {
                var a = n[o];
                (a.options.continuous || o === n.length - 1) && a.trigger([i])
            }
        }
        this.clearTriggerQueues()
    }, i.prototype.next = function (t) {
        this.waypoints.sort(e);
        var i = r.Adapter.inArray(t, this.waypoints);
        return i === this.waypoints.length - 1 ? null : this.waypoints[i + 1]
    }, i.prototype.previous = function (t) {
        this.waypoints.sort(e);
        var i = r.Adapter.inArray(t, this.waypoints);
        return i ? this.waypoints[i - 1] : null
    }, i.prototype.queueTrigger = function (e, t) {
        this.triggerQueues[t].push(e)
    }, i.prototype.remove = function (e) {
        var t = r.Adapter.inArray(e, this.waypoints);
        t > -1 && this.waypoints.splice(t, 1)
    }, i.prototype.first = function () {
        return this.waypoints[0]
    }, i.prototype.last = function () {
        return this.waypoints[this.waypoints.length - 1]
    }, i.findOrCreate = function (e) {
        return n[e.axis][e.name] || new i(e)
    }, r.Group = i
}(),
function () {
    "use strict";

    function e(e) {
        this.$element = t(e)
    }
    var t = window.jQuery,
        i = window.Waypoint;
    t.each(["innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop"], (function (t, i) {
        e.prototype[i] = function () {
            var e = Array.prototype.slice.call(arguments);
            return this.$element[i].apply(this.$element, e)
        }
    })), t.each(["extend", "inArray", "isEmptyObject"], (function (i, n) {
        e[n] = t[n]
    })), i.adapters.push({
        name: "jquery",
        Adapter: e
    }), i.Adapter = e
}(),
function () {
    "use strict";

    function e(e) {
        return function () {
            var i = [],
                n = arguments[0];
            return e.isFunction(arguments[0]) && ((n = e.extend({}, arguments[1])).handler = arguments[0]), this.each((function () {
                var r = e.extend({}, n, {
                    element: this
                });
                "string" == typeof r.context && (r.context = e(this).closest(r.context)[0]), i.push(new t(r))
            })), i
        }
    }
    var t = window.Waypoint;
    window.jQuery && (window.jQuery.fn.waypoint = e(window.jQuery)), window.Zepto && (window.Zepto.fn.waypoint = e(window.Zepto))
}(),
/*!
 * jquery.counterup.js 1.0
 *
 * Copyright 2013, Benjamin Intal http://gambit.ph @bfintal
 * Released under the GPL v2 License
 *
 * Date: Nov 26, 2013
 */
function (e) {
    "use strict";
    e.fn.counterUp = function (t) {
        var i, n = e.extend({
            time: 400,
            delay: 10,
            offset: 100,
            beginAt: 0,
            formatter: !1,
            context: "window",
            callback: function () {}
        }, t);
        return this.each((function () {
            var t = e(this),
                r = {
                    time: e(this).data("counterup-time") || n.time,
                    delay: e(this).data("counterup-delay") || n.delay,
                    offset: e(this).data("counterup-offset") || n.offset,
                    beginAt: e(this).data("counterup-beginat") || n.beginAt,
                    context: e(this).data("counterup-context") || n.context
                };
            t.waypoint((function (o) {
                ! function () {
                    var o = [],
                        s = r.time / r.delay,
                        a = e(this).attr("data-num") ? e(this).attr("data-num") : t.text(),
                        l = /[0-9]+,[0-9]+/.test(a),
                        c = ((a = a.replace(/,/g, "")).split(".")[1] || []).length;
                    r.beginAt > a && (r.beginAt = a);
                    var u = /[0-9]+:[0-9]+:[0-9]+/.test(a);
                    if (u) {
                        var h = a.split(":"),
                            d = 1;
                        for (i = 0; h.length > 0;) i += d * parseInt(h.pop(), 10), d *= 60
                    }
                    for (var p = s; p >= r.beginAt / a * s; p--) {
                        var f = parseFloat(a / s * p).toFixed(c);
                        if (u) {
                            f = parseInt(i / s * p);
                            var m = parseInt(f / 3600) % 24,
                                g = parseInt(f / 60) % 60,
                                v = parseInt(f % 60, 10);
                            f = (m < 10 ? "0" + m : m) + ":" + (g < 10 ? "0" + g : g) + ":" + (v < 10 ? "0" + v : v)
                        }
                        if (l)
                            for (;
                                /(\d+)(\d{3})/.test(f.toString());) f = f.toString().replace(/(\d+)(\d{3})/, "$1,$2");
                        n.formatter && (f = n.formatter.call(this, f)), o.unshift(f)
                    }
                    t.data("counterup-nums", o), t.text(r.beginAt);
                    t.data("counterup-func", (function () {
                        t.data("counterup-nums") ? (t.html(t.data("counterup-nums").shift()), t.data("counterup-nums").length ? setTimeout(t.data("counterup-func"), r.delay) : (t.data("counterup-nums", null), t.data("counterup-func", null), n.callback.call(this))) : n.callback.call(this)
                    })), setTimeout(t.data("counterup-func"), r.delay)
                }(), this.destroy()
            }), {
                offset: r.offset + "%",
                context: r.context
            })
        }))
    }
}(jQuery),
function (e) {
    "function" == typeof define && define.amd ? define(["jquery"], e) : e("object" == typeof exports ? require("jquery") : window.jQuery || window.Zepto)
}((function (e) {
    var t, i, n, r, o, s, a = "Close",
        l = "BeforeClose",
        c = "MarkupParse",
        u = "Open",
        h = "Change",
        d = "mfp",
        p = ".mfp",
        f = "mfp-ready",
        m = "mfp-removing",
        g = "mfp-prevent-close",
        v = function () {},
        y = !!window.jQuery,
        b = e(window),
        x = function (e, i) {
            t.ev.on(d + e + p, i)
        },
        w = function (t, i, n, r) {
            var o = document.createElement("div");
            return o.className = "mfp-" + t, n && (o.innerHTML = n), r ? i && i.appendChild(o) : (o = e(o), i && o.appendTo(i)), o
        },
        _ = function (i, n) {
            t.ev.triggerHandler(d + i, n), t.st.callbacks && (i = i.charAt(0).toLowerCase() + i.slice(1), t.st.callbacks[i] && t.st.callbacks[i].apply(t, e.isArray(n) ? n : [n]))
        },
        E = function (i) {
            return i === s && t.currTemplate.closeBtn || (t.currTemplate.closeBtn = e(t.st.closeMarkup.replace("%title%", t.st.tClose)), s = i), t.currTemplate.closeBtn
        },
        M = function () {
            e.magnificPopup.instance || ((t = new v).init(), e.magnificPopup.instance = t)
        };
    v.prototype = {
        constructor: v,
        init: function () {
            var i = navigator.appVersion;
            t.isLowIE = t.isIE8 = document.all && !document.addEventListener, t.isAndroid = /android/gi.test(i), t.isIOS = /iphone|ipad|ipod/gi.test(i), t.supportsTransition = function () {
                var e = document.createElement("p").style,
                    t = ["ms", "O", "Moz", "Webkit"];
                if (void 0 !== e.transition) return !0;
                for (; t.length;)
                    if (t.pop() + "Transition" in e) return !0;
                return !1
            }(), t.probablyMobile = t.isAndroid || t.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent), n = e(document), t.popupsCache = {}
        },
        open: function (i) {
            var r;
            if (!1 === i.isObj) {
                t.items = i.items.toArray(), t.index = 0;
                var s, a = i.items;
                for (r = 0; r < a.length; r++)
                    if ((s = a[r]).parsed && (s = s.el[0]), s === i.el[0]) {
                        t.index = r;
                        break
                    }
            } else t.items = e.isArray(i.items) ? i.items : [i.items], t.index = i.index || 0;
            if (!t.isOpen) {
                t.types = [], o = "", i.mainEl && i.mainEl.length ? t.ev = i.mainEl.eq(0) : t.ev = n, i.key ? (t.popupsCache[i.key] || (t.popupsCache[i.key] = {}), t.currTemplate = t.popupsCache[i.key]) : t.currTemplate = {}, t.st = e.extend(!0, {}, e.magnificPopup.defaults, i), t.fixedContentPos = "auto" === t.st.fixedContentPos ? !t.probablyMobile : t.st.fixedContentPos, t.st.modal && (t.st.closeOnContentClick = !1, t.st.closeOnBgClick = !1, t.st.showCloseBtn = !1, t.st.enableEscapeKey = !1), t.bgOverlay || (t.bgOverlay = w("bg").on("click" + p, (function () {
                    t.close()
                })), t.wrap = w("wrap").attr("tabindex", -1).on("click" + p, (function (e) {
                    t._checkIfClose(e.target) && t.close()
                })), t.container = w("container", t.wrap)), t.contentContainer = w("content"), t.st.preloader && (t.preloader = w("preloader", t.container, t.st.tLoading));
                var l = e.magnificPopup.modules;
                for (r = 0; r < l.length; r++) {
                    var h = l[r];
                    h = h.charAt(0).toUpperCase() + h.slice(1), t["init" + h].call(t)
                }
                _("BeforeOpen"), t.st.showCloseBtn && (t.st.closeBtnInside ? (x(c, (function (e, t, i, n) {
                    i.close_replaceWith = E(n.type)
                })), o += " mfp-close-btn-in") : t.wrap.append(E())), t.st.alignTop && (o += " mfp-align-top"), t.fixedContentPos ? t.wrap.css({
                    overflow: t.st.overflowY,
                    overflowX: "hidden",
                    overflowY: t.st.overflowY
                }) : t.wrap.css({
                    top: b.scrollTop(),
                    position: "absolute"
                }), (!1 === t.st.fixedBgPos || "auto" === t.st.fixedBgPos && !t.fixedContentPos) && t.bgOverlay.css({
                    height: n.height(),
                    position: "absolute"
                }), t.st.enableEscapeKey && n.on("keyup" + p, (function (e) {
                    27 === e.keyCode && t.close()
                })), b.on("resize" + p, (function () {
                    t.updateSize()
                })), t.st.closeOnContentClick || (o += " mfp-auto-cursor"), o && t.wrap.addClass(o);
                var d = t.wH = b.height(),
                    m = {};
                if (t.fixedContentPos && t._hasScrollBar(d)) {
                    var g = t._getScrollbarSize();
                    g && (m.marginRight = g)
                }
                t.fixedContentPos && (t.isIE7 ? e("body, html").css("overflow", "hidden") : m.overflow = "hidden");
                var v = t.st.mainClass;
                return t.isIE7 && (v += " mfp-ie7"), v && t._addClassToMFP(v), t.updateItemHTML(), _("BuildControls"), e("html").css(m), t.bgOverlay.add(t.wrap).prependTo(t.st.prependTo || e(document.body)), t._lastFocusedEl = document.activeElement, setTimeout((function () {
                    t.content ? (t._addClassToMFP(f), t._setFocus()) : t.bgOverlay.addClass(f), n.on("focusin" + p, t._onFocusIn)
                }), 16), t.isOpen = !0, t.updateSize(d), _(u), i
            }
            t.updateItemHTML()
        },
        close: function () {
            t.isOpen && (_(l), t.isOpen = !1, t.st.removalDelay && !t.isLowIE && t.supportsTransition ? (t._addClassToMFP(m), setTimeout((function () {
                t._close()
            }), t.st.removalDelay)) : t._close())
        },
        _close: function () {
            _(a);
            var i = m + " " + f + " ";
            if (t.bgOverlay.detach(), t.wrap.detach(), t.container.empty(), t.st.mainClass && (i += t.st.mainClass + " "), t._removeClassFromMFP(i), t.fixedContentPos) {
                var r = {
                    marginRight: ""
                };
                t.isIE7 ? e("body, html").css("overflow", "") : r.overflow = "", e("html").css(r)
            }
            n.off("keyup.mfp focusin" + p), t.ev.off(p), t.wrap.attr("class", "mfp-wrap").removeAttr("style"), t.bgOverlay.attr("class", "mfp-bg"), t.container.attr("class", "mfp-container"), !t.st.showCloseBtn || t.st.closeBtnInside && !0 !== t.currTemplate[t.currItem.type] || t.currTemplate.closeBtn && t.currTemplate.closeBtn.detach(), t.st.autoFocusLast && t._lastFocusedEl && e(t._lastFocusedEl).focus(), t.currItem = null, t.content = null, t.currTemplate = null, t.prevHeight = 0, _("AfterClose")
        },
        updateSize: function (e) {
            if (t.isIOS) {
                var i = document.documentElement.clientWidth / window.innerWidth,
                    n = window.innerHeight * i;
                t.wrap.css("height", n), t.wH = n
            } else t.wH = e || b.height();
            t.fixedContentPos || t.wrap.css("height", t.wH), _("Resize")
        },
        updateItemHTML: function () {
            var i = t.items[t.index];
            t.contentContainer.detach(), t.content && t.content.detach(), i.parsed || (i = t.parseEl(t.index));
            var n = i.type;
            if (_("BeforeChange", [t.currItem ? t.currItem.type : "", n]), t.currItem = i, !t.currTemplate[n]) {
                var o = !!t.st[n] && t.st[n].markup;
                _("FirstMarkupParse", o), t.currTemplate[n] = !o || e(o)
            }
            r && r !== i.type && t.container.removeClass("mfp-" + r + "-holder");
            var s = t["get" + n.charAt(0).toUpperCase() + n.slice(1)](i, t.currTemplate[n]);
            t.appendContent(s, n), i.preloaded = !0, _(h, i), r = i.type, t.container.prepend(t.contentContainer), _("AfterChange")
        },
        appendContent: function (e, i) {
            t.content = e, e ? t.st.showCloseBtn && t.st.closeBtnInside && !0 === t.currTemplate[i] ? t.content.find(".mfp-close").length || t.content.append(E()) : t.content = e : t.content = "", _("BeforeAppend"), t.container.addClass("mfp-" + i + "-holder"), t.contentContainer.append(t.content)
        },
        parseEl: function (i) {
            var n, r = t.items[i];
            if (r.tagName ? r = {
                    el: e(r)
                } : (n = r.type, r = {
                    data: r,
                    src: r.src
                }), r.el) {
                for (var o = t.types, s = 0; s < o.length; s++)
                    if (r.el.hasClass("mfp-" + o[s])) {
                        n = o[s];
                        break
                    } r.src = r.el.attr("data-mfp-src"), r.src || (r.src = r.el.attr("href"))
            }
            return r.type = n || t.st.type || "inline", r.index = i, r.parsed = !0, t.items[i] = r, _("ElementParse", r), t.items[i]
        },
        addGroup: function (e, i) {
            var n = function (n) {
                n.mfpEl = this, t._openClick(n, e, i)
            };
            i || (i = {});
            var r = "click.magnificPopup";
            i.mainEl = e, i.items ? (i.isObj = !0, e.off(r).on(r, n)) : (i.isObj = !1, i.delegate ? e.off(r).on(r, i.delegate, n) : (i.items = e, e.off(r).on(r, n)))
        },
        _openClick: function (i, n, r) {
            if ((void 0 !== r.midClick ? r.midClick : e.magnificPopup.defaults.midClick) || !(2 === i.which || i.ctrlKey || i.metaKey || i.altKey || i.shiftKey)) {
                var o = void 0 !== r.disableOn ? r.disableOn : e.magnificPopup.defaults.disableOn;
                if (o)
                    if (e.isFunction(o)) {
                        if (!o.call(t)) return !0
                    } else if (b.width() < o) return !0;
                i.type && (i.preventDefault(), t.isOpen && i.stopPropagation()), r.el = e(i.mfpEl), r.delegate && (r.items = n.find(r.delegate)), t.open(r)
            }
        },
        updateStatus: function (e, n) {
            if (t.preloader) {
                i !== e && t.container.removeClass("mfp-s-" + i), n || "loading" !== e || (n = t.st.tLoading);
                var r = {
                    status: e,
                    text: n
                };
                _("UpdateStatus", r), e = r.status, n = r.text, t.preloader.html(n), t.preloader.find("a").on("click", (function (e) {
                    e.stopImmediatePropagation()
                })), t.container.addClass("mfp-s-" + e), i = e
            }
        },
        _checkIfClose: function (i) {
            if (!e(i).hasClass(g)) {
                var n = t.st.closeOnContentClick,
                    r = t.st.closeOnBgClick;
                if (n && r) return !0;
                if (!t.content || e(i).hasClass("mfp-close") || t.preloader && i === t.preloader[0]) return !0;
                if (i === t.content[0] || e.contains(t.content[0], i)) {
                    if (n) return !0
                } else if (r && e.contains(document, i)) return !0;
                return !1
            }
        },
        _addClassToMFP: function (e) {
            t.bgOverlay.addClass(e), t.wrap.addClass(e)
        },
        _removeClassFromMFP: function (e) {
            this.bgOverlay.removeClass(e), t.wrap.removeClass(e)
        },
        _hasScrollBar: function (e) {
            return (t.isIE7 ? n.height() : document.body.scrollHeight) > (e || b.height())
        },
        _setFocus: function () {
            (t.st.focus ? t.content.find(t.st.focus).eq(0) : t.wrap).focus()
        },
        _onFocusIn: function (i) {
            return i.target === t.wrap[0] || e.contains(t.wrap[0], i.target) ? void 0 : (t._setFocus(), !1)
        },
        _parseMarkup: function (t, i, n) {
            var r;
            n.data && (i = e.extend(n.data, i)), _(c, [t, i, n]), e.each(i, (function (i, n) {
                if (void 0 === n || !1 === n) return !0;
                if ((r = i.split("_")).length > 1) {
                    var o = t.find(p + "-" + r[0]);
                    if (o.length > 0) {
                        var s = r[1];
                        "replaceWith" === s ? o[0] !== n[0] && o.replaceWith(n) : "img" === s ? o.is("img") ? o.attr("src", n) : o.replaceWith(e("<img>").attr("src", n).attr("class", o.attr("class"))) : o.attr(r[1], n)
                    }
                } else t.find(p + "-" + i).html(n)
            }))
        },
        _getScrollbarSize: function () {
            if (void 0 === t.scrollbarSize) {
                var e = document.createElement("div");
                e.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;", document.body.appendChild(e), t.scrollbarSize = e.offsetWidth - e.clientWidth, document.body.removeChild(e)
            }
            return t.scrollbarSize
        }
    }, e.magnificPopup = {
        instance: null,
        proto: v.prototype,
        modules: [],
        open: function (t, i) {
            return M(), (t = t ? e.extend(!0, {}, t) : {}).isObj = !0, t.index = i || 0, this.instance.open(t)
        },
        close: function () {
            return e.magnificPopup.instance && e.magnificPopup.instance.close()
        },
        registerModule: function (t, i) {
            i.options && (e.magnificPopup.defaults[t] = i.options), e.extend(this.proto, i.proto), this.modules.push(t)
        },
        defaults: {
            disableOn: 0,
            key: null,
            midClick: !1,
            mainClass: "",
            preloader: !0,
            focus: "",
            closeOnContentClick: !1,
            closeOnBgClick: !0,
            closeBtnInside: !0,
            showCloseBtn: !0,
            enableEscapeKey: !0,
            modal: !1,
            alignTop: !1,
            removalDelay: 0,
            prependTo: null,
            fixedContentPos: "auto",
            fixedBgPos: "auto",
            overflowY: "auto",
            closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>',
            tClose: "Close (Esc)",
            tLoading: "Loading...",
            autoFocusLast: !0
        }
    }, e.fn.magnificPopup = function (i) {
        M();
        var n = e(this);
        if ("string" == typeof i)
            if ("open" === i) {
                var r, o = y ? n.data("magnificPopup") : n[0].magnificPopup,
                    s = parseInt(arguments[1], 10) || 0;
                o.items ? r = o.items[s] : (r = n, o.delegate && (r = r.find(o.delegate)), r = r.eq(s)), t._openClick({
                    mfpEl: r
                }, n, o)
            } else t.isOpen && t[i].apply(t, Array.prototype.slice.call(arguments, 1));
        else i = e.extend(!0, {}, i), y ? n.data("magnificPopup", i) : n[0].magnificPopup = i, t.addGroup(n, i);
        return n
    };
    var S, T, A, C = "inline",
        L = function () {
            A && (T.after(A.addClass(S)).detach(), A = null)
        };
    e.magnificPopup.registerModule(C, {
        options: {
            hiddenClass: "hide",
            markup: "",
            tNotFound: "Content not found"
        },
        proto: {
            initInline: function () {
                t.types.push(C), x(a + "." + C, (function () {
                    L()
                }))
            },
            getInline: function (i, n) {
                if (L(), i.src) {
                    var r = t.st.inline,
                        o = e(i.src);
                    if (o.length) {
                        var s = o[0].parentNode;
                        s && s.tagName && (T || (S = r.hiddenClass, T = w(S), S = "mfp-" + S), A = o.after(T).detach().removeClass(S)), t.updateStatus("ready")
                    } else t.updateStatus("error", r.tNotFound), o = e("<div>");
                    return i.inlineElement = o, o
                }
                return t.updateStatus("ready"), t._parseMarkup(n, {}, i), n
            }
        }
    });
    var P, I = "ajax",
        O = function () {
            P && e(document.body).removeClass(P)
        },
        R = function () {
            O(), t.req && t.req.abort()
        };
    e.magnificPopup.registerModule(I, {
        options: {
            settings: null,
            cursor: "mfp-ajax-cur",
            tError: '<a href="%url%">The content</a> could not be loaded.'
        },
        proto: {
            initAjax: function () {
                t.types.push(I), P = t.st.ajax.cursor, x(a + "." + I, R), x("BeforeChange." + I, R)
            },
            getAjax: function (i) {
                P && e(document.body).addClass(P), t.updateStatus("loading");
                var n = e.extend({
                    url: i.src,
                    success: function (n, r, o) {
                        var s = {
                            data: n,
                            xhr: o
                        };
                        _("ParseAjax", s), t.appendContent(e(s.data), I), i.finished = !0, O(), t._setFocus(), setTimeout((function () {
                            t.wrap.addClass(f)
                        }), 16), t.updateStatus("ready"), _("AjaxContentAdded")
                    },
                    error: function () {
                        O(), i.finished = i.loadError = !0, t.updateStatus("error", t.st.ajax.tError.replace("%url%", i.src))
                    }
                }, t.st.ajax.settings);
                return t.req = e.ajax(n), ""
            }
        }
    });
    var D, k = function (i) {
        if (i.data && void 0 !== i.data.title) return i.data.title;
        var n = t.st.image.titleSrc;
        if (n) {
            if (e.isFunction(n)) return n.call(t, i);
            if (i.el) return i.el.attr(n) || ""
        }
        return ""
    };
    e.magnificPopup.registerModule("image", {
        options: {
            markup: '<div class="mfp-figure"><div class="mfp-close"></div><figure><div class="mfp-img"></div><figcaption><div class="mfp-bottom-bar"><div class="mfp-title"></div><div class="mfp-counter"></div></div></figcaption></figure></div>',
            cursor: "mfp-zoom-out-cur",
            titleSrc: "title",
            verticalFit: !0,
            tError: '<a href="%url%">The image</a> could not be loaded.'
        },
        proto: {
            initImage: function () {
                var i = t.st.image,
                    n = ".image";
                t.types.push("image"), x(u + n, (function () {
                    "image" === t.currItem.type && i.cursor && e(document.body).addClass(i.cursor)
                })), x(a + n, (function () {
                    i.cursor && e(document.body).removeClass(i.cursor), b.off("resize" + p)
                })), x("Resize" + n, t.resizeImage), t.isLowIE && x("AfterChange", t.resizeImage)
            },
            resizeImage: function () {
                var e = t.currItem;
                if (e && e.img && t.st.image.verticalFit) {
                    var i = 0;
                    t.isLowIE && (i = parseInt(e.img.css("padding-top"), 10) + parseInt(e.img.css("padding-bottom"), 10)), e.img.css("max-height", t.wH - i)
                }
            },
            _onImageHasSize: function (e) {
                e.img && (e.hasSize = !0, D && clearInterval(D), e.isCheckingImgSize = !1, _("ImageHasSize", e), e.imgHidden && (t.content && t.content.removeClass("mfp-loading"), e.imgHidden = !1))
            },
            findImageSize: function (e) {
                var i = 0,
                    n = e.img[0],
                    r = function (o) {
                        D && clearInterval(D), D = setInterval((function () {
                            return n.naturalWidth > 0 ? void t._onImageHasSize(e) : (i > 200 && clearInterval(D), void(3 === ++i ? r(10) : 40 === i ? r(50) : 100 === i && r(500)))
                        }), o)
                    };
                r(1)
            },
            getImage: function (i, n) {
                var r = 0,
                    o = function () {
                        i && (i.img[0].complete ? (i.img.off(".mfploader"), i === t.currItem && (t._onImageHasSize(i), t.updateStatus("ready")), i.hasSize = !0, i.loaded = !0, _("ImageLoadComplete")) : 200 > ++r ? setTimeout(o, 100) : s())
                    },
                    s = function () {
                        i && (i.img.off(".mfploader"), i === t.currItem && (t._onImageHasSize(i), t.updateStatus("error", a.tError.replace("%url%", i.src))), i.hasSize = !0, i.loaded = !0, i.loadError = !0)
                    },
                    a = t.st.image,
                    l = n.find(".mfp-img");
                if (l.length) {
                    var c = document.createElement("img");
                    c.className = "mfp-img", i.el && i.el.find("img").length && (c.alt = i.el.find("img").attr("alt")), i.img = e(c).on("load.mfploader", o).on("error.mfploader", s), c.src = i.src, l.is("img") && (i.img = i.img.clone()), (c = i.img[0]).naturalWidth > 0 ? i.hasSize = !0 : c.width || (i.hasSize = !1)
                }
                return t._parseMarkup(n, {
                    title: k(i),
                    img_replaceWith: i.img
                }, i), t.resizeImage(), i.hasSize ? (D && clearInterval(D), i.loadError ? (n.addClass("mfp-loading"), t.updateStatus("error", a.tError.replace("%url%", i.src))) : (n.removeClass("mfp-loading"), t.updateStatus("ready")), n) : (t.updateStatus("loading"), i.loading = !0, i.hasSize || (i.imgHidden = !0, n.addClass("mfp-loading"), t.findImageSize(i)), n)
            }
        }
    });
    var z;
    e.magnificPopup.registerModule("zoom", {
        options: {
            enabled: !1,
            easing: "ease-in-out",
            duration: 300,
            opener: function (e) {
                return e.is("img") ? e : e.find("img")
            }
        },
        proto: {
            initZoom: function () {
                var e, i = t.st.zoom,
                    n = ".zoom";
                if (i.enabled && t.supportsTransition) {
                    var r, o, s = i.duration,
                        c = function (e) {
                            var t = e.clone().removeAttr("style").removeAttr("class").addClass("mfp-animated-image"),
                                n = "all " + i.duration / 1e3 + "s " + i.easing,
                                r = {
                                    position: "fixed",
                                    zIndex: 9999,
                                    left: 0,
                                    top: 0,
                                    "-webkit-backface-visibility": "hidden"
                                },
                                o = "transition";
                            return r["-webkit-" + o] = r["-moz-" + o] = r["-o-" + o] = r[o] = n, t.css(r), t
                        },
                        u = function () {
                            t.content.css("visibility", "visible")
                        };
                    x("BuildControls" + n, (function () {
                        if (t._allowZoom()) {
                            if (clearTimeout(r), t.content.css("visibility", "hidden"), !(e = t._getItemToZoom())) return void u();
                            (o = c(e)).css(t._getOffset()), t.wrap.append(o), r = setTimeout((function () {
                                o.css(t._getOffset(!0)), r = setTimeout((function () {
                                    u(), setTimeout((function () {
                                        o.remove(), e = o = null, _("ZoomAnimationEnded")
                                    }), 16)
                                }), s)
                            }), 16)
                        }
                    })), x(l + n, (function () {
                        if (t._allowZoom()) {
                            if (clearTimeout(r), t.st.removalDelay = s, !e) {
                                if (!(e = t._getItemToZoom())) return;
                                o = c(e)
                            }
                            o.css(t._getOffset(!0)), t.wrap.append(o), t.content.css("visibility", "hidden"), setTimeout((function () {
                                o.css(t._getOffset())
                            }), 16)
                        }
                    })), x(a + n, (function () {
                        t._allowZoom() && (u(), o && o.remove(), e = null)
                    }))
                }
            },
            _allowZoom: function () {
                return "image" === t.currItem.type
            },
            _getItemToZoom: function () {
                return !!t.currItem.hasSize && t.currItem.img
            },
            _getOffset: function (i) {
                var n, r = (n = i ? t.currItem.img : t.st.zoom.opener(t.currItem.el || t.currItem)).offset(),
                    o = parseInt(n.css("padding-top"), 10),
                    s = parseInt(n.css("padding-bottom"), 10);
                r.top -= e(window).scrollTop() - o;
                var a = {
                    width: n.width(),
                    height: (y ? n.innerHeight() : n[0].offsetHeight) - s - o
                };
                return void 0 === z && (z = void 0 !== document.createElement("p").style.MozTransform), z ? a["-moz-transform"] = a.transform = "translate(" + r.left + "px," + r.top + "px)" : (a.left = r.left, a.top = r.top), a
            }
        }
    });
    var B = "iframe",
        N = function (e) {
            if (t.currTemplate[B]) {
                var i = t.currTemplate[B].find("iframe");
                i.length && (e || (i[0].src = "//about:blank"), t.isIE8 && i.css("display", e ? "block" : "none"))
            }
        };
    e.magnificPopup.registerModule(B, {
        options: {
            markup: '<div class="mfp-iframe-scaler"><div class="mfp-close"></div><iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe></div>',
            srcAction: "iframe_src",
            patterns: {
                youtube: {
                    index: "youtube.com",
                    id: "v=",
                    src: "//www.youtube.com/embed/%id%?autoplay=1"
                },
                vimeo: {
                    index: "vimeo.com/",
                    id: "/",
                    src: "//player.vimeo.com/video/%id%?autoplay=1"
                },
                gmaps: {
                    index: "//maps.google.",
                    src: "%id%&output=embed"
                }
            }
        },
        proto: {
            initIframe: function () {
                t.types.push(B), x("BeforeChange", (function (e, t, i) {
                    t !== i && (t === B ? N() : i === B && N(!0))
                })), x(a + "." + B, (function () {
                    N()
                }))
            },
            getIframe: function (i, n) {
                var r = i.src,
                    o = t.st.iframe;
                e.each(o.patterns, (function () {
                    return r.indexOf(this.index) > -1 ? (this.id && (r = "string" == typeof this.id ? r.substr(r.lastIndexOf(this.id) + this.id.length, r.length) : this.id.call(this, r)), r = this.src.replace("%id%", r), !1) : void 0
                }));
                var s = {};
                return o.srcAction && (s[o.srcAction] = r), t._parseMarkup(n, s, i), t.updateStatus("ready"), n
            }
        }
    });
    var F = function (e) {
            var i = t.items.length;
            return e > i - 1 ? e - i : 0 > e ? i + e : e
        },
        H = function (e, t, i) {
            return e.replace(/%curr%/gi, t + 1).replace(/%total%/gi, i)
        };
    e.magnificPopup.registerModule("gallery", {
        options: {
            enabled: !1,
            arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
            preload: [0, 2],
            navigateByImgClick: !0,
            arrows: !0,
            tPrev: "Previous (Left arrow key)",
            tNext: "Next (Right arrow key)",
            tCounter: "%curr% of %total%"
        },
        proto: {
            initGallery: function () {
                var i = t.st.gallery,
                    r = ".mfp-gallery";
                return t.direction = !0, !(!i || !i.enabled) && (o += " mfp-gallery", x(u + r, (function () {
                    i.navigateByImgClick && t.wrap.on("click" + r, ".mfp-img", (function () {
                        return t.items.length > 1 ? (t.next(), !1) : void 0
                    })), n.on("keydown" + r, (function (e) {
                        37 === e.keyCode ? t.prev() : 39 === e.keyCode && t.next()
                    }))
                })), x("UpdateStatus" + r, (function (e, i) {
                    i.text && (i.text = H(i.text, t.currItem.index, t.items.length))
                })), x(c + r, (function (e, n, r, o) {
                    var s = t.items.length;
                    r.counter = s > 1 ? H(i.tCounter, o.index, s) : ""
                })), x("BuildControls" + r, (function () {
                    if (t.items.length > 1 && i.arrows && !t.arrowLeft) {
                        var n = i.arrowMarkup,
                            r = t.arrowLeft = e(n.replace(/%title%/gi, i.tPrev).replace(/%dir%/gi, "left")).addClass(g),
                            o = t.arrowRight = e(n.replace(/%title%/gi, i.tNext).replace(/%dir%/gi, "right")).addClass(g);
                        r.click((function () {
                            t.prev()
                        })), o.click((function () {
                            t.next()
                        })), t.container.append(r.add(o))
                    }
                })), x(h + r, (function () {
                    t._preloadTimeout && clearTimeout(t._preloadTimeout), t._preloadTimeout = setTimeout((function () {
                        t.preloadNearbyImages(), t._preloadTimeout = null
                    }), 16)
                })), void x(a + r, (function () {
                    n.off(r), t.wrap.off("click" + r), t.arrowRight = t.arrowLeft = null
                })))
            },
            next: function () {
                t.direction = !0, t.index = F(t.index + 1), t.updateItemHTML()
            },
            prev: function () {
                t.direction = !1, t.index = F(t.index - 1), t.updateItemHTML()
            },
            goTo: function (e) {
                t.direction = e >= t.index, t.index = e, t.updateItemHTML()
            },
            preloadNearbyImages: function () {
                var e, i = t.st.gallery.preload,
                    n = Math.min(i[0], t.items.length),
                    r = Math.min(i[1], t.items.length);
                for (e = 1; e <= (t.direction ? r : n); e++) t._preloadItem(t.index + e);
                for (e = 1; e <= (t.direction ? n : r); e++) t._preloadItem(t.index - e)
            },
            _preloadItem: function (i) {
                if (i = F(i), !t.items[i].preloaded) {
                    var n = t.items[i];
                    n.parsed || (n = t.parseEl(i)), _("LazyLoad", n), "image" === n.type && (n.img = e('<img class="mfp-img" />').on("load.mfploader", (function () {
                        n.hasSize = !0
                    })).on("error.mfploader", (function () {
                        n.hasSize = !0, n.loadError = !0, _("LazyLoadError", n)
                    })).attr("src", n.src)), n.preloaded = !0
                }
            }
        }
    });
    var U = "retina";
    e.magnificPopup.registerModule(U, {
        options: {
            replaceSrc: function (e) {
                return e.src.replace(/\.\w+$/, (function (e) {
                    return "@2x" + e
                }))
            },
            ratio: 1
        },
        proto: {
            initRetina: function () {
                if (window.devicePixelRatio > 1) {
                    var e = t.st.retina,
                        i = e.ratio;
                    (i = isNaN(i) ? i() : i) > 1 && (x("ImageHasSize." + U, (function (e, t) {
                        t.img.css({
                            "max-width": t.img[0].naturalWidth / i,
                            width: "100%"
                        })
                    })), x("ElementParse." + U, (function (t, n) {
                        n.src = e.replaceSrc(n, i)
                    })))
                }
            }
        }
    }), M()
})),
function (e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("Matter", [], t) : "object" == typeof exports ? exports.Matter = t() : e.Matter = t()
}(this, (function () {
    return function (e) {
        var t = {};

        function i(n) {
            if (t[n]) return t[n].exports;
            var r = t[n] = {
                i: n,
                l: !1,
                exports: {}
            };
            return e[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports
        }
        return i.m = e, i.c = t, i.d = function (e, t, n) {
            i.o(e, t) || Object.defineProperty(e, t, {
                enumerable: !0,
                get: n
            })
        }, i.r = function (e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, i.t = function (e, t) {
            if (1 & t && (e = i(e)), 8 & t) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var n = Object.create(null);
            if (i.r(n), Object.defineProperty(n, "default", {
                    enumerable: !0,
                    value: e
                }), 2 & t && "string" != typeof e)
                for (var r in e) i.d(n, r, function (t) {
                    return e[t]
                }.bind(null, r));
            return n
        }, i.n = function (e) {
            var t = e && e.__esModule ? function () {
                return e.default
            } : function () {
                return e
            };
            return i.d(t, "a", t), t
        }, i.o = function (e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }, i.p = "", i(i.s = 20)
    }([function (e, t) {
        var i = {};
        e.exports = i,
            function () {
                i._baseDelta = 1e3 / 60, i._nextId = 0, i._seed = 0, i._nowStartTime = +new Date, i._warnedOnce = {}, i._decomp = null, i.extend = function (e, t) {
                    var n, r;
                    "boolean" == typeof t ? (n = 2, r = t) : (n = 1, r = !0);
                    for (var o = n; o < arguments.length; o++) {
                        var s = arguments[o];
                        if (s)
                            for (var a in s) r && s[a] && s[a].constructor === Object ? e[a] && e[a].constructor !== Object ? e[a] = s[a] : (e[a] = e[a] || {}, i.extend(e[a], r, s[a])) : e[a] = s[a]
                    }
                    return e
                }, i.clone = function (e, t) {
                    return i.extend({}, t, e)
                }, i.keys = function (e) {
                    if (Object.keys) return Object.keys(e);
                    var t = [];
                    for (var i in e) t.push(i);
                    return t
                }, i.values = function (e) {
                    var t = [];
                    if (Object.keys) {
                        for (var i = Object.keys(e), n = 0; n < i.length; n++) t.push(e[i[n]]);
                        return t
                    }
                    for (var r in e) t.push(e[r]);
                    return t
                }, i.get = function (e, t, i, n) {
                    t = t.split(".").slice(i, n);
                    for (var r = 0; r < t.length; r += 1) e = e[t[r]];
                    return e
                }, i.set = function (e, t, n, r, o) {
                    var s = t.split(".").slice(r, o);
                    return i.get(e, t, 0, -1)[s[s.length - 1]] = n, n
                }, i.shuffle = function (e) {
                    for (var t = e.length - 1; t > 0; t--) {
                        var n = Math.floor(i.random() * (t + 1)),
                            r = e[t];
                        e[t] = e[n], e[n] = r
                    }
                    return e
                }, i.choose = function (e) {
                    return e[Math.floor(i.random() * e.length)]
                }, i.isElement = function (e) {
                    return "undefined" != typeof HTMLElement ? e instanceof HTMLElement : !!(e && e.nodeType && e.nodeName)
                }, i.isArray = function (e) {
                    return "[object Array]" === Object.prototype.toString.call(e)
                }, i.isFunction = function (e) {
                    return "function" == typeof e
                }, i.isPlainObject = function (e) {
                    return "object" == typeof e && e.constructor === Object
                }, i.isString = function (e) {
                    return "[object String]" === toString.call(e)
                }, i.clamp = function (e, t, i) {
                    return e < t ? t : e > i ? i : e
                }, i.sign = function (e) {
                    return e < 0 ? -1 : 1
                }, i.now = function () {
                    if ("undefined" != typeof window && window.performance) {
                        if (window.performance.now) return window.performance.now();
                        if (window.performance.webkitNow) return window.performance.webkitNow()
                    }
                    return Date.now ? Date.now() : new Date - i._nowStartTime
                }, i.random = function (t, i) {
                    return i = void 0 !== i ? i : 1, (t = void 0 !== t ? t : 0) + e() * (i - t)
                };
                var e = function () {
                    return i._seed = (9301 * i._seed + 49297) % 233280, i._seed / 233280
                };
                i.colorToNumber = function (e) {
                    return 3 == (e = e.replace("#", "")).length && (e = e.charAt(0) + e.charAt(0) + e.charAt(1) + e.charAt(1) + e.charAt(2) + e.charAt(2)), parseInt(e, 16)
                }, i.logLevel = 1, i.log = function () {
                    console && i.logLevel > 0 && i.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                }, i.info = function () {
                    console && i.logLevel > 0 && i.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                }, i.warn = function () {
                    console && i.logLevel > 0 && i.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                }, i.warnOnce = function () {
                    var e = Array.prototype.slice.call(arguments).join(" ");
                    i._warnedOnce[e] || (i.warn(e), i._warnedOnce[e] = !0)
                }, i.deprecated = function (e, t, n) {
                    e[t] = i.chain((function () {
                        i.warnOnce(" deprecated ", n)
                    }), e[t])
                }, i.nextId = function () {
                    return i._nextId++
                }, i.indexOf = function (e, t) {
                    if (e.indexOf) return e.indexOf(t);
                    for (var i = 0; i < e.length; i++)
                        if (e[i] === t) return i;
                    return -1
                }, i.map = function (e, t) {
                    if (e.map) return e.map(t);
                    for (var i = [], n = 0; n < e.length; n += 1) i.push(t(e[n]));
                    return i
                }, i.topologicalSort = function (e) {
                    var t = [],
                        n = [],
                        r = [];
                    for (var o in e) n[o] || r[o] || i._topologicalSort(o, n, r, e, t);
                    return t
                }, i._topologicalSort = function (e, t, n, r, o) {
                    var s = r[e] || [];
                    n[e] = !0;
                    for (var a = 0; a < s.length; a += 1) {
                        var l = s[a];
                        n[l] || t[l] || i._topologicalSort(l, t, n, r, o)
                    }
                    n[e] = !1, t[e] = !0, o.push(e)
                }, i.chain = function () {
                    for (var e = [], t = 0; t < arguments.length; t += 1) {
                        var i = arguments[t];
                        i._chained ? e.push.apply(e, i._chained) : e.push(i)
                    }
                    var n = function () {
                        for (var t, i = new Array(arguments.length), n = 0, r = arguments.length; n < r; n++) i[n] = arguments[n];
                        for (n = 0; n < e.length; n += 1) {
                            var o = e[n].apply(t, i);
                            void 0 !== o && (t = o)
                        }
                        return t
                    };
                    return n._chained = e, n
                }, i.chainPathBefore = function (e, t, n) {
                    return i.set(e, t, i.chain(n, i.get(e, t)))
                }, i.chainPathAfter = function (e, t, n) {
                    return i.set(e, t, i.chain(i.get(e, t), n))
                }, i.setDecomp = function (e) {
                    i._decomp = e
                }, i.getDecomp = function () {
                    var e = i._decomp;
                    try {
                        e || "undefined" == typeof window || (e = window.decomp), e || "undefined" == typeof global || (e = global.decomp)
                    } catch (t) {
                        e = null
                    }
                    return e
                }
            }()
    }, function (e, t) {
        var i = {};
        e.exports = i, i.create = function (e) {
            var t = {
                min: {
                    x: 0,
                    y: 0
                },
                max: {
                    x: 0,
                    y: 0
                }
            };
            return e && i.update(t, e), t
        }, i.update = function (e, t, i) {
            e.min.x = 1 / 0, e.max.x = -1 / 0, e.min.y = 1 / 0, e.max.y = -1 / 0;
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.x > e.max.x && (e.max.x = r.x), r.x < e.min.x && (e.min.x = r.x), r.y > e.max.y && (e.max.y = r.y), r.y < e.min.y && (e.min.y = r.y)
            }
            i && (i.x > 0 ? e.max.x += i.x : e.min.x += i.x, i.y > 0 ? e.max.y += i.y : e.min.y += i.y)
        }, i.contains = function (e, t) {
            return t.x >= e.min.x && t.x <= e.max.x && t.y >= e.min.y && t.y <= e.max.y
        }, i.overlaps = function (e, t) {
            return e.min.x <= t.max.x && e.max.x >= t.min.x && e.max.y >= t.min.y && e.min.y <= t.max.y
        }, i.translate = function (e, t) {
            e.min.x += t.x, e.max.x += t.x, e.min.y += t.y, e.max.y += t.y
        }, i.shift = function (e, t) {
            var i = e.max.x - e.min.x,
                n = e.max.y - e.min.y;
            e.min.x = t.x, e.max.x = t.x + i, e.min.y = t.y, e.max.y = t.y + n
        }
    }, function (e, t) {
        var i = {};
        e.exports = i, i.create = function (e, t) {
            return {
                x: e || 0,
                y: t || 0
            }
        }, i.clone = function (e) {
            return {
                x: e.x,
                y: e.y
            }
        }, i.magnitude = function (e) {
            return Math.sqrt(e.x * e.x + e.y * e.y)
        }, i.magnitudeSquared = function (e) {
            return e.x * e.x + e.y * e.y
        }, i.rotate = function (e, t, i) {
            var n = Math.cos(t),
                r = Math.sin(t);
            i || (i = {});
            var o = e.x * n - e.y * r;
            return i.y = e.x * r + e.y * n, i.x = o, i
        }, i.rotateAbout = function (e, t, i, n) {
            var r = Math.cos(t),
                o = Math.sin(t);
            n || (n = {});
            var s = i.x + ((e.x - i.x) * r - (e.y - i.y) * o);
            return n.y = i.y + ((e.x - i.x) * o + (e.y - i.y) * r), n.x = s, n
        }, i.normalise = function (e) {
            var t = i.magnitude(e);
            return 0 === t ? {
                x: 0,
                y: 0
            } : {
                x: e.x / t,
                y: e.y / t
            }
        }, i.dot = function (e, t) {
            return e.x * t.x + e.y * t.y
        }, i.cross = function (e, t) {
            return e.x * t.y - e.y * t.x
        }, i.cross3 = function (e, t, i) {
            return (t.x - e.x) * (i.y - e.y) - (t.y - e.y) * (i.x - e.x)
        }, i.add = function (e, t, i) {
            return i || (i = {}), i.x = e.x + t.x, i.y = e.y + t.y, i
        }, i.sub = function (e, t, i) {
            return i || (i = {}), i.x = e.x - t.x, i.y = e.y - t.y, i
        }, i.mult = function (e, t) {
            return {
                x: e.x * t,
                y: e.y * t
            }
        }, i.div = function (e, t) {
            return {
                x: e.x / t,
                y: e.y / t
            }
        }, i.perp = function (e, t) {
            return {
                x: (t = !0 === t ? -1 : 1) * -e.y,
                y: t * e.x
            }
        }, i.neg = function (e) {
            return {
                x: -e.x,
                y: -e.y
            }
        }, i.angle = function (e, t) {
            return Math.atan2(t.y - e.y, t.x - e.x)
        }, i._temp = [i.create(), i.create(), i.create(), i.create(), i.create(), i.create()]
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(2),
            o = i(0);
        n.create = function (e, t) {
            for (var i = [], n = 0; n < e.length; n++) {
                var r = e[n],
                    o = {
                        x: r.x,
                        y: r.y,
                        index: n,
                        body: t,
                        isInternal: !1
                    };
                i.push(o)
            }
            return i
        }, n.fromPath = function (e, t) {
            var i = [];
            return e.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi, (function (e, t, n) {
                i.push({
                    x: parseFloat(t),
                    y: parseFloat(n)
                })
            })), n.create(i, t)
        }, n.centre = function (e) {
            for (var t, i, o, s = n.area(e, !0), a = {
                    x: 0,
                    y: 0
                }, l = 0; l < e.length; l++) o = (l + 1) % e.length, t = r.cross(e[l], e[o]), i = r.mult(r.add(e[l], e[o]), t), a = r.add(a, i);
            return r.div(a, 6 * s)
        }, n.mean = function (e) {
            for (var t = {
                    x: 0,
                    y: 0
                }, i = 0; i < e.length; i++) t.x += e[i].x, t.y += e[i].y;
            return r.div(t, e.length)
        }, n.area = function (e, t) {
            for (var i = 0, n = e.length - 1, r = 0; r < e.length; r++) i += (e[n].x - e[r].x) * (e[n].y + e[r].y), n = r;
            return t ? i / 2 : Math.abs(i) / 2
        }, n.inertia = function (e, t) {
            for (var i, n, o = 0, s = 0, a = e, l = 0; l < a.length; l++) n = (l + 1) % a.length, o += (i = Math.abs(r.cross(a[n], a[l]))) * (r.dot(a[n], a[n]) + r.dot(a[n], a[l]) + r.dot(a[l], a[l])), s += i;
            return t / 6 * (o / s)
        }, n.translate = function (e, t, i) {
            i = void 0 !== i ? i : 1;
            var n, r = e.length,
                o = t.x * i,
                s = t.y * i;
            for (n = 0; n < r; n++) e[n].x += o, e[n].y += s;
            return e
        }, n.rotate = function (e, t, i) {
            if (0 !== t) {
                var n, r, o, s, a = Math.cos(t),
                    l = Math.sin(t),
                    c = i.x,
                    u = i.y,
                    h = e.length;
                for (s = 0; s < h; s++) r = (n = e[s]).x - c, o = n.y - u, n.x = c + (r * a - o * l), n.y = u + (r * l + o * a);
                return e
            }
        }, n.contains = function (e, t) {
            for (var i, n = t.x, r = t.y, o = e.length, s = e[o - 1], a = 0; a < o; a++) {
                if (i = e[a], (n - s.x) * (i.y - s.y) + (r - s.y) * (s.x - i.x) > 0) return !1;
                s = i
            }
            return !0
        }, n.scale = function (e, t, i, o) {
            if (1 === t && 1 === i) return e;
            var s, a;
            o = o || n.centre(e);
            for (var l = 0; l < e.length; l++) s = e[l], a = r.sub(s, o), e[l].x = o.x + a.x * t, e[l].y = o.y + a.y * i;
            return e
        }, n.chamfer = function (e, t, i, n, s) {
            t = "number" == typeof t ? [t] : t || [8], i = void 0 !== i ? i : -1, n = n || 2, s = s || 14;
            for (var a = [], l = 0; l < e.length; l++) {
                var c = e[l - 1 >= 0 ? l - 1 : e.length - 1],
                    u = e[l],
                    h = e[(l + 1) % e.length],
                    d = t[l < t.length ? l : t.length - 1];
                if (0 !== d) {
                    var p = r.normalise({
                            x: u.y - c.y,
                            y: c.x - u.x
                        }),
                        f = r.normalise({
                            x: h.y - u.y,
                            y: u.x - h.x
                        }),
                        m = Math.sqrt(2 * Math.pow(d, 2)),
                        g = r.mult(o.clone(p), d),
                        v = r.normalise(r.mult(r.add(p, f), .5)),
                        y = r.sub(u, r.mult(v, m)),
                        b = i; - 1 === i && (b = 1.75 * Math.pow(d, .32)), (b = o.clamp(b, n, s)) % 2 == 1 && (b += 1);
                    for (var x = Math.acos(r.dot(p, f)) / b, w = 0; w < b; w++) a.push(r.add(r.rotate(g, x * w), y))
                } else a.push(u)
            }
            return a
        }, n.clockwiseSort = function (e) {
            var t = n.mean(e);
            return e.sort((function (e, i) {
                return r.angle(t, e) - r.angle(t, i)
            })), e
        }, n.isConvex = function (e) {
            var t, i, n, r, o = 0,
                s = e.length;
            if (s < 3) return null;
            for (t = 0; t < s; t++)
                if (n = (t + 2) % s, r = (e[i = (t + 1) % s].x - e[t].x) * (e[n].y - e[i].y), (r -= (e[i].y - e[t].y) * (e[n].x - e[i].x)) < 0 ? o |= 1 : r > 0 && (o |= 2), 3 === o) return !1;
            return 0 !== o || null
        }, n.hull = function (e) {
            var t, i, n = [],
                o = [];
            for ((e = e.slice(0)).sort((function (e, t) {
                    var i = e.x - t.x;
                    return 0 !== i ? i : e.y - t.y
                })), i = 0; i < e.length; i += 1) {
                for (t = e[i]; o.length >= 2 && r.cross3(o[o.length - 2], o[o.length - 1], t) <= 0;) o.pop();
                o.push(t)
            }
            for (i = e.length - 1; i >= 0; i -= 1) {
                for (t = e[i]; n.length >= 2 && r.cross3(n[n.length - 2], n[n.length - 1], t) <= 0;) n.pop();
                n.push(t)
            }
            return n.pop(), o.pop(), n.concat(o)
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(3),
            o = i(2),
            s = i(7),
            a = i(0),
            l = i(1),
            c = i(11);
        ! function () {
            n._timeCorrection = !0, n._inertiaScale = 4, n._nextCollidingGroupId = 1, n._nextNonCollidingGroupId = -1, n._nextCategory = 1, n._baseDelta = 1e3 / 60, n.create = function (t) {
                var i = {
                        id: a.nextId(),
                        type: "body",
                        label: "Body",
                        parts: [],
                        plugin: {},
                        angle: 0,
                        vertices: r.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),
                        position: {
                            x: 0,
                            y: 0
                        },
                        force: {
                            x: 0,
                            y: 0
                        },
                        torque: 0,
                        positionImpulse: {
                            x: 0,
                            y: 0
                        },
                        constraintImpulse: {
                            x: 0,
                            y: 0,
                            angle: 0
                        },
                        totalContacts: 0,
                        speed: 0,
                        angularSpeed: 0,
                        velocity: {
                            x: 0,
                            y: 0
                        },
                        angularVelocity: 0,
                        isSensor: !1,
                        isStatic: !1,
                        isSleeping: !1,
                        motion: 0,
                        sleepThreshold: 60,
                        density: .001,
                        restitution: 0,
                        friction: .1,
                        frictionStatic: .5,
                        frictionAir: .01,
                        collisionFilter: {
                            category: 1,
                            mask: 4294967295,
                            group: 0
                        },
                        slop: .05,
                        timeScale: 1,
                        render: {
                            visible: !0,
                            opacity: 1,
                            strokeStyle: null,
                            fillStyle: null,
                            lineWidth: null,
                            sprite: {
                                xScale: 1,
                                yScale: 1,
                                xOffset: 0,
                                yOffset: 0
                            }
                        },
                        events: null,
                        bounds: null,
                        chamfer: null,
                        circleRadius: 0,
                        positionPrev: null,
                        anglePrev: 0,
                        parent: null,
                        axes: null,
                        area: 0,
                        mass: 0,
                        inertia: 0,
                        deltaTime: 1e3 / 60,
                        _original: null
                    },
                    n = a.extend(i, t);
                return e(n, t), n
            }, n.nextGroup = function (e) {
                return e ? n._nextNonCollidingGroupId-- : n._nextCollidingGroupId++
            }, n.nextCategory = function () {
                return n._nextCategory = n._nextCategory << 1, n._nextCategory
            };
            var e = function (e, t) {
                t = t || {}, n.set(e, {
                    bounds: e.bounds || l.create(e.vertices),
                    positionPrev: e.positionPrev || o.clone(e.position),
                    anglePrev: e.anglePrev || e.angle,
                    vertices: e.vertices,
                    parts: e.parts || [e],
                    isStatic: e.isStatic,
                    isSleeping: e.isSleeping,
                    parent: e.parent || e
                }), r.rotate(e.vertices, e.angle, e.position), c.rotate(e.axes, e.angle), l.update(e.bounds, e.vertices, e.velocity), n.set(e, {
                    axes: t.axes || e.axes,
                    area: t.area || e.area,
                    mass: t.mass || e.mass,
                    inertia: t.inertia || e.inertia
                });
                var i = e.isStatic ? "#14151f" : a.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]),
                    s = e.isStatic ? "#555" : "#ccc",
                    u = e.isStatic && null === e.render.fillStyle ? 1 : 0;
                e.render.fillStyle = e.render.fillStyle || i, e.render.strokeStyle = e.render.strokeStyle || s, e.render.lineWidth = e.render.lineWidth || u, e.render.sprite.xOffset += -(e.bounds.min.x - e.position.x) / (e.bounds.max.x - e.bounds.min.x), e.render.sprite.yOffset += -(e.bounds.min.y - e.position.y) / (e.bounds.max.y - e.bounds.min.y)
            };
            n.set = function (e, t, i) {
                var r;
                for (r in "string" == typeof t && (r = t, (t = {})[r] = i), t)
                    if (Object.prototype.hasOwnProperty.call(t, r)) switch (i = t[r], r) {
                        case "isStatic":
                            n.setStatic(e, i);
                            break;
                        case "isSleeping":
                            s.set(e, i);
                            break;
                        case "mass":
                            n.setMass(e, i);
                            break;
                        case "density":
                            n.setDensity(e, i);
                            break;
                        case "inertia":
                            n.setInertia(e, i);
                            break;
                        case "vertices":
                            n.setVertices(e, i);
                            break;
                        case "position":
                            n.setPosition(e, i);
                            break;
                        case "angle":
                            n.setAngle(e, i);
                            break;
                        case "velocity":
                            n.setVelocity(e, i);
                            break;
                        case "angularVelocity":
                            n.setAngularVelocity(e, i);
                            break;
                        case "speed":
                            n.setSpeed(e, i);
                            break;
                        case "angularSpeed":
                            n.setAngularSpeed(e, i);
                            break;
                        case "parts":
                            n.setParts(e, i);
                            break;
                        case "centre":
                            n.setCentre(e, i);
                            break;
                        default:
                            e[r] = i
                    }
            }, n.setStatic = function (e, t) {
                for (var i = 0; i < e.parts.length; i++) {
                    var n = e.parts[i];
                    n.isStatic = t, t ? (n._original = {
                        restitution: n.restitution,
                        friction: n.friction,
                        mass: n.mass,
                        inertia: n.inertia,
                        density: n.density,
                        inverseMass: n.inverseMass,
                        inverseInertia: n.inverseInertia
                    }, n.restitution = 0, n.friction = 1, n.mass = n.inertia = n.density = 1 / 0, n.inverseMass = n.inverseInertia = 0, n.positionPrev.x = n.position.x, n.positionPrev.y = n.position.y, n.anglePrev = n.angle, n.angularVelocity = 0, n.speed = 0, n.angularSpeed = 0, n.motion = 0) : n._original && (n.restitution = n._original.restitution, n.friction = n._original.friction, n.mass = n._original.mass, n.inertia = n._original.inertia, n.density = n._original.density, n.inverseMass = n._original.inverseMass, n.inverseInertia = n._original.inverseInertia, n._original = null)
                }
            }, n.setMass = function (e, t) {
                var i = e.inertia / (e.mass / 6);
                e.inertia = i * (t / 6), e.inverseInertia = 1 / e.inertia, e.mass = t, e.inverseMass = 1 / e.mass, e.density = e.mass / e.area
            }, n.setDensity = function (e, t) {
                n.setMass(e, t * e.area), e.density = t
            }, n.setInertia = function (e, t) {
                e.inertia = t, e.inverseInertia = 1 / e.inertia
            }, n.setVertices = function (e, t) {
                t[0].body === e ? e.vertices = t : e.vertices = r.create(t, e), e.axes = c.fromVertices(e.vertices), e.area = r.area(e.vertices), n.setMass(e, e.density * e.area);
                var i = r.centre(e.vertices);
                r.translate(e.vertices, i, -1), n.setInertia(e, n._inertiaScale * r.inertia(e.vertices, e.mass)), r.translate(e.vertices, e.position), l.update(e.bounds, e.vertices, e.velocity)
            }, n.setParts = function (e, t, i) {
                var o;
                for (t = t.slice(0), e.parts.length = 0, e.parts.push(e), e.parent = e, o = 0; o < t.length; o++) {
                    var s = t[o];
                    s !== e && (s.parent = e, e.parts.push(s))
                }
                if (1 !== e.parts.length) {
                    if (i = void 0 === i || i) {
                        var a = [];
                        for (o = 0; o < t.length; o++) a = a.concat(t[o].vertices);
                        r.clockwiseSort(a);
                        var l = r.hull(a),
                            c = r.centre(l);
                        n.setVertices(e, l), r.translate(e.vertices, c)
                    }
                    var u = n._totalProperties(e);
                    e.area = u.area, e.parent = e, e.position.x = u.centre.x, e.position.y = u.centre.y, e.positionPrev.x = u.centre.x, e.positionPrev.y = u.centre.y, n.setMass(e, u.mass), n.setInertia(e, u.inertia), n.setPosition(e, u.centre)
                }
            }, n.setCentre = function (e, t, i) {
                i ? (e.positionPrev.x += t.x, e.positionPrev.y += t.y, e.position.x += t.x, e.position.y += t.y) : (e.positionPrev.x = t.x - (e.position.x - e.positionPrev.x), e.positionPrev.y = t.y - (e.position.y - e.positionPrev.y), e.position.x = t.x, e.position.y = t.y)
            }, n.setPosition = function (e, t, i) {
                var n = o.sub(t, e.position);
                i ? (e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.velocity.x = n.x, e.velocity.y = n.y, e.speed = o.magnitude(n)) : (e.positionPrev.x += n.x, e.positionPrev.y += n.y);
                for (var s = 0; s < e.parts.length; s++) {
                    var a = e.parts[s];
                    a.position.x += n.x, a.position.y += n.y, r.translate(a.vertices, n), l.update(a.bounds, a.vertices, e.velocity)
                }
            }, n.setAngle = function (e, t, i) {
                var n = t - e.angle;
                i ? (e.anglePrev = e.angle, e.angularVelocity = n, e.angularSpeed = Math.abs(n)) : e.anglePrev += n;
                for (var s = 0; s < e.parts.length; s++) {
                    var a = e.parts[s];
                    a.angle += n, r.rotate(a.vertices, n, e.position), c.rotate(a.axes, n), l.update(a.bounds, a.vertices, e.velocity), s > 0 && o.rotateAbout(a.position, n, e.position, a.position)
                }
            }, n.setVelocity = function (e, t) {
                var i = e.deltaTime / n._baseDelta;
                e.positionPrev.x = e.position.x - t.x * i, e.positionPrev.y = e.position.y - t.y * i, e.velocity.x = (e.position.x - e.positionPrev.x) / i, e.velocity.y = (e.position.y - e.positionPrev.y) / i, e.speed = o.magnitude(e.velocity)
            }, n.getVelocity = function (e) {
                var t = n._baseDelta / e.deltaTime;
                return {
                    x: (e.position.x - e.positionPrev.x) * t,
                    y: (e.position.y - e.positionPrev.y) * t
                }
            }, n.getSpeed = function (e) {
                return o.magnitude(n.getVelocity(e))
            }, n.setSpeed = function (e, t) {
                n.setVelocity(e, o.mult(o.normalise(n.getVelocity(e)), t))
            }, n.setAngularVelocity = function (e, t) {
                var i = e.deltaTime / n._baseDelta;
                e.anglePrev = e.angle - t * i, e.angularVelocity = (e.angle - e.anglePrev) / i, e.angularSpeed = Math.abs(e.angularVelocity)
            }, n.getAngularVelocity = function (e) {
                return (e.angle - e.anglePrev) * n._baseDelta / e.deltaTime
            }, n.getAngularSpeed = function (e) {
                return Math.abs(n.getAngularVelocity(e))
            }, n.setAngularSpeed = function (e, t) {
                n.setAngularVelocity(e, a.sign(n.getAngularVelocity(e)) * t)
            }, n.translate = function (e, t, i) {
                n.setPosition(e, o.add(e.position, t), i)
            }, n.rotate = function (e, t, i, r) {
                if (i) {
                    var o = Math.cos(t),
                        s = Math.sin(t),
                        a = e.position.x - i.x,
                        l = e.position.y - i.y;
                    n.setPosition(e, {
                        x: i.x + (a * o - l * s),
                        y: i.y + (a * s + l * o)
                    }, r), n.setAngle(e, e.angle + t, r)
                } else n.setAngle(e, e.angle + t, r)
            }, n.scale = function (e, t, i, o) {
                var s = 0,
                    a = 0;
                o = o || e.position;
                for (var u = 0; u < e.parts.length; u++) {
                    var h = e.parts[u];
                    r.scale(h.vertices, t, i, o), h.axes = c.fromVertices(h.vertices), h.area = r.area(h.vertices), n.setMass(h, e.density * h.area), r.translate(h.vertices, {
                        x: -h.position.x,
                        y: -h.position.y
                    }), n.setInertia(h, n._inertiaScale * r.inertia(h.vertices, h.mass)), r.translate(h.vertices, {
                        x: h.position.x,
                        y: h.position.y
                    }), u > 0 && (s += h.area, a += h.inertia), h.position.x = o.x + (h.position.x - o.x) * t, h.position.y = o.y + (h.position.y - o.y) * i, l.update(h.bounds, h.vertices, e.velocity)
                }
                e.parts.length > 1 && (e.area = s, e.isStatic || (n.setMass(e, e.density * s), n.setInertia(e, a))), e.circleRadius && (t === i ? e.circleRadius *= t : e.circleRadius = null)
            }, n.update = function (e, t) {
                var i = (t = (void 0 !== t ? t : 1e3 / 60) * e.timeScale) * t,
                    s = n._timeCorrection ? t / (e.deltaTime || t) : 1,
                    u = 1 - e.frictionAir * (t / a._baseDelta),
                    h = (e.position.x - e.positionPrev.x) * s,
                    d = (e.position.y - e.positionPrev.y) * s;
                e.velocity.x = h * u + e.force.x / e.mass * i, e.velocity.y = d * u + e.force.y / e.mass * i, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.position.x += e.velocity.x, e.position.y += e.velocity.y, e.deltaTime = t, e.angularVelocity = (e.angle - e.anglePrev) * u * s + e.torque / e.inertia * i, e.anglePrev = e.angle, e.angle += e.angularVelocity;
                for (var p = 0; p < e.parts.length; p++) {
                    var f = e.parts[p];
                    r.translate(f.vertices, e.velocity), p > 0 && (f.position.x += e.velocity.x, f.position.y += e.velocity.y), 0 !== e.angularVelocity && (r.rotate(f.vertices, e.angularVelocity, e.position), c.rotate(f.axes, e.angularVelocity), p > 0 && o.rotateAbout(f.position, e.angularVelocity, e.position, f.position)), l.update(f.bounds, f.vertices, e.velocity)
                }
            }, n.updateVelocities = function (e) {
                var t = n._baseDelta / e.deltaTime,
                    i = e.velocity;
                i.x = (e.position.x - e.positionPrev.x) * t, i.y = (e.position.y - e.positionPrev.y) * t, e.speed = Math.sqrt(i.x * i.x + i.y * i.y), e.angularVelocity = (e.angle - e.anglePrev) * t, e.angularSpeed = Math.abs(e.angularVelocity)
            }, n.applyForce = function (e, t, i) {
                var n = t.x - e.position.x,
                    r = t.y - e.position.y;
                e.force.x += i.x, e.force.y += i.y, e.torque += n * i.y - r * i.x
            }, n._totalProperties = function (e) {
                for (var t = {
                        mass: 0,
                        area: 0,
                        inertia: 0,
                        centre: {
                            x: 0,
                            y: 0
                        }
                    }, i = 1 === e.parts.length ? 0 : 1; i < e.parts.length; i++) {
                    var n = e.parts[i],
                        r = n.mass !== 1 / 0 ? n.mass : 1;
                    t.mass += r, t.area += n.area, t.inertia += n.inertia, t.centre = o.add(t.centre, o.mult(n.position, r))
                }
                return t.centre = o.div(t.centre, t.mass), t
            }
        }()
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(0);
        n.on = function (e, t, i) {
            for (var n, r = t.split(" "), o = 0; o < r.length; o++) n = r[o], e.events = e.events || {}, e.events[n] = e.events[n] || [], e.events[n].push(i);
            return i
        }, n.off = function (e, t, i) {
            if (t) {
                "function" == typeof t && (i = t, t = r.keys(e.events).join(" "));
                for (var n = t.split(" "), o = 0; o < n.length; o++) {
                    var s = e.events[n[o]],
                        a = [];
                    if (i && s)
                        for (var l = 0; l < s.length; l++) s[l] !== i && a.push(s[l]);
                    e.events[n[o]] = a
                }
            } else e.events = {}
        }, n.trigger = function (e, t, i) {
            var n, o, s, a, l = e.events;
            if (l && r.keys(l).length > 0) {
                i || (i = {}), n = t.split(" ");
                for (var c = 0; c < n.length; c++)
                    if (s = l[o = n[c]]) {
                        (a = r.clone(i, !1)).name = o, a.source = e;
                        for (var u = 0; u < s.length; u++) s[u].apply(e, [a])
                    }
            }
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(5),
            o = i(0),
            s = i(1),
            a = i(4);
        n.create = function (e) {
            return o.extend({
                id: o.nextId(),
                type: "composite",
                parent: null,
                isModified: !1,
                bodies: [],
                constraints: [],
                composites: [],
                label: "Composite",
                plugin: {},
                cache: {
                    allBodies: null,
                    allConstraints: null,
                    allComposites: null
                }
            }, e)
        }, n.setModified = function (e, t, i, r) {
            if (e.isModified = t, t && e.cache && (e.cache.allBodies = null, e.cache.allConstraints = null, e.cache.allComposites = null), i && e.parent && n.setModified(e.parent, t, i, r), r)
                for (var o = 0; o < e.composites.length; o++) {
                    var s = e.composites[o];
                    n.setModified(s, t, i, r)
                }
        }, n.add = function (e, t) {
            var i = [].concat(t);
            r.trigger(e, "beforeAdd", {
                object: t
            });
            for (var s = 0; s < i.length; s++) {
                var a = i[s];
                switch (a.type) {
                    case "body":
                        if (a.parent !== a) {
                            o.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                            break
                        }
                        n.addBody(e, a);
                        break;
                    case "constraint":
                        n.addConstraint(e, a);
                        break;
                    case "composite":
                        n.addComposite(e, a);
                        break;
                    case "mouseConstraint":
                        n.addConstraint(e, a.constraint)
                }
            }
            return r.trigger(e, "afterAdd", {
                object: t
            }), e
        }, n.remove = function (e, t, i) {
            var o = [].concat(t);
            r.trigger(e, "beforeRemove", {
                object: t
            });
            for (var s = 0; s < o.length; s++) {
                var a = o[s];
                switch (a.type) {
                    case "body":
                        n.removeBody(e, a, i);
                        break;
                    case "constraint":
                        n.removeConstraint(e, a, i);
                        break;
                    case "composite":
                        n.removeComposite(e, a, i);
                        break;
                    case "mouseConstraint":
                        n.removeConstraint(e, a.constraint)
                }
            }
            return r.trigger(e, "afterRemove", {
                object: t
            }), e
        }, n.addComposite = function (e, t) {
            return e.composites.push(t), t.parent = e, n.setModified(e, !0, !0, !1), e
        }, n.removeComposite = function (e, t, i) {
            var r = o.indexOf(e.composites, t);
            if (-1 !== r && n.removeCompositeAt(e, r), i)
                for (var s = 0; s < e.composites.length; s++) n.removeComposite(e.composites[s], t, !0);
            return e
        }, n.removeCompositeAt = function (e, t) {
            return e.composites.splice(t, 1), n.setModified(e, !0, !0, !1), e
        }, n.addBody = function (e, t) {
            return e.bodies.push(t), n.setModified(e, !0, !0, !1), e
        }, n.removeBody = function (e, t, i) {
            var r = o.indexOf(e.bodies, t);
            if (-1 !== r && n.removeBodyAt(e, r), i)
                for (var s = 0; s < e.composites.length; s++) n.removeBody(e.composites[s], t, !0);
            return e
        }, n.removeBodyAt = function (e, t) {
            return e.bodies.splice(t, 1), n.setModified(e, !0, !0, !1), e
        }, n.addConstraint = function (e, t) {
            return e.constraints.push(t), n.setModified(e, !0, !0, !1), e
        }, n.removeConstraint = function (e, t, i) {
            var r = o.indexOf(e.constraints, t);
            if (-1 !== r && n.removeConstraintAt(e, r), i)
                for (var s = 0; s < e.composites.length; s++) n.removeConstraint(e.composites[s], t, !0);
            return e
        }, n.removeConstraintAt = function (e, t) {
            return e.constraints.splice(t, 1), n.setModified(e, !0, !0, !1), e
        }, n.clear = function (e, t, i) {
            if (i)
                for (var r = 0; r < e.composites.length; r++) n.clear(e.composites[r], t, !0);
            return t ? e.bodies = e.bodies.filter((function (e) {
                return e.isStatic
            })) : e.bodies.length = 0, e.constraints.length = 0, e.composites.length = 0, n.setModified(e, !0, !0, !1), e
        }, n.allBodies = function (e) {
            if (e.cache && e.cache.allBodies) return e.cache.allBodies;
            for (var t = [].concat(e.bodies), i = 0; i < e.composites.length; i++) t = t.concat(n.allBodies(e.composites[i]));
            return e.cache && (e.cache.allBodies = t), t
        }, n.allConstraints = function (e) {
            if (e.cache && e.cache.allConstraints) return e.cache.allConstraints;
            for (var t = [].concat(e.constraints), i = 0; i < e.composites.length; i++) t = t.concat(n.allConstraints(e.composites[i]));
            return e.cache && (e.cache.allConstraints = t), t
        }, n.allComposites = function (e) {
            if (e.cache && e.cache.allComposites) return e.cache.allComposites;
            for (var t = [].concat(e.composites), i = 0; i < e.composites.length; i++) t = t.concat(n.allComposites(e.composites[i]));
            return e.cache && (e.cache.allComposites = t), t
        }, n.get = function (e, t, i) {
            var r, o;
            switch (i) {
                case "body":
                    r = n.allBodies(e);
                    break;
                case "constraint":
                    r = n.allConstraints(e);
                    break;
                case "composite":
                    r = n.allComposites(e).concat(e)
            }
            return r ? 0 === (o = r.filter((function (e) {
                return e.id.toString() === t.toString()
            }))).length ? null : o[0] : null
        }, n.move = function (e, t, i) {
            return n.remove(e, t), n.add(i, t), e
        }, n.rebase = function (e) {
            for (var t = n.allBodies(e).concat(n.allConstraints(e)).concat(n.allComposites(e)), i = 0; i < t.length; i++) t[i].id = o.nextId();
            return e
        }, n.translate = function (e, t, i) {
            for (var r = i ? n.allBodies(e) : e.bodies, o = 0; o < r.length; o++) a.translate(r[o], t);
            return e
        }, n.rotate = function (e, t, i, r) {
            for (var o = Math.cos(t), s = Math.sin(t), l = r ? n.allBodies(e) : e.bodies, c = 0; c < l.length; c++) {
                var u = l[c],
                    h = u.position.x - i.x,
                    d = u.position.y - i.y;
                a.setPosition(u, {
                    x: i.x + (h * o - d * s),
                    y: i.y + (h * s + d * o)
                }), a.rotate(u, t)
            }
            return e
        }, n.scale = function (e, t, i, r, o) {
            for (var s = o ? n.allBodies(e) : e.bodies, l = 0; l < s.length; l++) {
                var c = s[l],
                    u = c.position.x - r.x,
                    h = c.position.y - r.y;
                a.setPosition(c, {
                    x: r.x + u * t,
                    y: r.y + h * i
                }), a.scale(c, t, i)
            }
            return e
        }, n.bounds = function (e) {
            for (var t = n.allBodies(e), i = [], r = 0; r < t.length; r += 1) {
                var o = t[r];
                i.push(o.bounds.min, o.bounds.max)
            }
            return s.create(i)
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(4),
            o = i(5),
            s = i(0);
        n._motionWakeThreshold = .18, n._motionSleepThreshold = .08, n._minBias = .9, n.update = function (e, t) {
            for (var i = t / s._baseDelta, o = n._motionSleepThreshold, a = 0; a < e.length; a++) {
                var l = e[a],
                    c = r.getSpeed(l),
                    u = r.getAngularSpeed(l),
                    h = c * c + u * u;
                if (0 === l.force.x && 0 === l.force.y) {
                    var d = Math.min(l.motion, h),
                        p = Math.max(l.motion, h);
                    l.motion = n._minBias * d + (1 - n._minBias) * p, l.sleepThreshold > 0 && l.motion < o ? (l.sleepCounter += 1, l.sleepCounter >= l.sleepThreshold / i && n.set(l, !0)) : l.sleepCounter > 0 && (l.sleepCounter -= 1)
                } else n.set(l, !1)
            }
        }, n.afterCollisions = function (e) {
            for (var t = n._motionSleepThreshold, i = 0; i < e.length; i++) {
                var r = e[i];
                if (r.isActive) {
                    var o = r.collision,
                        s = o.bodyA.parent,
                        a = o.bodyB.parent;
                    if (!(s.isSleeping && a.isSleeping || s.isStatic || a.isStatic) && (s.isSleeping || a.isSleeping)) {
                        var l = s.isSleeping && !s.isStatic ? s : a,
                            c = l === s ? a : s;
                        !l.isStatic && c.motion > t && n.set(l, !1)
                    }
                }
            }
        }, n.set = function (e, t) {
            var i = e.isSleeping;
            t ? (e.isSleeping = !0, e.sleepCounter = e.sleepThreshold, e.positionImpulse.x = 0, e.positionImpulse.y = 0, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.anglePrev = e.angle, e.speed = 0, e.angularSpeed = 0, e.motion = 0, i || o.trigger(e, "sleepStart")) : (e.isSleeping = !1, e.sleepCounter = 0, i && o.trigger(e, "sleepEnd"))
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r, o, s, a = i(3),
            l = i(9);
        r = [], o = {
            overlap: 0,
            axis: null
        }, s = {
            overlap: 0,
            axis: null
        }, n.create = function (e, t) {
            return {
                pair: null,
                collided: !1,
                bodyA: e,
                bodyB: t,
                parentA: e.parent,
                parentB: t.parent,
                depth: 0,
                normal: {
                    x: 0,
                    y: 0
                },
                tangent: {
                    x: 0,
                    y: 0
                },
                penetration: {
                    x: 0,
                    y: 0
                },
                supports: []
            }
        }, n.collides = function (e, t, i) {
            if (n._overlapAxes(o, e.vertices, t.vertices, e.axes), o.overlap <= 0) return null;
            if (n._overlapAxes(s, t.vertices, e.vertices, t.axes), s.overlap <= 0) return null;
            var r, c, u = i && i.table[l.id(e, t)];
            u ? r = u.collision : ((r = n.create(e, t)).collided = !0, r.bodyA = e.id < t.id ? e : t, r.bodyB = e.id < t.id ? t : e, r.parentA = r.bodyA.parent, r.parentB = r.bodyB.parent), e = r.bodyA, t = r.bodyB, c = o.overlap < s.overlap ? o : s;
            var h = r.normal,
                d = r.supports,
                p = c.axis,
                f = p.x,
                m = p.y;
            f * (t.position.x - e.position.x) + m * (t.position.y - e.position.y) < 0 ? (h.x = f, h.y = m) : (h.x = -f, h.y = -m), r.tangent.x = -h.y, r.tangent.y = h.x, r.depth = c.overlap, r.penetration.x = h.x * r.depth, r.penetration.y = h.y * r.depth;
            var g = n._findSupports(e, t, h, 1),
                v = 0;
            if (a.contains(e.vertices, g[0]) && (d[v++] = g[0]), a.contains(e.vertices, g[1]) && (d[v++] = g[1]), v < 2) {
                var y = n._findSupports(t, e, h, -1);
                a.contains(t.vertices, y[0]) && (d[v++] = y[0]), v < 2 && a.contains(t.vertices, y[1]) && (d[v++] = y[1])
            }
            return 0 === v && (d[v++] = g[0]), d.length = v, r
        }, n._overlapAxes = function (e, t, i, n) {
            var r, o, s, a, l, c, u = t.length,
                h = i.length,
                d = t[0].x,
                p = t[0].y,
                f = i[0].x,
                m = i[0].y,
                g = n.length,
                v = Number.MAX_VALUE,
                y = 0;
            for (l = 0; l < g; l++) {
                var b = n[l],
                    x = b.x,
                    w = b.y,
                    _ = d * x + p * w,
                    E = f * x + m * w,
                    M = _,
                    S = E;
                for (c = 1; c < u; c += 1)(a = t[c].x * x + t[c].y * w) > M ? M = a : a < _ && (_ = a);
                for (c = 1; c < h; c += 1)(a = i[c].x * x + i[c].y * w) > S ? S = a : a < E && (E = a);
                if ((r = (o = M - E) < (s = S - _) ? o : s) < v && (v = r, y = l, r <= 0)) break
            }
            e.axis = n[y], e.overlap = v
        }, n._projectToAxis = function (e, t, i) {
            for (var n = t[0].x * i.x + t[0].y * i.y, r = n, o = 1; o < t.length; o += 1) {
                var s = t[o].x * i.x + t[o].y * i.y;
                s > r ? r = s : s < n && (n = s)
            }
            e.min = n, e.max = r
        }, n._findSupports = function (e, t, i, n) {
            var o, s, a, l, c, u = t.vertices,
                h = u.length,
                d = e.position.x,
                p = e.position.y,
                f = i.x * n,
                m = i.y * n,
                g = Number.MAX_VALUE;
            for (c = 0; c < h; c += 1)(l = f * (d - (s = u[c]).x) + m * (p - s.y)) < g && (g = l, o = s);
            return g = f * (d - (a = u[(h + o.index - 1) % h]).x) + m * (p - a.y), f * (d - (s = u[(o.index + 1) % h]).x) + m * (p - s.y) < g ? (r[0] = o, r[1] = s, r) : (r[0] = o, r[1] = a, r)
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(16);
        n.create = function (e, t) {
            var i = e.bodyA,
                r = e.bodyB,
                o = {
                    id: n.id(i, r),
                    bodyA: i,
                    bodyB: r,
                    collision: e,
                    contacts: [],
                    activeContacts: [],
                    separation: 0,
                    isActive: !0,
                    confirmedActive: !0,
                    isSensor: i.isSensor || r.isSensor,
                    timeCreated: t,
                    timeUpdated: t,
                    inverseMass: 0,
                    friction: 0,
                    frictionStatic: 0,
                    restitution: 0,
                    slop: 0
                };
            return n.update(o, e, t), o
        }, n.update = function (e, t, i) {
            var n = e.contacts,
                o = t.supports,
                s = e.activeContacts,
                a = t.parentA,
                l = t.parentB,
                c = a.vertices.length;
            e.isActive = !0, e.timeUpdated = i, e.collision = t, e.separation = t.depth, e.inverseMass = a.inverseMass + l.inverseMass, e.friction = a.friction < l.friction ? a.friction : l.friction, e.frictionStatic = a.frictionStatic > l.frictionStatic ? a.frictionStatic : l.frictionStatic, e.restitution = a.restitution > l.restitution ? a.restitution : l.restitution, e.slop = a.slop > l.slop ? a.slop : l.slop, t.pair = e, s.length = 0;
            for (var u = 0; u < o.length; u++) {
                var h = o[u],
                    d = h.body === a ? h.index : c + h.index,
                    p = n[d];
                p ? s.push(p) : s.push(n[d] = r.create(h))
            }
        }, n.setActive = function (e, t, i) {
            t ? (e.isActive = !0, e.timeUpdated = i) : (e.isActive = !1, e.activeContacts.length = 0)
        }, n.id = function (e, t) {
            return e.id < t.id ? "A" + e.id + "B" + t.id : "A" + t.id + "B" + e.id
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(3),
            o = i(2),
            s = i(7),
            a = i(1),
            l = i(11),
            c = i(0);
        n._warming = .4, n._torqueDampen = 1, n._minLength = 1e-6, n.create = function (e) {
            var t = e;
            t.bodyA && !t.pointA && (t.pointA = {
                x: 0,
                y: 0
            }), t.bodyB && !t.pointB && (t.pointB = {
                x: 0,
                y: 0
            });
            var i = t.bodyA ? o.add(t.bodyA.position, t.pointA) : t.pointA,
                n = t.bodyB ? o.add(t.bodyB.position, t.pointB) : t.pointB,
                r = o.magnitude(o.sub(i, n));
            t.length = void 0 !== t.length ? t.length : r, t.id = t.id || c.nextId(), t.label = t.label || "Constraint", t.type = "constraint", t.stiffness = t.stiffness || (t.length > 0 ? 1 : .7), t.damping = t.damping || 0, t.angularStiffness = t.angularStiffness || 0, t.angleA = t.bodyA ? t.bodyA.angle : t.angleA, t.angleB = t.bodyB ? t.bodyB.angle : t.angleB, t.plugin = {};
            var s = {
                visible: !0,
                lineWidth: 2,
                strokeStyle: "#ffffff",
                type: "line",
                anchors: !0
            };
            return 0 === t.length && t.stiffness > .1 ? (s.type = "pin", s.anchors = !1) : t.stiffness < .9 && (s.type = "spring"), t.render = c.extend(s, t.render), t
        }, n.preSolveAll = function (e) {
            for (var t = 0; t < e.length; t += 1) {
                var i = e[t],
                    n = i.constraintImpulse;
                i.isStatic || 0 === n.x && 0 === n.y && 0 === n.angle || (i.position.x += n.x, i.position.y += n.y, i.angle += n.angle)
            }
        }, n.solveAll = function (e, t) {
            for (var i = c.clamp(t / c._baseDelta, 0, 1), r = 0; r < e.length; r += 1) {
                var o = e[r],
                    s = !o.bodyA || o.bodyA && o.bodyA.isStatic,
                    a = !o.bodyB || o.bodyB && o.bodyB.isStatic;
                (s || a) && n.solve(e[r], i)
            }
            for (r = 0; r < e.length; r += 1) s = !(o = e[r]).bodyA || o.bodyA && o.bodyA.isStatic, a = !o.bodyB || o.bodyB && o.bodyB.isStatic, s || a || n.solve(e[r], i)
        }, n.solve = function (e, t) {
            var i = e.bodyA,
                r = e.bodyB,
                s = e.pointA,
                a = e.pointB;
            if (i || r) {
                i && !i.isStatic && (o.rotate(s, i.angle - e.angleA, s), e.angleA = i.angle), r && !r.isStatic && (o.rotate(a, r.angle - e.angleB, a), e.angleB = r.angle);
                var l = s,
                    c = a;
                if (i && (l = o.add(i.position, s)), r && (c = o.add(r.position, a)), l && c) {
                    var u = o.sub(l, c),
                        h = o.magnitude(u);
                    h < n._minLength && (h = n._minLength);
                    var d, p, f, m, g, v = (h - e.length) / h,
                        y = e.stiffness >= 1 || 0 === e.length ? e.stiffness * t : e.stiffness * t * t,
                        b = e.damping * t,
                        x = o.mult(u, v * y),
                        w = (i ? i.inverseMass : 0) + (r ? r.inverseMass : 0),
                        _ = w + ((i ? i.inverseInertia : 0) + (r ? r.inverseInertia : 0));
                    if (b > 0) {
                        var E = o.create();
                        f = o.div(u, h), g = o.sub(r && o.sub(r.position, r.positionPrev) || E, i && o.sub(i.position, i.positionPrev) || E), m = o.dot(f, g)
                    }
                    i && !i.isStatic && (p = i.inverseMass / w, i.constraintImpulse.x -= x.x * p, i.constraintImpulse.y -= x.y * p, i.position.x -= x.x * p, i.position.y -= x.y * p, b > 0 && (i.positionPrev.x -= b * f.x * m * p, i.positionPrev.y -= b * f.y * m * p), d = o.cross(s, x) / _ * n._torqueDampen * i.inverseInertia * (1 - e.angularStiffness), i.constraintImpulse.angle -= d, i.angle -= d), r && !r.isStatic && (p = r.inverseMass / w, r.constraintImpulse.x += x.x * p, r.constraintImpulse.y += x.y * p, r.position.x += x.x * p, r.position.y += x.y * p, b > 0 && (r.positionPrev.x += b * f.x * m * p, r.positionPrev.y += b * f.y * m * p), d = o.cross(a, x) / _ * n._torqueDampen * r.inverseInertia * (1 - e.angularStiffness), r.constraintImpulse.angle += d, r.angle += d)
                }
            }
        }, n.postSolveAll = function (e) {
            for (var t = 0; t < e.length; t++) {
                var i = e[t],
                    c = i.constraintImpulse;
                if (!(i.isStatic || 0 === c.x && 0 === c.y && 0 === c.angle)) {
                    s.set(i, !1);
                    for (var u = 0; u < i.parts.length; u++) {
                        var h = i.parts[u];
                        r.translate(h.vertices, c), u > 0 && (h.position.x += c.x, h.position.y += c.y), 0 !== c.angle && (r.rotate(h.vertices, c.angle, i.position), l.rotate(h.axes, c.angle), u > 0 && o.rotateAbout(h.position, c.angle, i.position, h.position)), a.update(h.bounds, h.vertices, i.velocity)
                    }
                    c.angle *= n._warming, c.x *= n._warming, c.y *= n._warming
                }
            }
        }, n.pointAWorld = function (e) {
            return {
                x: (e.bodyA ? e.bodyA.position.x : 0) + (e.pointA ? e.pointA.x : 0),
                y: (e.bodyA ? e.bodyA.position.y : 0) + (e.pointA ? e.pointA.y : 0)
            }
        }, n.pointBWorld = function (e) {
            return {
                x: (e.bodyB ? e.bodyB.position.x : 0) + (e.pointB ? e.pointB.x : 0),
                y: (e.bodyB ? e.bodyB.position.y : 0) + (e.pointB ? e.pointB.y : 0)
            }
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(2),
            o = i(0);
        n.fromVertices = function (e) {
            for (var t = {}, i = 0; i < e.length; i++) {
                var n = (i + 1) % e.length,
                    s = r.normalise({
                        x: e[n].y - e[i].y,
                        y: e[i].x - e[n].x
                    }),
                    a = 0 === s.y ? 1 / 0 : s.x / s.y;
                t[a = a.toFixed(3).toString()] = s
            }
            return o.values(t)
        }, n.rotate = function (e, t) {
            if (0 !== t)
                for (var i = Math.cos(t), n = Math.sin(t), r = 0; r < e.length; r++) {
                    var o, s = e[r];
                    o = s.x * i - s.y * n, s.y = s.x * n + s.y * i, s.x = o
                }
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(3),
            o = i(0),
            s = i(4),
            a = i(1),
            l = i(2);
        n.rectangle = function (e, t, i, n, a) {
            a = a || {};
            var l = {
                label: "Rectangle Body",
                position: {
                    x: e,
                    y: t
                },
                vertices: r.fromPath("L 0 0 L " + i + " 0 L " + i + " " + n + " L 0 " + n)
            };
            if (a.chamfer) {
                var c = a.chamfer;
                l.vertices = r.chamfer(l.vertices, c.radius, c.quality, c.qualityMin, c.qualityMax), delete a.chamfer
            }
            return s.create(o.extend({}, l, a))
        }, n.trapezoid = function (e, t, i, n, a, l) {
            l = l || {};
            var c, u = i * (a *= .5),
                h = u + (1 - 2 * a) * i,
                d = h + u;
            c = a < .5 ? "L 0 0 L " + u + " " + -n + " L " + h + " " + -n + " L " + d + " 0" : "L 0 0 L " + h + " " + -n + " L " + d + " 0";
            var p = {
                label: "Trapezoid Body",
                position: {
                    x: e,
                    y: t
                },
                vertices: r.fromPath(c)
            };
            if (l.chamfer) {
                var f = l.chamfer;
                p.vertices = r.chamfer(p.vertices, f.radius, f.quality, f.qualityMin, f.qualityMax), delete l.chamfer
            }
            return s.create(o.extend({}, p, l))
        }, n.circle = function (e, t, i, r, s) {
            r = r || {};
            var a = {
                label: "Circle Body",
                circleRadius: i
            };
            s = s || 25;
            var l = Math.ceil(Math.max(10, Math.min(s, i)));
            return l % 2 == 1 && (l += 1), n.polygon(e, t, l, i, o.extend({}, a, r))
        }, n.polygon = function (e, t, i, a, l) {
            if (l = l || {}, i < 3) return n.circle(e, t, a, l);
            for (var c = 2 * Math.PI / i, u = "", h = .5 * c, d = 0; d < i; d += 1) {
                var p = h + d * c,
                    f = Math.cos(p) * a,
                    m = Math.sin(p) * a;
                u += "L " + f.toFixed(3) + " " + m.toFixed(3) + " "
            }
            var g = {
                label: "Polygon Body",
                position: {
                    x: e,
                    y: t
                },
                vertices: r.fromPath(u)
            };
            if (l.chamfer) {
                var v = l.chamfer;
                g.vertices = r.chamfer(g.vertices, v.radius, v.quality, v.qualityMin, v.qualityMax), delete l.chamfer
            }
            return s.create(o.extend({}, g, l))
        }, n.fromVertices = function (e, t, i, n, c, u, h, d) {
            var p, f, m, g, v, y, b, x, w, _, E = o.getDecomp();
            for (p = Boolean(E && E.quickDecomp), n = n || {}, m = [], c = void 0 !== c && c, u = void 0 !== u ? u : .01, h = void 0 !== h ? h : 10, d = void 0 !== d ? d : .01, o.isArray(i[0]) || (i = [i]), w = 0; w < i.length; w += 1)
                if (v = i[w], !(g = r.isConvex(v)) && !p && o.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), g || !p) v = g ? r.clockwiseSort(v) : r.hull(v), m.push({
                    position: {
                        x: e,
                        y: t
                    },
                    vertices: v
                });
                else {
                    var M = v.map((function (e) {
                        return [e.x, e.y]
                    }));
                    E.makeCCW(M), !1 !== u && E.removeCollinearPoints(M, u), !1 !== d && E.removeDuplicatePoints && E.removeDuplicatePoints(M, d);
                    var S = E.quickDecomp(M);
                    for (y = 0; y < S.length; y++) {
                        var T = S[y].map((function (e) {
                            return {
                                x: e[0],
                                y: e[1]
                            }
                        }));
                        h > 0 && r.area(T) < h || m.push({
                            position: r.centre(T),
                            vertices: T
                        })
                    }
                } for (y = 0; y < m.length; y++) m[y] = s.create(o.extend(m[y], n));
            if (c)
                for (y = 0; y < m.length; y++) {
                    var A = m[y];
                    for (b = y + 1; b < m.length; b++) {
                        var C = m[b];
                        if (a.overlaps(A.bounds, C.bounds)) {
                            var L = A.vertices,
                                P = C.vertices;
                            for (x = 0; x < A.vertices.length; x++)
                                for (_ = 0; _ < C.vertices.length; _++) {
                                    var I = l.magnitudeSquared(l.sub(L[(x + 1) % L.length], P[_])),
                                        O = l.magnitudeSquared(l.sub(L[x], P[(_ + 1) % P.length]));
                                    I < 5 && O < 5 && (L[x].isInternal = !0, P[_].isInternal = !0)
                                }
                        }
                    }
                }
            return m.length > 1 ? (f = s.create(o.extend({
                parts: m.slice(0)
            }, n)), s.setPosition(f, {
                x: e,
                y: t
            }), f) : m[0]
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(0),
            o = i(8);
        n.create = function (e) {
            return r.extend({
                bodies: [],
                pairs: null
            }, e)
        }, n.setBodies = function (e, t) {
            e.bodies = t.slice(0)
        }, n.clear = function (e) {
            e.bodies = []
        }, n.collisions = function (e) {
            var t, i, r = [],
                s = e.pairs,
                a = e.bodies,
                l = a.length,
                c = n.canCollide,
                u = o.collides;
            for (a.sort(n._compareBoundsX), t = 0; t < l; t++) {
                var h = a[t],
                    d = h.bounds,
                    p = h.bounds.max.x,
                    f = h.bounds.max.y,
                    m = h.bounds.min.y,
                    g = h.isStatic || h.isSleeping,
                    v = h.parts.length,
                    y = 1 === v;
                for (i = t + 1; i < l; i++) {
                    var b = a[i];
                    if ((A = b.bounds).min.x > p) break;
                    if (!(f < A.min.y || m > A.max.y) && (!g || !b.isStatic && !b.isSleeping) && c(h.collisionFilter, b.collisionFilter)) {
                        var x = b.parts.length;
                        if (y && 1 === x)(S = u(h, b, s)) && r.push(S);
                        else
                            for (var w = x > 1 ? 1 : 0, _ = v > 1 ? 1 : 0; _ < v; _++)
                                for (var E = h.parts[_], M = (d = E.bounds, w); M < x; M++) {
                                    var S, T = b.parts[M],
                                        A = T.bounds;
                                    d.min.x > A.max.x || d.max.x < A.min.x || d.max.y < A.min.y || d.min.y > A.max.y || (S = u(E, T, s)) && r.push(S)
                                }
                    }
                }
            }
            return r
        }, n.canCollide = function (e, t) {
            return e.group === t.group && 0 !== e.group ? e.group > 0 : 0 != (e.mask & t.category) && 0 != (t.mask & e.category)
        }, n._compareBoundsX = function (e, t) {
            return e.bounds.min.x - t.bounds.min.x
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(0);
        n.create = function (e) {
            var t = {};
            return e || r.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), t.element = e || document.body, t.absolute = {
                x: 0,
                y: 0
            }, t.position = {
                x: 0,
                y: 0
            }, t.mousedownPosition = {
                x: 0,
                y: 0
            }, t.mouseupPosition = {
                x: 0,
                y: 0
            }, t.offset = {
                x: 0,
                y: 0
            }, t.scale = {
                x: 1,
                y: 1
            }, t.wheelDelta = 0, t.button = -1, t.pixelRatio = parseInt(t.element.getAttribute("data-pixel-ratio"), 10) || 1, t.sourceEvents = {
                mousemove: null,
                mousedown: null,
                mouseup: null,
                mousewheel: null
            }, t.mousemove = function (e) {
                var i = n._getRelativeMousePosition(e, t.element, t.pixelRatio);
                e.changedTouches && (t.button = 0, e.preventDefault()), t.absolute.x = i.x, t.absolute.y = i.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.sourceEvents.mousemove = e
            }, t.mousedown = function (e) {
                var i = n._getRelativeMousePosition(e, t.element, t.pixelRatio);
                e.changedTouches ? (t.button = 0, e.preventDefault()) : t.button = e.button, t.absolute.x = i.x, t.absolute.y = i.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.mousedownPosition.x = t.position.x, t.mousedownPosition.y = t.position.y, t.sourceEvents.mousedown = e
            }, t.mouseup = function (e) {
                var i = n._getRelativeMousePosition(e, t.element, t.pixelRatio);
                e.changedTouches && e.preventDefault(), t.button = -1, t.absolute.x = i.x, t.absolute.y = i.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.mouseupPosition.x = t.position.x, t.mouseupPosition.y = t.position.y, t.sourceEvents.mouseup = e
            }, t.mousewheel = function (e) {
                t.wheelDelta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail)), e.preventDefault()
            }, n.setElement(t, t.element), t
        }, n.setElement = function (e, t) {
            e.element = t, t.addEventListener("mousemove", e.mousemove), t.addEventListener("mousedown", e.mousedown), t.addEventListener("mouseup", e.mouseup), t.addEventListener("mousewheel", e.mousewheel), t.addEventListener("DOMMouseScroll", e.mousewheel), t.addEventListener("touchmove", e.mousemove), t.addEventListener("touchstart", e.mousedown), t.addEventListener("touchend", e.mouseup)
        }, n.clearSourceEvents = function (e) {
            e.sourceEvents.mousemove = null, e.sourceEvents.mousedown = null, e.sourceEvents.mouseup = null, e.sourceEvents.mousewheel = null, e.wheelDelta = 0
        }, n.setOffset = function (e, t) {
            e.offset.x = t.x, e.offset.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y
        }, n.setScale = function (e, t) {
            e.scale.x = t.x, e.scale.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y
        }, n._getRelativeMousePosition = function (e, t, i) {
            var n, r, o = t.getBoundingClientRect(),
                s = document.documentElement || document.body.parentNode || document.body,
                a = void 0 !== window.pageXOffset ? window.pageXOffset : s.scrollLeft,
                l = void 0 !== window.pageYOffset ? window.pageYOffset : s.scrollTop,
                c = e.changedTouches;
            return c ? (n = c[0].pageX - o.left - a, r = c[0].pageY - o.top - l) : (n = e.pageX - o.left - a, r = e.pageY - o.top - l), {
                x: n / (t.clientWidth / (t.width || t.clientWidth) * i),
                y: r / (t.clientHeight / (t.height || t.clientHeight) * i)
            }
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(0);
        n._registry = {}, n.register = function (e) {
            if (n.isPlugin(e) || r.warn("Plugin.register:", n.toString(e), "does not implement all required fields."), e.name in n._registry) {
                var t = n._registry[e.name],
                    i = n.versionParse(e.version).number,
                    o = n.versionParse(t.version).number;
                i > o ? (r.warn("Plugin.register:", n.toString(t), "was upgraded to", n.toString(e)), n._registry[e.name] = e) : i < o ? r.warn("Plugin.register:", n.toString(t), "can not be downgraded to", n.toString(e)) : e !== t && r.warn("Plugin.register:", n.toString(e), "is already registered to different plugin object")
            } else n._registry[e.name] = e;
            return e
        }, n.resolve = function (e) {
            return n._registry[n.dependencyParse(e).name]
        }, n.toString = function (e) {
            return "string" == typeof e ? e : (e.name || "anonymous") + "@" + (e.version || e.range || "0.0.0")
        }, n.isPlugin = function (e) {
            return e && e.name && e.version && e.install
        }, n.isUsed = function (e, t) {
            return e.used.indexOf(t) > -1
        }, n.isFor = function (e, t) {
            var i = e.for && n.dependencyParse(e.for);
            return !e.for || t.name === i.name && n.versionSatisfies(t.version, i.range)
        }, n.use = function (e, t) {
            if (e.uses = (e.uses || []).concat(t || []), 0 !== e.uses.length) {
                for (var i = n.dependencies(e), o = r.topologicalSort(i), s = [], a = 0; a < o.length; a += 1)
                    if (o[a] !== e.name) {
                        var l = n.resolve(o[a]);
                        l ? n.isUsed(e, l.name) || (n.isFor(l, e) || (r.warn("Plugin.use:", n.toString(l), "is for", l.for, "but installed on", n.toString(e) + "."), l._warned = !0), l.install ? l.install(e) : (r.warn("Plugin.use:", n.toString(l), "does not specify an install function."), l._warned = !0), l._warned ? (s.push(" " + n.toString(l)), delete l._warned) : s.push(" " + n.toString(l)), e.used.push(l.name)) : s.push(" " + o[a])
                    } s.length > 0 && r.info(s.join("  "))
            } else r.warn("Plugin.use:", n.toString(e), "does not specify any dependencies to install.")
        }, n.dependencies = function (e, t) {
            var i = n.dependencyParse(e),
                o = i.name;
            if (!(o in (t = t || {}))) {
                e = n.resolve(e) || e, t[o] = r.map(e.uses || [], (function (t) {
                    n.isPlugin(t) && n.register(t);
                    var o = n.dependencyParse(t),
                        s = n.resolve(t);
                    return s && !n.versionSatisfies(s.version, o.range) ? (r.warn("Plugin.dependencies:", n.toString(s), "does not satisfy", n.toString(o), "used by", n.toString(i) + "."), s._warned = !0, e._warned = !0) : s || (r.warn("Plugin.dependencies:", n.toString(t), "used by", n.toString(i), "could not be resolved."), e._warned = !0), o.name
                }));
                for (var s = 0; s < t[o].length; s += 1) n.dependencies(t[o][s], t);
                return t
            }
        }, n.dependencyParse = function (e) {
            return r.isString(e) ? (/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/.test(e) || r.warn("Plugin.dependencyParse:", e, "is not a valid dependency string."), {
                name: e.split("@")[0],
                range: e.split("@")[1] || "*"
            }) : {
                name: e.name,
                range: e.range || e.version
            }
        }, n.versionParse = function (e) {
            var t = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;
            t.test(e) || r.warn("Plugin.versionParse:", e, "is not a valid version or range.");
            var i = t.exec(e),
                n = Number(i[4]),
                o = Number(i[5]),
                s = Number(i[6]);
            return {
                isRange: Boolean(i[1] || i[2]),
                version: i[3],
                range: e,
                operator: i[1] || i[2] || "",
                major: n,
                minor: o,
                patch: s,
                parts: [n, o, s],
                prerelease: i[7],
                number: 1e8 * n + 1e4 * o + s
            }
        }, n.versionSatisfies = function (e, t) {
            t = t || "*";
            var i = n.versionParse(t),
                r = n.versionParse(e);
            if (i.isRange) {
                if ("*" === i.operator || "*" === e) return !0;
                if (">" === i.operator) return r.number > i.number;
                if (">=" === i.operator) return r.number >= i.number;
                if ("~" === i.operator) return r.major === i.major && r.minor === i.minor && r.patch >= i.patch;
                if ("^" === i.operator) return i.major > 0 ? r.major === i.major && r.number >= i.number : i.minor > 0 ? r.minor === i.minor && r.patch >= i.patch : r.patch === i.patch
            }
            return e === t || "*" === e
        }
    }, function (e, t) {
        var i = {};
        e.exports = i, i.create = function (e) {
            return {
                vertex: e,
                normalImpulse: 0,
                tangentImpulse: 0
            }
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(7),
            o = i(18),
            s = i(13),
            a = i(19),
            l = i(5),
            c = i(6),
            u = i(10),
            h = i(0),
            d = i(4);
        n.create = function (e) {
            e = e || {};
            var t = h.extend({
                positionIterations: 6,
                velocityIterations: 4,
                constraintIterations: 2,
                enableSleeping: !1,
                events: [],
                plugin: {},
                gravity: {
                    x: 0,
                    y: 1,
                    scale: .001
                },
                timing: {
                    timestamp: 0,
                    timeScale: 1,
                    lastDelta: 0,
                    lastElapsed: 0
                }
            }, e);
            return t.world = e.world || c.create({
                label: "World"
            }), t.pairs = e.pairs || a.create(), t.detector = e.detector || s.create(), t.grid = {
                buckets: []
            }, t.world.gravity = t.gravity, t.broadphase = t.grid, t.metrics = {}, t
        }, n.update = function (e, t) {
            var i, d = h.now(),
                p = e.world,
                f = e.detector,
                m = e.pairs,
                g = e.timing,
                v = g.timestamp;
            t = void 0 !== t ? t : h._baseDelta, t *= g.timeScale, g.timestamp += t, g.lastDelta = t;
            var y = {
                timestamp: g.timestamp,
                delta: t
            };
            l.trigger(e, "beforeUpdate", y);
            var b = c.allBodies(p),
                x = c.allConstraints(p);
            for (p.isModified && (s.setBodies(f, b), c.setModified(p, !1, !1, !0)), e.enableSleeping && r.update(b, t), n._bodiesApplyGravity(b, e.gravity), t > 0 && n._bodiesUpdate(b, t), u.preSolveAll(b), i = 0; i < e.constraintIterations; i++) u.solveAll(x, t);
            u.postSolveAll(b), f.pairs = e.pairs;
            var w = s.collisions(f);
            a.update(m, w, v), e.enableSleeping && r.afterCollisions(m.list), m.collisionStart.length > 0 && l.trigger(e, "collisionStart", {
                pairs: m.collisionStart
            });
            var _ = h.clamp(20 / e.positionIterations, 0, 1);
            for (o.preSolvePosition(m.list), i = 0; i < e.positionIterations; i++) o.solvePosition(m.list, t, _);
            for (o.postSolvePosition(b), u.preSolveAll(b), i = 0; i < e.constraintIterations; i++) u.solveAll(x, t);
            for (u.postSolveAll(b), o.preSolveVelocity(m.list), i = 0; i < e.velocityIterations; i++) o.solveVelocity(m.list, t);
            return n._bodiesUpdateVelocities(b), m.collisionActive.length > 0 && l.trigger(e, "collisionActive", {
                pairs: m.collisionActive
            }), m.collisionEnd.length > 0 && l.trigger(e, "collisionEnd", {
                pairs: m.collisionEnd
            }), n._bodiesClearForces(b), l.trigger(e, "afterUpdate", y), e.timing.lastElapsed = h.now() - d, e
        }, n.merge = function (e, t) {
            if (h.extend(e, t), t.world) {
                e.world = t.world, n.clear(e);
                for (var i = c.allBodies(e.world), o = 0; o < i.length; o++) {
                    var s = i[o];
                    r.set(s, !1), s.id = h.nextId()
                }
            }
        }, n.clear = function (e) {
            a.clear(e.pairs), s.clear(e.detector)
        }, n._bodiesClearForces = function (e) {
            for (var t = e.length, i = 0; i < t; i++) {
                var n = e[i];
                n.force.x = 0, n.force.y = 0, n.torque = 0
            }
        }, n._bodiesApplyGravity = function (e, t) {
            var i = void 0 !== t.scale ? t.scale : .001,
                n = e.length;
            if ((0 !== t.x || 0 !== t.y) && 0 !== i)
                for (var r = 0; r < n; r++) {
                    var o = e[r];
                    o.isStatic || o.isSleeping || (o.force.y += o.mass * t.y * i, o.force.x += o.mass * t.x * i)
                }
        }, n._bodiesUpdate = function (e, t) {
            for (var i = e.length, n = 0; n < i; n++) {
                var r = e[n];
                r.isStatic || r.isSleeping || d.update(r, t)
            }
        }, n._bodiesUpdateVelocities = function (e) {
            for (var t = e.length, i = 0; i < t; i++) d.updateVelocities(e[i])
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(3),
            o = i(0),
            s = i(1);
        n._restingThresh = 2, n._restingThreshTangent = Math.sqrt(6), n._positionDampen = .9, n._positionWarming = .8, n._frictionNormalMultiplier = 5, n._frictionMaxStatic = Number.MAX_VALUE, n.preSolvePosition = function (e) {
            var t, i, n, r = e.length;
            for (t = 0; t < r; t++)(i = e[t]).isActive && (n = i.activeContacts.length, i.collision.parentA.totalContacts += n, i.collision.parentB.totalContacts += n)
        }, n.solvePosition = function (e, t, i) {
            var r, s, a, l, c, u, h, d, p = n._positionDampen * (i || 1),
                f = o.clamp(t / o._baseDelta, 0, 1),
                m = e.length;
            for (r = 0; r < m; r++)(s = e[r]).isActive && !s.isSensor && (l = (a = s.collision).parentA, c = a.parentB, u = a.normal, s.separation = u.x * (c.positionImpulse.x + a.penetration.x - l.positionImpulse.x) + u.y * (c.positionImpulse.y + a.penetration.y - l.positionImpulse.y));
            for (r = 0; r < m; r++)(s = e[r]).isActive && !s.isSensor && (l = (a = s.collision).parentA, c = a.parentB, u = a.normal, d = s.separation - s.slop * f, (l.isStatic || c.isStatic) && (d *= 2), l.isStatic || l.isSleeping || (h = p / l.totalContacts, l.positionImpulse.x += u.x * d * h, l.positionImpulse.y += u.y * d * h), c.isStatic || c.isSleeping || (h = p / c.totalContacts, c.positionImpulse.x -= u.x * d * h, c.positionImpulse.y -= u.y * d * h))
        }, n.postSolvePosition = function (e) {
            for (var t = n._positionWarming, i = e.length, o = r.translate, a = s.update, l = 0; l < i; l++) {
                var c = e[l],
                    u = c.positionImpulse,
                    h = u.x,
                    d = u.y,
                    p = c.velocity;
                if (c.totalContacts = 0, 0 !== h || 0 !== d) {
                    for (var f = 0; f < c.parts.length; f++) {
                        var m = c.parts[f];
                        o(m.vertices, u), a(m.bounds, m.vertices, p), m.position.x += h, m.position.y += d
                    }
                    c.positionPrev.x += h, c.positionPrev.y += d, h * p.x + d * p.y < 0 ? (u.x = 0, u.y = 0) : (u.x *= t, u.y *= t)
                }
            }
        }, n.preSolveVelocity = function (e) {
            var t, i, n = e.length;
            for (t = 0; t < n; t++) {
                var r = e[t];
                if (r.isActive && !r.isSensor) {
                    var o = r.activeContacts,
                        s = o.length,
                        a = r.collision,
                        l = a.parentA,
                        c = a.parentB,
                        u = a.normal,
                        h = a.tangent;
                    for (i = 0; i < s; i++) {
                        var d = o[i],
                            p = d.vertex,
                            f = d.normalImpulse,
                            m = d.tangentImpulse;
                        if (0 !== f || 0 !== m) {
                            var g = u.x * f + h.x * m,
                                v = u.y * f + h.y * m;
                            l.isStatic || l.isSleeping || (l.positionPrev.x += g * l.inverseMass, l.positionPrev.y += v * l.inverseMass, l.anglePrev += l.inverseInertia * ((p.x - l.position.x) * v - (p.y - l.position.y) * g)), c.isStatic || c.isSleeping || (c.positionPrev.x -= g * c.inverseMass, c.positionPrev.y -= v * c.inverseMass, c.anglePrev -= c.inverseInertia * ((p.x - c.position.x) * v - (p.y - c.position.y) * g))
                        }
                    }
                }
            }
        }, n.solveVelocity = function (e, t) {
            var i, r, s, a, l = t / o._baseDelta,
                c = l * l * l,
                u = -n._restingThresh * l,
                h = n._restingThreshTangent,
                d = n._frictionNormalMultiplier * l,
                p = n._frictionMaxStatic,
                f = e.length;
            for (s = 0; s < f; s++) {
                var m = e[s];
                if (m.isActive && !m.isSensor) {
                    var g = m.collision,
                        v = g.parentA,
                        y = g.parentB,
                        b = v.velocity,
                        x = y.velocity,
                        w = g.normal.x,
                        _ = g.normal.y,
                        E = g.tangent.x,
                        M = g.tangent.y,
                        S = m.activeContacts,
                        T = S.length,
                        A = 1 / T,
                        C = v.inverseMass + y.inverseMass,
                        L = m.friction * m.frictionStatic * d;
                    for (b.x = v.position.x - v.positionPrev.x, b.y = v.position.y - v.positionPrev.y, x.x = y.position.x - y.positionPrev.x, x.y = y.position.y - y.positionPrev.y, v.angularVelocity = v.angle - v.anglePrev, y.angularVelocity = y.angle - y.anglePrev, a = 0; a < T; a++) {
                        var P = S[a],
                            I = P.vertex,
                            O = I.x - v.position.x,
                            R = I.y - v.position.y,
                            D = I.x - y.position.x,
                            k = I.y - y.position.y,
                            z = b.x - R * v.angularVelocity,
                            B = b.y + O * v.angularVelocity,
                            N = z - (x.x - k * y.angularVelocity),
                            F = B - (x.y + D * y.angularVelocity),
                            H = w * N + _ * F,
                            U = E * N + M * F,
                            j = m.separation + H,
                            G = Math.min(j, 1),
                            V = (G = j < 0 ? 0 : G) * L;
                        U < -V || U > V ? (r = U > 0 ? U : -U, (i = m.friction * (U > 0 ? 1 : -1) * c) < -r ? i = -r : i > r && (i = r)) : (i = U, r = p);
                        var W = O * _ - R * w,
                            q = D * _ - k * w,
                            X = A / (C + v.inverseInertia * W * W + y.inverseInertia * q * q),
                            Y = (1 + m.restitution) * H * X;
                        if (i *= X, H < u) P.normalImpulse = 0;
                        else {
                            var Z = P.normalImpulse;
                            P.normalImpulse += Y, P.normalImpulse > 0 && (P.normalImpulse = 0), Y = P.normalImpulse - Z
                        }
                        if (U < -h || U > h) P.tangentImpulse = 0;
                        else {
                            var Q = P.tangentImpulse;
                            P.tangentImpulse += i, P.tangentImpulse < -r && (P.tangentImpulse = -r), P.tangentImpulse > r && (P.tangentImpulse = r), i = P.tangentImpulse - Q
                        }
                        var J = w * Y + E * i,
                            K = _ * Y + M * i;
                        v.isStatic || v.isSleeping || (v.positionPrev.x += J * v.inverseMass, v.positionPrev.y += K * v.inverseMass, v.anglePrev += (O * K - R * J) * v.inverseInertia), y.isStatic || y.isSleeping || (y.positionPrev.x -= J * y.inverseMass, y.positionPrev.y -= K * y.inverseMass, y.anglePrev -= (D * K - k * J) * y.inverseInertia)
                    }
                }
            }
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(9),
            o = i(0);
        n.create = function (e) {
            return o.extend({
                table: {},
                list: [],
                collisionStart: [],
                collisionActive: [],
                collisionEnd: []
            }, e)
        }, n.update = function (e, t, i) {
            var n, o, s, a, l = e.list,
                c = l.length,
                u = e.table,
                h = t.length,
                d = e.collisionStart,
                p = e.collisionEnd,
                f = e.collisionActive;
            for (d.length = 0, p.length = 0, f.length = 0, a = 0; a < c; a++) l[a].confirmedActive = !1;
            for (a = 0; a < h; a++)(s = (n = t[a]).pair) ? (s.isActive ? f.push(s) : d.push(s), r.update(s, n, i), s.confirmedActive = !0) : (u[(s = r.create(n, i)).id] = s, d.push(s), l.push(s));
            var m = [];
            for (c = l.length, a = 0; a < c; a++)(s = l[a]).confirmedActive || (r.setActive(s, !1, i), p.push(s), s.collision.bodyA.isSleeping || s.collision.bodyB.isSleeping || m.push(a));
            for (a = 0; a < m.length; a++) s = l[o = m[a] - a], l.splice(o, 1), delete u[s.id]
        }, n.clear = function (e) {
            return e.table = {}, e.list.length = 0, e.collisionStart.length = 0, e.collisionActive.length = 0, e.collisionEnd.length = 0, e
        }
    }, function (e, t, i) {
        var n = e.exports = i(21);
        n.Axes = i(11), n.Bodies = i(12), n.Body = i(4), n.Bounds = i(1), n.Collision = i(8), n.Common = i(0), n.Composite = i(6), n.Composites = i(22), n.Constraint = i(10), n.Contact = i(16), n.Detector = i(13), n.Engine = i(17), n.Events = i(5), n.Grid = i(23), n.Mouse = i(14), n.MouseConstraint = i(24), n.Pair = i(9), n.Pairs = i(19), n.Plugin = i(15), n.Query = i(25), n.Render = i(26), n.Resolver = i(18), n.Runner = i(27), n.SAT = i(28), n.Sleeping = i(7), n.Svg = i(29), n.Vector = i(2), n.Vertices = i(3), n.World = i(30), n.Engine.run = n.Runner.run, n.Common.deprecated(n.Engine, "run", "Engine.run  use Matter.Runner.run(engine) instead")
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(15),
            o = i(0);
        n.name = "matter-js", n.version = "0.19.0", n.uses = [], n.used = [], n.use = function () {
            r.use(n, Array.prototype.slice.call(arguments))
        }, n.before = function (e, t) {
            return e = e.replace(/^Matter./, ""), o.chainPathBefore(n, e, t)
        }, n.after = function (e, t) {
            return e = e.replace(/^Matter./, ""), o.chainPathAfter(n, e, t)
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(6),
            o = i(10),
            s = i(0),
            a = i(4),
            l = i(12),
            c = s.deprecated;
        n.stack = function (e, t, i, n, o, s, l) {
            for (var c, u = r.create({
                    label: "Stack"
                }), h = e, d = t, p = 0, f = 0; f < n; f++) {
                for (var m = 0, g = 0; g < i; g++) {
                    var v = l(h, d, g, f, c, p);
                    if (v) {
                        var y = v.bounds.max.y - v.bounds.min.y,
                            b = v.bounds.max.x - v.bounds.min.x;
                        y > m && (m = y), a.translate(v, {
                            x: .5 * b,
                            y: .5 * y
                        }), h = v.bounds.max.x + o, r.addBody(u, v), c = v, p += 1
                    } else h += o
                }
                d += m + s, h = e
            }
            return u
        }, n.chain = function (e, t, i, n, a, l) {
            for (var c = e.bodies, u = 1; u < c.length; u++) {
                var h = c[u - 1],
                    d = c[u],
                    p = h.bounds.max.y - h.bounds.min.y,
                    f = h.bounds.max.x - h.bounds.min.x,
                    m = d.bounds.max.y - d.bounds.min.y,
                    g = {
                        bodyA: h,
                        pointA: {
                            x: f * t,
                            y: p * i
                        },
                        bodyB: d,
                        pointB: {
                            x: (d.bounds.max.x - d.bounds.min.x) * n,
                            y: m * a
                        }
                    },
                    v = s.extend(g, l);
                r.addConstraint(e, o.create(v))
            }
            return e.label += " Chain", e
        }, n.mesh = function (e, t, i, n, a) {
            var l, c, u, h, d, p = e.bodies;
            for (l = 0; l < i; l++) {
                for (c = 1; c < t; c++) u = p[c - 1 + l * t], h = p[c + l * t], r.addConstraint(e, o.create(s.extend({
                    bodyA: u,
                    bodyB: h
                }, a)));
                if (l > 0)
                    for (c = 0; c < t; c++) u = p[c + (l - 1) * t], h = p[c + l * t], r.addConstraint(e, o.create(s.extend({
                        bodyA: u,
                        bodyB: h
                    }, a))), n && c > 0 && (d = p[c - 1 + (l - 1) * t], r.addConstraint(e, o.create(s.extend({
                        bodyA: d,
                        bodyB: h
                    }, a)))), n && c < t - 1 && (d = p[c + 1 + (l - 1) * t], r.addConstraint(e, o.create(s.extend({
                        bodyA: d,
                        bodyB: h
                    }, a))))
            }
            return e.label += " Mesh", e
        }, n.pyramid = function (e, t, i, r, o, s, l) {
            return n.stack(e, t, i, r, o, s, (function (t, n, s, c, u, h) {
                var d = Math.min(r, Math.ceil(i / 2)),
                    p = u ? u.bounds.max.x - u.bounds.min.x : 0;
                if (!(c > d || s < (c = d - c) || s > i - 1 - c)) return 1 === h && a.translate(u, {
                    x: (s + (i % 2 == 1 ? 1 : -1)) * p,
                    y: 0
                }), l(e + (u ? s * p : 0) + s * o, n, s, c, u, h)
            }))
        }, n.newtonsCradle = function (e, t, i, n, s) {
            for (var a = r.create({
                    label: "Newtons Cradle"
                }), c = 0; c < i; c++) {
                var u = l.circle(e + c * (1.9 * n), t + s, n, {
                        inertia: 1 / 0,
                        restitution: 1,
                        friction: 0,
                        frictionAir: 1e-4,
                        slop: 1
                    }),
                    h = o.create({
                        pointA: {
                            x: e + c * (1.9 * n),
                            y: t
                        },
                        bodyB: u
                    });
                r.addBody(a, u), r.addConstraint(a, h)
            }
            return a
        }, c(n, "newtonsCradle", "Composites.newtonsCradle  moved to newtonsCradle example"), n.car = function (e, t, i, n, s) {
            var c = a.nextGroup(!0),
                u = .5 * -i + 20,
                h = .5 * i - 20,
                d = r.create({
                    label: "Car"
                }),
                p = l.rectangle(e, t, i, n, {
                    collisionFilter: {
                        group: c
                    },
                    chamfer: {
                        radius: .5 * n
                    },
                    density: 2e-4
                }),
                f = l.circle(e + u, t + 0, s, {
                    collisionFilter: {
                        group: c
                    },
                    friction: .8
                }),
                m = l.circle(e + h, t + 0, s, {
                    collisionFilter: {
                        group: c
                    },
                    friction: .8
                }),
                g = o.create({
                    bodyB: p,
                    pointB: {
                        x: u,
                        y: 0
                    },
                    bodyA: f,
                    stiffness: 1,
                    length: 0
                }),
                v = o.create({
                    bodyB: p,
                    pointB: {
                        x: h,
                        y: 0
                    },
                    bodyA: m,
                    stiffness: 1,
                    length: 0
                });
            return r.addBody(d, p), r.addBody(d, f), r.addBody(d, m), r.addConstraint(d, g), r.addConstraint(d, v), d
        }, c(n, "car", "Composites.car  moved to car example"), n.softBody = function (e, t, i, r, o, a, c, u, h, d) {
            h = s.extend({
                inertia: 1 / 0
            }, h), d = s.extend({
                stiffness: .2,
                render: {
                    type: "line",
                    anchors: !1
                }
            }, d);
            var p = n.stack(e, t, i, r, o, a, (function (e, t) {
                return l.circle(e, t, u, h)
            }));
            return n.mesh(p, i, r, c, d), p.label = "Soft Body", p
        }, c(n, "softBody", "Composites.softBody  moved to softBody and cloth examples")
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(9),
            o = i(0),
            s = o.deprecated;
        n.create = function (e) {
            return o.extend({
                buckets: {},
                pairs: {},
                pairsList: [],
                bucketWidth: 48,
                bucketHeight: 48
            }, e)
        }, n.update = function (e, t, i, r) {
            var o, s, a, l, c, u = i.world,
                h = e.buckets,
                d = !1;
            for (o = 0; o < t.length; o++) {
                var p = t[o];
                if ((!p.isSleeping || r) && (!u.bounds || !(p.bounds.max.x < u.bounds.min.x || p.bounds.min.x > u.bounds.max.x || p.bounds.max.y < u.bounds.min.y || p.bounds.min.y > u.bounds.max.y))) {
                    var f = n._getRegion(e, p);
                    if (!p.region || f.id !== p.region.id || r) {
                        p.region && !r || (p.region = f);
                        var m = n._regionUnion(f, p.region);
                        for (s = m.startCol; s <= m.endCol; s++)
                            for (a = m.startRow; a <= m.endRow; a++) {
                                l = h[c = n._getBucketId(s, a)];
                                var g = s >= f.startCol && s <= f.endCol && a >= f.startRow && a <= f.endRow,
                                    v = s >= p.region.startCol && s <= p.region.endCol && a >= p.region.startRow && a <= p.region.endRow;
                                !g && v && v && l && n._bucketRemoveBody(e, l, p), (p.region === f || g && !v || r) && (l || (l = n._createBucket(h, c)), n._bucketAddBody(e, l, p))
                            }
                        p.region = f, d = !0
                    }
                }
            }
            d && (e.pairsList = n._createActivePairsList(e))
        }, s(n, "update", "Grid.update  replaced by Matter.Detector"), n.clear = function (e) {
            e.buckets = {}, e.pairs = {}, e.pairsList = []
        }, s(n, "clear", "Grid.clear  replaced by Matter.Detector"), n._regionUnion = function (e, t) {
            var i = Math.min(e.startCol, t.startCol),
                r = Math.max(e.endCol, t.endCol),
                o = Math.min(e.startRow, t.startRow),
                s = Math.max(e.endRow, t.endRow);
            return n._createRegion(i, r, o, s)
        }, n._getRegion = function (e, t) {
            var i = t.bounds,
                r = Math.floor(i.min.x / e.bucketWidth),
                o = Math.floor(i.max.x / e.bucketWidth),
                s = Math.floor(i.min.y / e.bucketHeight),
                a = Math.floor(i.max.y / e.bucketHeight);
            return n._createRegion(r, o, s, a)
        }, n._createRegion = function (e, t, i, n) {
            return {
                id: e + "," + t + "," + i + "," + n,
                startCol: e,
                endCol: t,
                startRow: i,
                endRow: n
            }
        }, n._getBucketId = function (e, t) {
            return "C" + e + "R" + t
        }, n._createBucket = function (e, t) {
            return e[t] = []
        }, n._bucketAddBody = function (e, t, i) {
            var n, o = e.pairs,
                s = r.id,
                a = t.length;
            for (n = 0; n < a; n++) {
                var l = t[n];
                if (!(i.id === l.id || i.isStatic && l.isStatic)) {
                    var c = s(i, l),
                        u = o[c];
                    u ? u[2] += 1 : o[c] = [i, l, 1]
                }
            }
            t.push(i)
        }, n._bucketRemoveBody = function (e, t, i) {
            var n, s = e.pairs,
                a = r.id;
            t.splice(o.indexOf(t, i), 1);
            var l = t.length;
            for (n = 0; n < l; n++) {
                var c = s[a(i, t[n])];
                c && (c[2] -= 1)
            }
        }, n._createActivePairsList = function (e) {
            var t, i, n = e.pairs,
                r = o.keys(n),
                s = r.length,
                a = [];
            for (i = 0; i < s; i++)(t = n[r[i]])[2] > 0 ? a.push(t) : delete n[r[i]];
            return a
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(3),
            o = i(7),
            s = i(14),
            a = i(5),
            l = i(13),
            c = i(10),
            u = i(6),
            h = i(0),
            d = i(1);
        n.create = function (e, t) {
            var i = (e ? e.mouse : null) || (t ? t.mouse : null);
            i || (e && e.render && e.render.canvas ? i = s.create(e.render.canvas) : t && t.element ? i = s.create(t.element) : (i = s.create(), h.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));
            var r = {
                    type: "mouseConstraint",
                    mouse: i,
                    element: null,
                    body: null,
                    constraint: c.create({
                        label: "Mouse Constraint",
                        pointA: i.position,
                        pointB: {
                            x: 0,
                            y: 0
                        },
                        length: .01,
                        stiffness: .1,
                        angularStiffness: 1,
                        render: {
                            strokeStyle: "#90EE90",
                            lineWidth: 3
                        }
                    }),
                    collisionFilter: {
                        category: 1,
                        mask: 4294967295,
                        group: 0
                    }
                },
                o = h.extend(r, t);
            return a.on(e, "beforeUpdate", (function () {
                var t = u.allBodies(e.world);
                n.update(o, t), n._triggerEvents(o)
            })), o
        }, n.update = function (e, t) {
            var i = e.mouse,
                n = e.constraint,
                s = e.body;
            if (0 === i.button) {
                if (n.bodyB) o.set(n.bodyB, !1), n.pointA = i.position;
                else
                    for (var c = 0; c < t.length; c++)
                        if (s = t[c], d.contains(s.bounds, i.position) && l.canCollide(s.collisionFilter, e.collisionFilter))
                            for (var u = s.parts.length > 1 ? 1 : 0; u < s.parts.length; u++) {
                                var h = s.parts[u];
                                if (r.contains(h.vertices, i.position)) {
                                    n.pointA = i.position, n.bodyB = e.body = s, n.pointB = {
                                        x: i.position.x - s.position.x,
                                        y: i.position.y - s.position.y
                                    }, n.angleB = s.angle, o.set(s, !1), a.trigger(e, "startdrag", {
                                        mouse: i,
                                        body: s
                                    });
                                    break
                                }
                            }
            } else n.bodyB = e.body = null, n.pointB = null, s && a.trigger(e, "enddrag", {
                mouse: i,
                body: s
            })
        }, n._triggerEvents = function (e) {
            var t = e.mouse,
                i = t.sourceEvents;
            i.mousemove && a.trigger(e, "mousemove", {
                mouse: t
            }), i.mousedown && a.trigger(e, "mousedown", {
                mouse: t
            }), i.mouseup && a.trigger(e, "mouseup", {
                mouse: t
            }), s.clearSourceEvents(t)
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(2),
            o = i(8),
            s = i(1),
            a = i(12),
            l = i(3);
        n.collides = function (e, t) {
            for (var i = [], n = t.length, r = e.bounds, a = o.collides, l = s.overlaps, c = 0; c < n; c++) {
                var u = t[c],
                    h = u.parts.length,
                    d = 1 === h ? 0 : 1;
                if (l(u.bounds, r))
                    for (var p = d; p < h; p++) {
                        var f = u.parts[p];
                        if (l(f.bounds, r)) {
                            var m = a(f, e);
                            if (m) {
                                i.push(m);
                                break
                            }
                        }
                    }
            }
            return i
        }, n.ray = function (e, t, i, o) {
            o = o || 1e-100;
            for (var s = r.angle(t, i), l = r.magnitude(r.sub(t, i)), c = .5 * (i.x + t.x), u = .5 * (i.y + t.y), h = a.rectangle(c, u, l, o, {
                    angle: s
                }), d = n.collides(h, e), p = 0; p < d.length; p += 1) {
                var f = d[p];
                f.body = f.bodyB = f.bodyA
            }
            return d
        }, n.region = function (e, t, i) {
            for (var n = [], r = 0; r < e.length; r++) {
                var o = e[r],
                    a = s.overlaps(o.bounds, t);
                (a && !i || !a && i) && n.push(o)
            }
            return n
        }, n.point = function (e, t) {
            for (var i = [], n = 0; n < e.length; n++) {
                var r = e[n];
                if (s.contains(r.bounds, t))
                    for (var o = 1 === r.parts.length ? 0 : 1; o < r.parts.length; o++) {
                        var a = r.parts[o];
                        if (s.contains(a.bounds, t) && l.contains(a.vertices, t)) {
                            i.push(r);
                            break
                        }
                    }
            }
            return i
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(4),
            o = i(0),
            s = i(6),
            a = i(1),
            l = i(5),
            c = i(2),
            u = i(14);
        ! function () {
            var e, t;
            "undefined" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {
                window.setTimeout((function () {
                    e(o.now())
                }), 1e3 / 60)
            }, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), n._goodFps = 30, n._goodDelta = 1e3 / 60, n.create = function (e) {
                var t = {
                        engine: null,
                        element: null,
                        canvas: null,
                        mouse: null,
                        frameRequestId: null,
                        timing: {
                            historySize: 60,
                            delta: 0,
                            deltaHistory: [],
                            lastTime: 0,
                            lastTimestamp: 0,
                            lastElapsed: 0,
                            timestampElapsed: 0,
                            timestampElapsedHistory: [],
                            engineDeltaHistory: [],
                            engineElapsedHistory: [],
                            elapsedHistory: []
                        },
                        options: {
                            width: 800,
                            height: 600,
                            pixelRatio: 1,
                            background: "#14151f",
                            wireframeBackground: "#14151f",
                            hasBounds: !!e.bounds,
                            enabled: !0,
                            wireframes: !0,
                            showSleeping: !0,
                            showDebug: !1,
                            showStats: !1,
                            showPerformance: !1,
                            showBounds: !1,
                            showVelocity: !1,
                            showCollisions: !1,
                            showSeparations: !1,
                            showAxes: !1,
                            showPositions: !1,
                            showAngleIndicator: !1,
                            showIds: !1,
                            showVertexNumbers: !1,
                            showConvexHulls: !1,
                            showInternalEdges: !1,
                            showMousePosition: !1
                        }
                    },
                    i = o.extend(t, e);
                return i.canvas && (i.canvas.width = i.options.width || i.canvas.width, i.canvas.height = i.options.height || i.canvas.height), i.mouse = e.mouse, i.engine = e.engine, i.canvas = i.canvas || d(i.options.width, i.options.height), i.context = i.canvas.getContext("2d"), i.textures = {}, i.bounds = i.bounds || {
                    min: {
                        x: 0,
                        y: 0
                    },
                    max: {
                        x: i.canvas.width,
                        y: i.canvas.height
                    }
                }, i.controller = n, i.options.showBroadphase = !1, 1 !== i.options.pixelRatio && n.setPixelRatio(i, i.options.pixelRatio), o.isElement(i.element) && i.element.appendChild(i.canvas), i
            }, n.run = function (t) {
                ! function r(o) {
                    t.frameRequestId = e(r), i(t, o), n.world(t, o), (t.options.showStats || t.options.showDebug) && n.stats(t, t.context, o), (t.options.showPerformance || t.options.showDebug) && n.performance(t, t.context, o)
                }()
            }, n.stop = function (e) {
                t(e.frameRequestId)
            }, n.setPixelRatio = function (e, t) {
                var i = e.options,
                    n = e.canvas;
                "auto" === t && (t = p(n)), i.pixelRatio = t, n.setAttribute("data-pixel-ratio", t), n.width = i.width * t, n.height = i.height * t, n.style.width = i.width + "px", n.style.height = i.height + "px"
            }, n.lookAt = function (e, t, i, n) {
                n = void 0 === n || n, t = o.isArray(t) ? t : [t], i = i || {
                    x: 0,
                    y: 0
                };
                for (var r = {
                        min: {
                            x: 1 / 0,
                            y: 1 / 0
                        },
                        max: {
                            x: -1 / 0,
                            y: -1 / 0
                        }
                    }, s = 0; s < t.length; s += 1) {
                    var a = t[s],
                        l = a.bounds ? a.bounds.min : a.min || a.position || a,
                        c = a.bounds ? a.bounds.max : a.max || a.position || a;
                    l && c && (l.x < r.min.x && (r.min.x = l.x), c.x > r.max.x && (r.max.x = c.x), l.y < r.min.y && (r.min.y = l.y), c.y > r.max.y && (r.max.y = c.y))
                }
                var h = r.max.x - r.min.x + 2 * i.x,
                    d = r.max.y - r.min.y + 2 * i.y,
                    p = e.canvas.height,
                    f = e.canvas.width / p,
                    m = h / d,
                    g = 1,
                    v = 1;
                m > f ? v = m / f : g = f / m, e.options.hasBounds = !0, e.bounds.min.x = r.min.x, e.bounds.max.x = r.min.x + h * g, e.bounds.min.y = r.min.y, e.bounds.max.y = r.min.y + d * v, n && (e.bounds.min.x += .5 * h - h * g * .5, e.bounds.max.x += .5 * h - h * g * .5, e.bounds.min.y += .5 * d - d * v * .5, e.bounds.max.y += .5 * d - d * v * .5), e.bounds.min.x -= i.x, e.bounds.max.x -= i.x, e.bounds.min.y -= i.y, e.bounds.max.y -= i.y, e.mouse && (u.setScale(e.mouse, {
                    x: (e.bounds.max.x - e.bounds.min.x) / e.canvas.width,
                    y: (e.bounds.max.y - e.bounds.min.y) / e.canvas.height
                }), u.setOffset(e.mouse, e.bounds.min))
            }, n.startViewTransform = function (e) {
                var t = e.bounds.max.x - e.bounds.min.x,
                    i = e.bounds.max.y - e.bounds.min.y,
                    n = t / e.options.width,
                    r = i / e.options.height;
                e.context.setTransform(e.options.pixelRatio / n, 0, 0, e.options.pixelRatio / r, 0, 0), e.context.translate(-e.bounds.min.x, -e.bounds.min.y)
            }, n.endViewTransform = function (e) {
                e.context.setTransform(e.options.pixelRatio, 0, 0, e.options.pixelRatio, 0, 0)
            }, n.world = function (e, t) {
                var i, r = o.now(),
                    h = e.engine,
                    d = h.world,
                    p = e.canvas,
                    f = e.context,
                    g = e.options,
                    v = e.timing,
                    y = s.allBodies(d),
                    b = s.allConstraints(d),
                    x = g.wireframes ? g.wireframeBackground : g.background,
                    w = [],
                    _ = [],
                    E = {
                        timestamp: h.timing.timestamp
                    };
                if (l.trigger(e, "beforeRender", E), e.currentBackground !== x && m(e, x), f.globalCompositeOperation = "source-in", f.fillStyle = "transparent", f.fillRect(0, 0, p.width, p.height), f.globalCompositeOperation = "source-over", g.hasBounds) {
                    for (i = 0; i < y.length; i++) {
                        var M = y[i];
                        a.overlaps(M.bounds, e.bounds) && w.push(M)
                    }
                    for (i = 0; i < b.length; i++) {
                        var S = b[i],
                            T = S.bodyA,
                            A = S.bodyB,
                            C = S.pointA,
                            L = S.pointB;
                        T && (C = c.add(T.position, S.pointA)), A && (L = c.add(A.position, S.pointB)), C && L && (a.contains(e.bounds, C) || a.contains(e.bounds, L)) && _.push(S)
                    }
                    n.startViewTransform(e), e.mouse && (u.setScale(e.mouse, {
                        x: (e.bounds.max.x - e.bounds.min.x) / e.options.width,
                        y: (e.bounds.max.y - e.bounds.min.y) / e.options.height
                    }), u.setOffset(e.mouse, e.bounds.min))
                } else _ = b, w = y, 1 !== e.options.pixelRatio && e.context.setTransform(e.options.pixelRatio, 0, 0, e.options.pixelRatio, 0, 0);
                !g.wireframes || h.enableSleeping && g.showSleeping ? n.bodies(e, w, f) : (g.showConvexHulls && n.bodyConvexHulls(e, w, f), n.bodyWireframes(e, w, f)), g.showBounds && n.bodyBounds(e, w, f), (g.showAxes || g.showAngleIndicator) && n.bodyAxes(e, w, f), g.showPositions && n.bodyPositions(e, w, f), g.showVelocity && n.bodyVelocity(e, w, f), g.showIds && n.bodyIds(e, w, f), g.showSeparations && n.separations(e, h.pairs.list, f), g.showCollisions && n.collisions(e, h.pairs.list, f), g.showVertexNumbers && n.vertexNumbers(e, w, f), g.showMousePosition && n.mousePosition(e, e.mouse, f), n.constraints(_, f), g.hasBounds && n.endViewTransform(e), l.trigger(e, "afterRender", E), v.lastElapsed = o.now() - r
            }, n.stats = function (e, t, i) {
                for (var n = e.engine, r = n.world, o = s.allBodies(r), a = 0, l = 0, c = 0; c < o.length; c += 1) a += o[c].parts.length;
                var u = {
                    Part: a,
                    Body: o.length,
                    Cons: s.allConstraints(r).length,
                    Comp: s.allComposites(r).length,
                    Pair: n.pairs.list.length
                };
                for (var h in t.fillStyle = "#0e0f19", t.fillRect(l, 0, 302.5, 44), t.font = "12px Arial", t.textBaseline = "top", t.textAlign = "right", u) {
                    var d = u[h];
                    t.fillStyle = "#aaa", t.fillText(h, l + 55, 8), t.fillStyle = "#eee", t.fillText(d, l + 55, 26), l += 55
                }
            }, n.performance = function (e, t) {
                var i = e.engine,
                    r = e.timing,
                    o = r.deltaHistory,
                    s = r.elapsedHistory,
                    a = r.timestampElapsedHistory,
                    l = r.engineDeltaHistory,
                    c = r.engineElapsedHistory,
                    u = i.timing.lastDelta,
                    d = h(o),
                    p = h(s),
                    f = h(l),
                    m = h(c),
                    g = h(a) / d || 0,
                    v = 1e3 / d || 0;
                t.fillStyle = "#0e0f19", t.fillRect(0, 50, 370, 34), n.status(t, 10, 69, 60, 4, o.length, Math.round(v) + " fps", v / n._goodFps, (function (e) {
                    return o[e] / d - 1
                })), n.status(t, 82, 69, 60, 4, l.length, u.toFixed(2) + " dt", n._goodDelta / u, (function (e) {
                    return l[e] / f - 1
                })), n.status(t, 154, 69, 60, 4, c.length, m.toFixed(2) + " ut", 1 - m / n._goodFps, (function (e) {
                    return c[e] / m - 1
                })), n.status(t, 226, 69, 60, 4, s.length, p.toFixed(2) + " rt", 1 - p / n._goodFps, (function (e) {
                    return s[e] / p - 1
                })), n.status(t, 298, 69, 60, 4, a.length, g.toFixed(2) + " x", g * g * g, (function (e) {
                    return (a[e] / o[e] / g || 0) - 1
                }))
            }, n.status = function (e, t, i, n, r, s, a, l, c) {
                e.strokeStyle = "#888", e.fillStyle = "#444", e.lineWidth = 1, e.fillRect(t, i + 7, n, 1), e.beginPath(), e.moveTo(t, i + 7 - r * o.clamp(.4 * c(0), -2, 2));
                for (var u = 0; u < n; u += 1) e.lineTo(t + u, i + 7 - (u < s ? r * o.clamp(.4 * c(u), -2, 2) : 0));
                e.stroke(), e.fillStyle = "hsl(" + o.clamp(25 + 95 * l, 0, 120) + ",100%,60%)", e.fillRect(t, i - 7, 4, 4), e.font = "12px Arial", e.textBaseline = "middle", e.textAlign = "right", e.fillStyle = "#eee", e.fillText(a, t + n, i - 5)
            }, n.constraints = function (e, t) {
                for (var i = t, n = 0; n < e.length; n++) {
                    var r = e[n];
                    if (r.render.visible && r.pointA && r.pointB) {
                        var s, a, l = r.bodyA,
                            u = r.bodyB;
                        if (s = l ? c.add(l.position, r.pointA) : r.pointA, "pin" === r.render.type) i.beginPath(), i.arc(s.x, s.y, 3, 0, 2 * Math.PI), i.closePath();
                        else {
                            if (a = u ? c.add(u.position, r.pointB) : r.pointB, i.beginPath(), i.moveTo(s.x, s.y), "spring" === r.render.type)
                                for (var h, d = c.sub(a, s), p = c.perp(c.normalise(d)), f = Math.ceil(o.clamp(r.length / 5, 12, 20)), m = 1; m < f; m += 1) h = m % 2 == 0 ? 1 : -1, i.lineTo(s.x + d.x * (m / f) + p.x * h * 4, s.y + d.y * (m / f) + p.y * h * 4);
                            i.lineTo(a.x, a.y)
                        }
                        r.render.lineWidth && (i.lineWidth = r.render.lineWidth, i.strokeStyle = r.render.strokeStyle, i.stroke()), r.render.anchors && (i.fillStyle = r.render.strokeStyle, i.beginPath(), i.arc(s.x, s.y, 3, 0, 2 * Math.PI), i.arc(a.x, a.y, 3, 0, 2 * Math.PI), i.closePath(), i.fill())
                    }
                }
            }, n.bodies = function (e, t, i) {
                var n, r, o, s, a = i,
                    l = (e.engine, e.options),
                    c = l.showInternalEdges || !l.wireframes;
                for (o = 0; o < t.length; o++)
                    if ((n = t[o]).render.visible)
                        for (s = n.parts.length > 1 ? 1 : 0; s < n.parts.length; s++)
                            if ((r = n.parts[s]).render.visible) {
                                if (l.showSleeping && n.isSleeping ? a.globalAlpha = .5 * r.render.opacity : 1 !== r.render.opacity && (a.globalAlpha = r.render.opacity), r.render.sprite && r.render.sprite.texture && !l.wireframes) {
                                    var u = r.render.sprite,
                                        h = f(e, u.texture);
                                    a.translate(r.position.x, r.position.y), a.rotate(r.angle), a.drawImage(h, h.width * -u.xOffset * u.xScale, h.height * -u.yOffset * u.yScale, h.width * u.xScale, h.height * u.yScale), a.rotate(-r.angle), a.translate(-r.position.x, -r.position.y)
                                } else {
                                    if (r.circleRadius) a.beginPath(), a.arc(r.position.x, r.position.y, r.circleRadius, 0, 2 * Math.PI);
                                    else {
                                        a.beginPath(), a.moveTo(r.vertices[0].x, r.vertices[0].y);
                                        for (var d = 1; d < r.vertices.length; d++) !r.vertices[d - 1].isInternal || c ? a.lineTo(r.vertices[d].x, r.vertices[d].y) : a.moveTo(r.vertices[d].x, r.vertices[d].y), r.vertices[d].isInternal && !c && a.moveTo(r.vertices[(d + 1) % r.vertices.length].x, r.vertices[(d + 1) % r.vertices.length].y);
                                        a.lineTo(r.vertices[0].x, r.vertices[0].y), a.closePath()
                                    }
                                    l.wireframes ? (a.lineWidth = 1, a.strokeStyle = "#bbb", a.stroke()) : (a.fillStyle = r.render.fillStyle, r.render.lineWidth && (a.lineWidth = r.render.lineWidth, a.strokeStyle = r.render.strokeStyle, a.stroke()), a.fill())
                                }
                                a.globalAlpha = 1
                            }
            }, n.bodyWireframes = function (e, t, i) {
                var n, r, o, s, a, l = i,
                    c = e.options.showInternalEdges;
                for (l.beginPath(), o = 0; o < t.length; o++)
                    if ((n = t[o]).render.visible)
                        for (a = n.parts.length > 1 ? 1 : 0; a < n.parts.length; a++) {
                            for (r = n.parts[a], l.moveTo(r.vertices[0].x, r.vertices[0].y), s = 1; s < r.vertices.length; s++) !r.vertices[s - 1].isInternal || c ? l.lineTo(r.vertices[s].x, r.vertices[s].y) : l.moveTo(r.vertices[s].x, r.vertices[s].y), r.vertices[s].isInternal && !c && l.moveTo(r.vertices[(s + 1) % r.vertices.length].x, r.vertices[(s + 1) % r.vertices.length].y);
                            l.lineTo(r.vertices[0].x, r.vertices[0].y)
                        }
                l.lineWidth = 1, l.strokeStyle = "#bbb", l.stroke()
            }, n.bodyConvexHulls = function (e, t, i) {
                var n, r, o, s = i;
                for (s.beginPath(), r = 0; r < t.length; r++)
                    if ((n = t[r]).render.visible && 1 !== n.parts.length) {
                        for (s.moveTo(n.vertices[0].x, n.vertices[0].y), o = 1; o < n.vertices.length; o++) s.lineTo(n.vertices[o].x, n.vertices[o].y);
                        s.lineTo(n.vertices[0].x, n.vertices[0].y)
                    } s.lineWidth = 1, s.strokeStyle = "rgba(255,255,255,0.2)", s.stroke()
            }, n.vertexNumbers = function (e, t, i) {
                var n, r, o, s = i;
                for (n = 0; n < t.length; n++) {
                    var a = t[n].parts;
                    for (o = a.length > 1 ? 1 : 0; o < a.length; o++) {
                        var l = a[o];
                        for (r = 0; r < l.vertices.length; r++) s.fillStyle = "rgba(255,255,255,0.2)", s.fillText(n + "_" + r, l.position.x + .8 * (l.vertices[r].x - l.position.x), l.position.y + .8 * (l.vertices[r].y - l.position.y))
                    }
                }
            }, n.mousePosition = function (e, t, i) {
                var n = i;
                n.fillStyle = "rgba(255,255,255,0.8)", n.fillText(t.position.x + "  " + t.position.y, t.position.x + 5, t.position.y - 5)
            }, n.bodyBounds = function (e, t, i) {
                var n = i,
                    r = (e.engine, e.options);
                n.beginPath();
                for (var o = 0; o < t.length; o++)
                    if (t[o].render.visible)
                        for (var s = t[o].parts, a = s.length > 1 ? 1 : 0; a < s.length; a++) {
                            var l = s[a];
                            n.rect(l.bounds.min.x, l.bounds.min.y, l.bounds.max.x - l.bounds.min.x, l.bounds.max.y - l.bounds.min.y)
                        }
                r.wireframes ? n.strokeStyle = "rgba(255,255,255,0.08)" : n.strokeStyle = "rgba(0,0,0,0.1)", n.lineWidth = 1, n.stroke()
            }, n.bodyAxes = function (e, t, i) {
                var n, r, o, s, a = i,
                    l = (e.engine, e.options);
                for (a.beginPath(), r = 0; r < t.length; r++) {
                    var c = t[r],
                        u = c.parts;
                    if (c.render.visible)
                        if (l.showAxes)
                            for (o = u.length > 1 ? 1 : 0; o < u.length; o++)
                                for (n = u[o], s = 0; s < n.axes.length; s++) {
                                    var h = n.axes[s];
                                    a.moveTo(n.position.x, n.position.y), a.lineTo(n.position.x + 20 * h.x, n.position.y + 20 * h.y)
                                } else
                                    for (o = u.length > 1 ? 1 : 0; o < u.length; o++)
                                        for (n = u[o], s = 0; s < n.axes.length; s++) a.moveTo(n.position.x, n.position.y), a.lineTo((n.vertices[0].x + n.vertices[n.vertices.length - 1].x) / 2, (n.vertices[0].y + n.vertices[n.vertices.length - 1].y) / 2)
                }
                l.wireframes ? (a.strokeStyle = "indianred", a.lineWidth = 1) : (a.strokeStyle = "rgba(255, 255, 255, 0.4)", a.globalCompositeOperation = "overlay", a.lineWidth = 2), a.stroke(), a.globalCompositeOperation = "source-over"
            }, n.bodyPositions = function (e, t, i) {
                var n, r, o, s, a = i,
                    l = (e.engine, e.options);
                for (a.beginPath(), o = 0; o < t.length; o++)
                    if ((n = t[o]).render.visible)
                        for (s = 0; s < n.parts.length; s++) r = n.parts[s], a.arc(r.position.x, r.position.y, 3, 0, 2 * Math.PI, !1), a.closePath();
                for (l.wireframes ? a.fillStyle = "indianred" : a.fillStyle = "rgba(0,0,0,0.5)", a.fill(), a.beginPath(), o = 0; o < t.length; o++)(n = t[o]).render.visible && (a.arc(n.positionPrev.x, n.positionPrev.y, 2, 0, 2 * Math.PI, !1), a.closePath());
                a.fillStyle = "rgba(255,165,0,0.8)", a.fill()
            }, n.bodyVelocity = function (e, t, i) {
                var n = i;
                n.beginPath();
                for (var o = 0; o < t.length; o++) {
                    var s = t[o];
                    if (s.render.visible) {
                        var a = r.getVelocity(s);
                        n.moveTo(s.position.x, s.position.y), n.lineTo(s.position.x + a.x, s.position.y + a.y)
                    }
                }
                n.lineWidth = 3, n.strokeStyle = "cornflowerblue", n.stroke()
            }, n.bodyIds = function (e, t, i) {
                var n, r, o = i;
                for (n = 0; n < t.length; n++)
                    if (t[n].render.visible) {
                        var s = t[n].parts;
                        for (r = s.length > 1 ? 1 : 0; r < s.length; r++) {
                            var a = s[r];
                            o.font = "12px Arial", o.fillStyle = "rgba(255,255,255,0.5)", o.fillText(a.id, a.position.x + 10, a.position.y - 10)
                        }
                    }
            }, n.collisions = function (e, t, i) {
                var n, r, o, s, a = i,
                    l = e.options;
                for (a.beginPath(), o = 0; o < t.length; o++)
                    if ((n = t[o]).isActive)
                        for (r = n.collision, s = 0; s < n.activeContacts.length; s++) {
                            var c = n.activeContacts[s].vertex;
                            a.rect(c.x - 1.5, c.y - 1.5, 3.5, 3.5)
                        }
                for (l.wireframes ? a.fillStyle = "rgba(255,255,255,0.7)" : a.fillStyle = "orange", a.fill(), a.beginPath(), o = 0; o < t.length; o++)
                    if ((n = t[o]).isActive && (r = n.collision, n.activeContacts.length > 0)) {
                        var u = n.activeContacts[0].vertex.x,
                            h = n.activeContacts[0].vertex.y;
                        2 === n.activeContacts.length && (u = (n.activeContacts[0].vertex.x + n.activeContacts[1].vertex.x) / 2, h = (n.activeContacts[0].vertex.y + n.activeContacts[1].vertex.y) / 2), r.bodyB === r.supports[0].body || !0 === r.bodyA.isStatic ? a.moveTo(u - 8 * r.normal.x, h - 8 * r.normal.y) : a.moveTo(u + 8 * r.normal.x, h + 8 * r.normal.y), a.lineTo(u, h)
                    } l.wireframes ? a.strokeStyle = "rgba(255,165,0,0.7)" : a.strokeStyle = "orange", a.lineWidth = 1, a.stroke()
            }, n.separations = function (e, t, i) {
                var n, r, o, s, a, l = i,
                    c = e.options;
                for (l.beginPath(), a = 0; a < t.length; a++)
                    if ((n = t[a]).isActive) {
                        o = (r = n.collision).bodyA;
                        var u = 1;
                        (s = r.bodyB).isStatic || o.isStatic || (u = .5), s.isStatic && (u = 0), l.moveTo(s.position.x, s.position.y), l.lineTo(s.position.x - r.penetration.x * u, s.position.y - r.penetration.y * u), u = 1, s.isStatic || o.isStatic || (u = .5), o.isStatic && (u = 0), l.moveTo(o.position.x, o.position.y), l.lineTo(o.position.x + r.penetration.x * u, o.position.y + r.penetration.y * u)
                    } c.wireframes ? l.strokeStyle = "rgba(255,165,0,0.5)" : l.strokeStyle = "orange", l.stroke()
            }, n.inspector = function (e, t) {
                e.engine;
                var i, n = e.selected,
                    r = e.render,
                    o = r.options;
                if (o.hasBounds) {
                    var s = r.bounds.max.x - r.bounds.min.x,
                        a = r.bounds.max.y - r.bounds.min.y,
                        l = s / r.options.width,
                        c = a / r.options.height;
                    t.scale(1 / l, 1 / c), t.translate(-r.bounds.min.x, -r.bounds.min.y)
                }
                for (var u = 0; u < n.length; u++) {
                    var h = n[u].data;
                    switch (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = "rgba(255,165,0,0.9)", t.setLineDash([1, 2]), h.type) {
                        case "body":
                            i = h.bounds, t.beginPath(), t.rect(Math.floor(i.min.x - 3), Math.floor(i.min.y - 3), Math.floor(i.max.x - i.min.x + 6), Math.floor(i.max.y - i.min.y + 6)), t.closePath(), t.stroke();
                            break;
                        case "constraint":
                            var d = h.pointA;
                            h.bodyA && (d = h.pointB), t.beginPath(), t.arc(d.x, d.y, 10, 0, 2 * Math.PI), t.closePath(), t.stroke()
                    }
                    t.setLineDash([]), t.translate(-.5, -.5)
                }
                null !== e.selectStart && (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = "rgba(255,165,0,0.6)", t.fillStyle = "rgba(255,165,0,0.1)", i = e.selectBounds, t.beginPath(), t.rect(Math.floor(i.min.x), Math.floor(i.min.y), Math.floor(i.max.x - i.min.x), Math.floor(i.max.y - i.min.y)), t.closePath(), t.stroke(), t.fill(), t.translate(-.5, -.5)), o.hasBounds && t.setTransform(1, 0, 0, 1, 0, 0)
            };
            var i = function (e, t) {
                    var i = e.engine,
                        r = e.timing,
                        o = r.historySize,
                        s = i.timing.timestamp;
                    r.delta = t - r.lastTime || n._goodDelta, r.lastTime = t, r.timestampElapsed = s - r.lastTimestamp || 0, r.lastTimestamp = s, r.deltaHistory.unshift(r.delta), r.deltaHistory.length = Math.min(r.deltaHistory.length, o), r.engineDeltaHistory.unshift(i.timing.lastDelta), r.engineDeltaHistory.length = Math.min(r.engineDeltaHistory.length, o), r.timestampElapsedHistory.unshift(r.timestampElapsed), r.timestampElapsedHistory.length = Math.min(r.timestampElapsedHistory.length, o), r.engineElapsedHistory.unshift(i.timing.lastElapsed), r.engineElapsedHistory.length = Math.min(r.engineElapsedHistory.length, o), r.elapsedHistory.unshift(r.lastElapsed), r.elapsedHistory.length = Math.min(r.elapsedHistory.length, o)
                },
                h = function (e) {
                    for (var t = 0, i = 0; i < e.length; i += 1) t += e[i];
                    return t / e.length || 0
                },
                d = function (e, t) {
                    var i = document.createElement("canvas");
                    return i.width = e, i.height = t, i.oncontextmenu = function () {
                        return !1
                    }, i.onselectstart = function () {
                        return !1
                    }, i
                },
                p = function (e) {
                    var t = e.getContext("2d");
                    return (window.devicePixelRatio || 1) / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1)
                },
                f = function (e, t) {
                    var i = e.textures[t];
                    return i || ((i = e.textures[t] = new Image).src = t, i)
                },
                m = function (e, t) {
                    var i = t;
                    /(jpg|gif|png)$/.test(t) && (i = "url(" + t + ")"), e.canvas.style.background = i, e.canvas.style.backgroundSize = "contain", e.currentBackground = t
                }
        }()
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(5),
            o = i(17),
            s = i(0);
        ! function () {
            var e, t, i;
            "undefined" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), e || (e = function (e) {
                i = setTimeout((function () {
                    e(s.now())
                }), 1e3 / 60)
            }, t = function () {
                clearTimeout(i)
            }), n.create = function (e) {
                var t = s.extend({
                    fps: 60,
                    deltaSampleSize: 60,
                    counterTimestamp: 0,
                    frameCounter: 0,
                    deltaHistory: [],
                    timePrev: null,
                    frameRequestId: null,
                    isFixed: !1,
                    enabled: !0
                }, e);
                return t.delta = t.delta || 1e3 / t.fps, t.deltaMin = t.deltaMin || 1e3 / t.fps, t.deltaMax = t.deltaMax || 1e3 / (.5 * t.fps), t.fps = 1e3 / t.delta, t
            }, n.run = function (t, i) {
                return void 0 !== t.positionIterations && (i = t, t = n.create()),
                    function r(o) {
                        t.frameRequestId = e(r), o && t.enabled && n.tick(t, i, o)
                    }(), t
            }, n.tick = function (e, t, i) {
                var n, s = t.timing;
                e.isFixed ? n = e.delta : (n = i - e.timePrev || e.delta, e.timePrev = i, e.deltaHistory.push(n), e.deltaHistory = e.deltaHistory.slice(-e.deltaSampleSize), n = (n = (n = Math.min.apply(null, e.deltaHistory)) < e.deltaMin ? e.deltaMin : n) > e.deltaMax ? e.deltaMax : n, e.delta = n);
                var a = {
                    timestamp: s.timestamp
                };
                r.trigger(e, "beforeTick", a), e.frameCounter += 1, i - e.counterTimestamp >= 1e3 && (e.fps = e.frameCounter * ((i - e.counterTimestamp) / 1e3), e.counterTimestamp = i, e.frameCounter = 0), r.trigger(e, "tick", a), r.trigger(e, "beforeUpdate", a), o.update(t, n), r.trigger(e, "afterUpdate", a), r.trigger(e, "afterTick", a)
            }, n.stop = function (e) {
                t(e.frameRequestId)
            }, n.start = function (e, t) {
                n.run(e, t)
            }
        }()
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(8),
            o = i(0).deprecated;
        n.collides = function (e, t) {
            return r.collides(e, t)
        }, o(n, "collides", "SAT.collides  replaced by Collision.collides")
    }, function (e, t, i) {
        var n = {};
        e.exports = n, i(1);
        var r = i(0);
        n.pathToVertices = function (e, t) {
            "undefined" == typeof window || "SVGPathSeg" in window || r.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
            var i, o, s, a, l, c, u, h, d, p, f, m = [],
                g = 0,
                v = 0,
                y = 0;
            t = t || 15;
            var b = function (e, t, i) {
                    var n = i % 2 == 1 && i > 1;
                    if (!d || e != d.x || t != d.y) {
                        d && n ? (p = d.x, f = d.y) : (p = 0, f = 0);
                        var r = {
                            x: p + e,
                            y: f + t
                        };
                        !n && d || (d = r), m.push(r), v = p + e, y = f + t
                    }
                },
                x = function (e) {
                    var t = e.pathSegTypeAsLetter.toUpperCase();
                    if ("Z" !== t) {
                        switch (t) {
                            case "M":
                            case "L":
                            case "T":
                            case "C":
                            case "S":
                            case "Q":
                                v = e.x, y = e.y;
                                break;
                            case "H":
                                v = e.x;
                                break;
                            case "V":
                                y = e.y
                        }
                        b(v, y, e.pathSegType)
                    }
                };
            for (n._svgPathToAbsolute(e), s = e.getTotalLength(), c = [], i = 0; i < e.pathSegList.numberOfItems; i += 1) c.push(e.pathSegList.getItem(i));
            for (u = c.concat(); g < s;) {
                if ((l = c[e.getPathSegAtLength(g)]) != h) {
                    for (; u.length && u[0] != l;) x(u.shift());
                    h = l
                }
                switch (l.pathSegTypeAsLetter.toUpperCase()) {
                    case "C":
                    case "T":
                    case "S":
                    case "Q":
                    case "A":
                        a = e.getPointAtLength(g), b(a.x, a.y, 0)
                }
                g += t
            }
            for (i = 0, o = u.length; i < o; ++i) x(u[i]);
            return m
        }, n._svgPathToAbsolute = function (e) {
            for (var t, i, n, r, o, s, a = e.pathSegList, l = 0, c = 0, u = a.numberOfItems, h = 0; h < u; ++h) {
                var d = a.getItem(h),
                    p = d.pathSegTypeAsLetter;
                if (/[MLHVCSQTA]/.test(p)) "x" in d && (l = d.x), "y" in d && (c = d.y);
                else switch ("x1" in d && (n = l + d.x1), "x2" in d && (o = l + d.x2), "y1" in d && (r = c + d.y1), "y2" in d && (s = c + d.y2), "x" in d && (l += d.x), "y" in d && (c += d.y), p) {
                    case "m":
                        a.replaceItem(e.createSVGPathSegMovetoAbs(l, c), h);
                        break;
                    case "l":
                        a.replaceItem(e.createSVGPathSegLinetoAbs(l, c), h);
                        break;
                    case "h":
                        a.replaceItem(e.createSVGPathSegLinetoHorizontalAbs(l), h);
                        break;
                    case "v":
                        a.replaceItem(e.createSVGPathSegLinetoVerticalAbs(c), h);
                        break;
                    case "c":
                        a.replaceItem(e.createSVGPathSegCurvetoCubicAbs(l, c, n, r, o, s), h);
                        break;
                    case "s":
                        a.replaceItem(e.createSVGPathSegCurvetoCubicSmoothAbs(l, c, o, s), h);
                        break;
                    case "q":
                        a.replaceItem(e.createSVGPathSegCurvetoQuadraticAbs(l, c, n, r), h);
                        break;
                    case "t":
                        a.replaceItem(e.createSVGPathSegCurvetoQuadraticSmoothAbs(l, c), h);
                        break;
                    case "a":
                        a.replaceItem(e.createSVGPathSegArcAbs(l, c, d.r1, d.r2, d.angle, d.largeArcFlag, d.sweepFlag), h);
                        break;
                    case "z":
                    case "Z":
                        l = t, c = i
                }
                "M" != p && "m" != p || (t = l, i = c)
            }
        }
    }, function (e, t, i) {
        var n = {};
        e.exports = n;
        var r = i(6);
        i(0), n.create = r.create, n.add = r.add, n.remove = r.remove, n.clear = r.clear, n.addComposite = r.addComposite, n.addBody = r.addBody, n.addConstraint = r.addConstraint
    }])
}));
var tagsContainer = $(".tags-container");
if (tagsContainer.length) {
    function initSimulation() {
        var e = Matter.Engine,
            t = Matter.Render,
            n = Matter.Events,
            r = Matter.MouseConstraint,
            o = Matter.Mouse,
            s = Matter.World,
            a = Matter.Bodies,
            l = e.create(),
            c = l.world,
            u = document.querySelector(".tags-container"),
            h = u.clientWidth,
            d = u.clientHeight,
            p = t.create({
                element: u,
                engine: l,
                options: {
                    width: h,
                    height: d,
                    pixelRatio: 2,
                    background: "transparent",
                    wireframes: !1
                }
            }),
            f = a.rectangle(h / 2 + 160, d + 80, h + 320, 160, {
                render: {
                    fillStyle: "#fff"
                },
                isStatic: !0
            }),
            m = a.rectangle(-80, d / 2, 160, d, {
                isStatic: !0
            }),
            g = a.rectangle(h + 80, d / 2, 160, 1200, {
                isStatic: !0
            }),
            v = a.rectangle(h / 2 + 160, -80, h + 320, 160, {
                isStatic: !0
            }),
            y = a.rectangle(h / 2 + 150, 200, 164, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_1.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            b = a.rectangle(h / 2 - 150, 160, 122, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_2.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            x = a.rectangle(h / 2 + 250, 120, 104, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_3.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            w = a.rectangle(h / 2 - 75, 180, 105, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_4.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            _ = a.rectangle(h / 2 - 74, 141, 194, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_5.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            E = a.rectangle(h / 2 + 174, 190, 116, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_6.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            M = a.rectangle(h / 2 - 142, 144, 167, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_7.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            S = a.rectangle(h / 2 - 10, 169, 139, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_8.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            T = a.rectangle(h / 2 - 242, 122, 174, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_9.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            A = a.rectangle(h / 2 + 60, 100, 185, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_10.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            C = a.rectangle(h / 2, 127, 170, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_11.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            L = a.rectangle(h / 2 - 59, 168, 60, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_12.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            P = a.rectangle(h / 2 + 110, 159, 110, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_13.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            I = a.rectangle(h / 2 - 110, 196, 101, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_14.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            O = a.rectangle(h / 2 - 10, 129, 101, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_15.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            R = a.rectangle(h / 2 - 80, 170, 101, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_16.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            D = a.rectangle(h / 2 - 110, 196, 101, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_17.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            k = a.rectangle(h / 2 + 90, 164, 101, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_18.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            }),
            z = a.rectangle(h / 2 + 80, 130, 191, 56, {
                chamfer: {
                    radius: 20
                },
                render: {
                    sprite: {
                        texture: "./assets/img/shape/elements_1_19.svg",
                        xScale: 1,
                        yScale: 1
                    }
                }
            });
        s.add(l.world, [f, m, g, v, y, b, x, w, _, E, M, S, T, A, C, L, P, I, O, R, D, k, z]);
        var B = o.create(p.canvas),
            N = r.create(l, {
                mouse: B,
                constraint: {
                    stiffness: .2,
                    render: {
                        visible: !1
                    }
                }
            });
        s.add(c, N), p.mouse = B, B.element.removeEventListener("mousewheel", B.mousewheel), B.element.removeEventListener("DOMMouseScroll", B.mousewheel);
        let F = !1;
        document.addEventListener("mousedown", () => F = !0), document.addEventListener("mousemove", () => F = !1), n.on(N, "mouseup", (function (e) {
            var t = e.source,
                n = l.world.bodies;
            if (!t.bodyB)
                for (i = 0; i < n.length; i++) {
                    var r = n[i];
                    if (!0 === F && Matter.Bounds.contains(r.bounds, t.mouse.position)) {
                        var o = r.url;
                        null != o && window.open(o, "_blank");
                        break
                    }
                }
        })), e.run(l), t.run(p)
    }
    var containerElement = document.querySelector(".tags-container"),
        observer = new IntersectionObserver((e, t) => {
            e.forEach(e => {
                e.isIntersecting && (initSimulation(), t.disconnect())
            })
        }, {});
    observer.observe(containerElement)
}! function (e) {
    e.fn.niceSelect = function (t) {
        function i(t) {
            t.after(e("<div></div>").addClass("nice-select").addClass(t.attr("class") || "").addClass(t.attr("disabled") ? "disabled" : "").attr("tabindex", t.attr("disabled") ? null : "0").html('<span class="current"></span><ul class="list"></ul>'));
            var i = t.next(),
                n = t.find("option"),
                r = t.find("option:selected");
            i.find(".current").html(r.data("display") || r.text()), n.each((function (t) {
                var n = e(this),
                    r = n.data("display");
                i.find("ul").append(e("<li></li>").attr("data-value", n.val()).attr("data-display", r || null).addClass("option" + (n.is(":selected") ? " selected" : "") + (n.is(":disabled") ? " disabled" : "")).html(n.text()))
            }))
        }
        if ("string" == typeof t) return "update" == t ? this.each((function () {
            var t = e(this),
                n = e(this).next(".nice-select"),
                r = n.hasClass("open");
            n.length && (n.remove(), i(t), r && t.next().trigger("click"))
        })) : "destroy" == t ? (this.each((function () {
            var t = e(this),
                i = e(this).next(".nice-select");
            i.length && (i.remove(), t.css("display", ""))
        })), 0 == e(".nice-select").length && e(document).off(".nice_select")) : console.log('Method "' + t + '" does not exist.'), this;
        this.hide(), this.each((function () {
            var t = e(this);
            t.next().hasClass("nice-select") || i(t)
        })), e(document).off(".nice_select"), e(document).on("click.nice_select", ".nice-select", (function (t) {
            var i = e(this);
            e(".nice-select").not(i).removeClass("open"), i.toggleClass("open"), i.hasClass("open") ? (i.find(".option"), i.find(".focus").removeClass("focus"), i.find(".selected").addClass("focus")) : i.focus()
        })), e(document).on("click.nice_select", (function (t) {
            0 === e(t.target).closest(".nice-select").length && e(".nice-select").removeClass("open").find(".option")
        })), e(document).on("click.nice_select", ".nice-select .option:not(.disabled)", (function (t) {
            var i = e(this),
                n = i.closest(".nice-select");
            n.find(".selected").removeClass("selected"), i.addClass("selected");
            var r = i.data("display") || i.text();
            n.find(".current").text(r), n.prev("select").val(i.data("value")).trigger("change")
        })), e(document).on("keydown.nice_select", ".nice-select", (function (t) {
            var i = e(this),
                n = e(i.find(".focus") || i.find(".list .option.selected"));
            if (32 == t.keyCode || 13 == t.keyCode) return i.hasClass("open") ? n.trigger("click") : i.trigger("click"), !1;
            if (40 == t.keyCode) {
                if (i.hasClass("open")) {
                    var r = n.nextAll(".option:not(.disabled)").first();
                    r.length > 0 && (i.find(".focus").removeClass("focus"), r.addClass("focus"))
                } else i.trigger("click");
                return !1
            }
            if (38 == t.keyCode) {
                if (i.hasClass("open")) {
                    var o = n.prevAll(".option:not(.disabled)").first();
                    o.length > 0 && (i.find(".focus").removeClass("focus"), o.addClass("focus"))
                } else i.trigger("click");
                return !1
            }
            if (27 == t.keyCode) i.hasClass("open") && i.trigger("click");
            else if (9 == t.keyCode && i.hasClass("open")) return !1
        }));
        var n = document.createElement("a").style;
        return n.cssText = "pointer-events:auto", "auto" !== n.pointerEvents && e("html").addClass("no-csspointerevents"), this
    }
}(jQuery),
function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports, require("three")) : "function" == typeof define && define.amd ? define(["exports", "three"], t) : t((e = e || self).PANOLENS = {}, e.THREE)
}(this, (function (e, t) {
    function i(e) {
        this.constraints = Object.assign({
            video: {
                width: {
                    ideal: 1920
                },
                height: {
                    ideal: 1080
                },
                facingMode: {
                    exact: "environment"
                }
            },
            audio: !1
        }, e), this.element = this.scene = this.container = null, this.devices = [], this.stream = null, this.ratioScalar = 1, this.videoDeviceIndex = 0
    }

    function n(e, i, n) {
        e = void 0 === e ? 16777215 : e, i = void 0 === i || i, n = void 0 === n ? 1500 : n, this.dpr = window.devicePixelRatio;
        var r = this.createCanvas(),
            o = r.canvas;
        r = r.context;
        var s = new t.SpriteMaterial({
            color: e,
            map: this.createCanvasTexture(o)
        });
        t.Sprite.call(this, s), this.canvasWidth = o.width, this.canvasHeight = o.height, this.context = r, this.color = e instanceof t.Color ? e : new t.Color(e), this.autoSelect = i, this.dwellTime = n, this.rippleDuration = 500, this.position.z = -10, this.center.set(.5, .5), this.scale.set(.5, .5, 1), this.callback = this.timerId = this.startTimestamp = null, this.frustumCulled = !1, this.updateCanvasArcByProgress(0)
    }

    function r(e, i, n) {
        e = void 0 === e ? 300 : e, i = i || M.Info, t.Sprite.call(this), this.type = "infospot", this.animated = void 0 === n || n, this.frustumCulled = this.isHovering = !1, this.cursorStyle = this.toPanorama = this.element = null, this.mode = E.NORMAL, this.scale.set(e, e, 1), this.rotation.y = Math.PI, this.container = null, this.originalRaycast = this.raycast, this.HANDLER_FOCUS = null, this.material.side = t.DoubleSide, this.material.depthTest = !1, this.material.transparent = !0, this.material.opacity = 0, this.scaleUpAnimation = new L.Tween, this.scaleDownAnimation = new L.Tween, n = function (i) {
            if (this.material) {
                var n = i.image.width / i.image.height,
                    r = new t.Vector3;
                i.image.width = i.image.naturalWidth || 64, i.image.height = i.image.naturalHeight || 64, this.scale.set(n * e, e, 1), r.copy(this.scale), this.scaleUpAnimation = new L.Tween(this.scale).to({
                    x: 1.3 * r.x,
                    y: 1.3 * r.y
                }, 500).easing(L.Easing.Elastic.Out), this.scaleDownAnimation = new L.Tween(this.scale).to({
                    x: r.x,
                    y: r.y
                }, 500).easing(L.Easing.Elastic.Out), this.material.map = i, this.material.needsUpdate = !0
            }
        }.bind(this), this.showAnimation = new L.Tween(this.material).to({
            opacity: 1
        }, 500).onStart(this.enableRaycast.bind(this, !0)).easing(L.Easing.Quartic.Out), this.hideAnimation = new L.Tween(this.material).to({
            opacity: 0
        }, 500).onStart(this.enableRaycast.bind(this, !1)).easing(L.Easing.Quartic.Out), this.addEventListener("click", this.onClick), this.addEventListener("hover", this.onHover), this.addEventListener("hoverenter", this.onHoverStart), this.addEventListener("hoverleave", this.onHoverEnd), this.addEventListener("panolens-dual-eye-effect", this.onDualEyeEffect), this.addEventListener("panolens-container", this.setContainer.bind(this)), this.addEventListener("dismiss", this.onDismiss), this.addEventListener("panolens-infospot-focus", this.setFocusMethod), T.load(i, n)
    }

    function o(e) {
        e || console.warn("PANOLENS.Widget: No container specified"), t.EventDispatcher.call(this), this.DEFAULT_TRANSITION = "all 0.27s ease", this.TOUCH_ENABLED = !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch), this.PREVENT_EVENT_HANDLER = function (e) {
            e.preventDefault(), e.stopPropagation()
        }, this.container = e, this.mask = this.activeSubMenu = this.activeMainItem = this.mainMenu = this.settingElement = this.videoElement = this.fullscreenElement = this.barElement = null
    }

    function s(e, i) {
        t.Mesh.call(this, e, i), this.type = "panorama", this.ImageQualityLow = 1, this.ImageQualityFair = 2, this.ImageQualityMedium = 3, this.ImageQualityHigh = 4, this.ImageQualitySuperHigh = 5, this.animationDuration = 1e3, this.defaultInfospotSize = 350, this.container = void 0, this.loaded = !1, this.linkedSpots = [], this.isInfospotVisible = !1, this.linkingImageScale = this.linkingImageURL = void 0, this.material.side = t.BackSide, this.material.opacity = 0, this.scale.x *= -1, this.renderOrder = -1, this.active = !1, this.infospotAnimation = new L.Tween(this).to({}, this.animationDuration / 2), this.addEventListener("load", this.fadeIn.bind(this)), this.addEventListener("panolens-container", this.setContainer.bind(this)), this.addEventListener("click", this.onClick.bind(this)), this.setupTransitions()
    }

    function a(e, i, n) {
        i = i || new t.SphereBufferGeometry(5e3, 60, 40), n = n || new t.MeshBasicMaterial({
            opacity: 0,
            transparent: !0
        }), s.call(this, i, n), this.src = e, this.radius = 5e3
    }

    function l() {
        var e = new t.BufferGeometry,
            i = new t.MeshBasicMaterial({
                color: 0,
                opacity: 0,
                transparent: !0
            });
        e.addAttribute("position", new t.BufferAttribute(new Float32Array, 1)), s.call(this, e, i)
    }

    function c(e) {
        e = void 0 === e ? [] : e;
        var i = Object.assign({}, t.ShaderLib.cube),
            n = new t.BoxBufferGeometry(1e4, 1e4, 1e4);
        i = new t.ShaderMaterial({
            fragmentShader: i.fragmentShader,
            vertexShader: i.vertexShader,
            uniforms: i.uniforms,
            side: t.BackSide,
            transparent: !0
        }), s.call(this, n, i), this.images = e, this.edgeLength = 1e4, this.material.uniforms.opacity.value = 0
    }

    function u() {
        for (var e = [], t = 0; 6 > t; t++) e.push(M.WhiteTile);
        c.call(this, e)
    }

    function h(e, i) {
        i = void 0 === i ? {} : i;
        var n = new t.SphereBufferGeometry(5e3, 60, 40),
            r = new t.MeshBasicMaterial({
                opacity: 0,
                transparent: !0
            });
        s.call(this, n, r), this.src = e, this.options = {
            videoElement: document.createElement("video"),
            loop: !0,
            muted: !0,
            autoplay: !1,
            playsinline: !0,
            crossOrigin: "anonymous"
        }, Object.assign(this.options, i), this.videoElement = this.options.videoElement, this.videoProgress = 0, this.radius = 5e3, this.addEventListener("leave", this.pauseVideo.bind(this)), this.addEventListener("enter-fade-start", this.resumeVideoProgress.bind(this)), this.addEventListener("video-toggle", this.toggleVideo.bind(this)), this.addEventListener("video-time", this.setVideoCurrentTime.bind(this))
    }

    function d(e) {
        var t;
        this._parameters = e = void 0 === e ? {} : e, this._panoId = this._zoom = null, this._panoClient = new google.maps.StreetViewService, this._total = this._count = 0, this._canvas = [], this._ctx = [], this._hc = this._wc = 0, this.result = null, this.rotation = 0, this.copyright = "", this.onPanoramaLoad = this.onSizeChange = null, this.levelsW = [1, 2, 4, 7, 13, 26], this.levelsH = [1, 1, 2, 4, 7, 13], this.widths = [416, 832, 1664, 3328, 6656, 13312], this.heights = [416, 416, 832, 1664, 3328, 6656], this.maxH = this.maxW = 6656;
        try {
            var i = document.createElement("canvas");
            (t = i.getContext("experimental-webgl")) || (t = i.getContext("webgl"))
        } catch (e) {}
        this.maxW = Math.max(t.getParameter(t.MAX_TEXTURE_SIZE), this.maxW), this.maxH = Math.max(t.getParameter(t.MAX_TEXTURE_SIZE), this.maxH)
    }

    function p(e, t) {
        a.call(this), this.panoId = e, this.gsvLoader = null, this.loadRequested = !1, this.setupGoogleMapAPI(t)
    }

    function f(e, i, n, r) {
        n = void 0 === n ? 1e4 : n, r = void 0 === r ? .5 : r, "image" === (void 0 === e ? "image" : e) && a.call(this, i, this.createGeometry(n, r), this.createMaterial(n)), this.size = n, this.ratio = r, this.EPS = 1e-6, this.frameId = null, this.dragging = !1, this.userMouse = new t.Vector2, this.quatA = new t.Quaternion, this.quatB = new t.Quaternion, this.quatCur = new t.Quaternion, this.quatSlerp = new t.Quaternion, this.vectorX = new t.Vector3(1, 0, 0), this.vectorY = new t.Vector3(0, 1, 0), this.addEventListener("window-resize", this.onWindowResize)
    }

    function m(e, t, i) {
        f.call(this, "image", e, t, i)
    }

    function g(e) {
        var n = new t.SphereBufferGeometry(5e3, 60, 40),
            r = new t.MeshBasicMaterial({
                visible: !1
            });
        s.call(this, n, r), this.media = new i(e), this.radius = 5e3, this.addEventListener("enter", this.start.bind(this)), this.addEventListener("leave", this.stop.bind(this)), this.addEventListener("panolens-container", this.onPanolensContainer.bind(this)), this.addEventListener("panolens-scene", this.onPanolensScene.bind(this))
    }

    function v(e, i) {
        function n(e) {
            if (F = !1, B = N = 0, !1 !== v.enabled) {
                if (e.preventDefault(), e.button === v.mouseButtons.ORBIT) {
                    if (!0 === v.noRotate) return;
                    U = H.ROTATE, y.set(e.clientX, e.clientY)
                } else if (e.button === v.mouseButtons.ZOOM) {
                    if (!0 === v.noZoom) return;
                    U = H.DOLLY, T.set(e.clientX, e.clientY)
                } else if (e.button === v.mouseButtons.PAN) {
                    if (!0 === v.noPan) return;
                    U = H.PAN, w.set(e.clientX, e.clientY)
                }
                U !== H.NONE && (document.addEventListener("mousemove", r, !1), document.addEventListener("mouseup", o, !1), v.dispatchEvent(W)), v.update()
            }
        }

        function r(e) {
            if (!1 !== v.enabled) {
                e.preventDefault();
                var t = v.domElement === document ? v.domElement.body : v.domElement;
                if (U === H.ROTATE) {
                    if (!0 === v.noRotate) return;
                    b.set(e.clientX, e.clientY), x.subVectors(b, y), v.rotateLeft(2 * Math.PI * x.x / t.clientWidth * v.rotateSpeed), v.rotateUp(2 * Math.PI * x.y / t.clientHeight * v.rotateSpeed), y.copy(b), d && (B = e.clientX - d.clientX, N = e.clientY - d.clientY), d = e
                } else if (U === H.DOLLY) {
                    if (!0 === v.noZoom) return;
                    A.set(e.clientX, e.clientY), C.subVectors(A, T), 0 < C.y ? v.dollyIn() : 0 > C.y && v.dollyOut(), T.copy(A)
                } else if (U === H.PAN) {
                    if (!0 === v.noPan) return;
                    _.set(e.clientX, e.clientY), E.subVectors(_, w), v.pan(E.x, E.y), w.copy(_)
                }
                U !== H.NONE && v.update()
            }
        }

        function o() {
            F = !0, d = void 0, !1 !== v.enabled && (document.removeEventListener("mousemove", r, !1), document.removeEventListener("mouseup", o, !1), v.dispatchEvent(q), U = H.NONE)
        }

        function s(e) {
            if (!1 !== v.enabled && !0 !== v.noZoom && U === H.NONE) {
                e.preventDefault(), e.stopPropagation();
                var t = 0;
                void 0 !== e.wheelDelta ? t = e.wheelDelta : void 0 !== e.detail && (t = -e.detail), 0 < t ? (v.object.fov = v.object.fov < v.maxFov ? v.object.fov + 1 : v.maxFov, v.object.updateProjectionMatrix()) : 0 > t && (v.object.fov = v.object.fov > v.minFov ? v.object.fov - 1 : v.minFov, v.object.updateProjectionMatrix()), v.update(), v.dispatchEvent(V), v.dispatchEvent(W), v.dispatchEvent(q)
            }
        }

        function a(e) {
            switch (e.keyCode) {
                case v.keys.UP:
                    p = !1;
                    break;
                case v.keys.BOTTOM:
                    f = !1;
                    break;
                case v.keys.LEFT:
                    m = !1;
                    break;
                case v.keys.RIGHT:
                    g = !1
            }
        }

        function l(e) {
            if (!1 !== v.enabled && !0 !== v.noKeys && !0 !== v.noRotate) {
                switch (e.keyCode) {
                    case v.keys.UP:
                        p = !0;
                        break;
                    case v.keys.BOTTOM:
                        f = !0;
                        break;
                    case v.keys.LEFT:
                        m = !0;
                        break;
                    case v.keys.RIGHT:
                        g = !0
                }(p || f || m || g) && (F = !0, p && (N = -v.rotateSpeed * v.momentumKeydownFactor), f && (N = v.rotateSpeed * v.momentumKeydownFactor), m && (B = -v.rotateSpeed * v.momentumKeydownFactor), g && (B = v.rotateSpeed * v.momentumKeydownFactor))
            }
        }

        function c(e) {
            if (F = !1, B = N = 0, !1 !== v.enabled) {
                switch (e.touches.length) {
                    case 1:
                        if (!0 === v.noRotate) return;
                        U = H.TOUCH_ROTATE, y.set(e.touches[0].pageX, e.touches[0].pageY);
                        break;
                    case 2:
                        if (!0 === v.noZoom) return;
                        U = H.TOUCH_DOLLY;
                        var t = e.touches[0].pageX - e.touches[1].pageX;
                        e = e.touches[0].pageY - e.touches[1].pageY, T.set(0, Math.sqrt(t * t + e * e));
                        break;
                    case 3:
                        if (!0 === v.noPan) return;
                        U = H.TOUCH_PAN, w.set(e.touches[0].pageX, e.touches[0].pageY);
                        break;
                    default:
                        U = H.NONE
                }
                U !== H.NONE && v.dispatchEvent(W)
            }
        }

        function u(e) {
            if (!1 !== v.enabled) {
                e.preventDefault(), e.stopPropagation();
                var t = v.domElement === document ? v.domElement.body : v.domElement;
                switch (e.touches.length) {
                    case 1:
                        if (!0 === v.noRotate) break;
                        if (U !== H.TOUCH_ROTATE) break;
                        b.set(e.touches[0].pageX, e.touches[0].pageY), x.subVectors(b, y), v.rotateLeft(2 * Math.PI * x.x / t.clientWidth * v.rotateSpeed), v.rotateUp(2 * Math.PI * x.y / t.clientHeight * v.rotateSpeed), y.copy(b), d && (B = e.touches[0].pageX - d.pageX, N = e.touches[0].pageY - d.pageY), d = {
                            pageX: e.touches[0].pageX,
                            pageY: e.touches[0].pageY
                        }, v.update();
                        break;
                    case 2:
                        if (!0 === v.noZoom) break;
                        if (U !== H.TOUCH_DOLLY) break;
                        t = e.touches[0].pageX - e.touches[1].pageX, e = e.touches[0].pageY - e.touches[1].pageY, A.set(0, Math.sqrt(t * t + e * e)), C.subVectors(A, T), 0 > C.y ? (v.object.fov = v.object.fov < v.maxFov ? v.object.fov + 1 : v.maxFov, v.object.updateProjectionMatrix()) : 0 < C.y && (v.object.fov = v.object.fov > v.minFov ? v.object.fov - 1 : v.minFov, v.object.updateProjectionMatrix()), T.copy(A), v.update(), v.dispatchEvent(V);
                        break;
                    case 3:
                        if (!0 === v.noPan) break;
                        if (U !== H.TOUCH_PAN) break;
                        _.set(e.touches[0].pageX, e.touches[0].pageY), E.subVectors(_, w), v.pan(E.x, E.y), w.copy(_), v.update();
                        break;
                    default:
                        U = H.NONE
                }
            }
        }

        function h() {
            F = !0, d = void 0, !1 !== v.enabled && (v.dispatchEvent(q), U = H.NONE)
        }
        this.object = e, this.domElement = void 0 !== i ? i : document, this.frameId = null, this.enabled = !0, this.center = this.target = new t.Vector3, this.noZoom = !1, this.zoomSpeed = 1, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.noRotate = !1, this.rotateSpeed = -.15, this.noPan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.momentumDampingFactor = .9, this.momentumScalingFactor = -.005, this.momentumKeydownFactor = 20, this.minFov = 30, this.maxFov = 120, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.noKeys = !1, this.keys = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            BOTTOM: 40
        }, this.mouseButtons = {
            ORBIT: t.MOUSE.LEFT,
            ZOOM: t.MOUSE.MIDDLE,
            PAN: t.MOUSE.RIGHT
        };
        var d, p, f, m, g, v = this,
            y = new t.Vector2,
            b = new t.Vector2,
            x = new t.Vector2,
            w = new t.Vector2,
            _ = new t.Vector2,
            E = new t.Vector2,
            M = new t.Vector3,
            S = new t.Vector3,
            T = new t.Vector2,
            A = new t.Vector2,
            C = new t.Vector2,
            L = 0,
            P = 0,
            I = 0,
            O = 0,
            R = 1,
            D = new t.Vector3,
            k = new t.Vector3,
            z = new t.Quaternion,
            B = 0,
            N = 0,
            F = !1,
            H = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_DOLLY: 4,
                TOUCH_PAN: 5
            },
            U = H.NONE;
        this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom;
        var j = (new t.Quaternion).setFromUnitVectors(e.up, new t.Vector3(0, 1, 0)),
            G = j.clone().inverse(),
            V = {
                type: "change"
            },
            W = {
                type: "start"
            },
            q = {
                type: "end"
            };
        this.setLastQuaternion = function (e) {
            z.copy(e), v.object.quaternion.copy(e)
        }, this.getLastPosition = function () {
            return k
        }, this.rotateLeft = function (e) {
            void 0 === e && (e = 2 * Math.PI / 60 / 60 * v.autoRotateSpeed), O -= e
        }, this.rotateUp = function (e) {
            void 0 === e && (e = 2 * Math.PI / 60 / 60 * v.autoRotateSpeed), I -= e
        }, this.panLeft = function (e) {
            var t = this.object.matrix.elements;
            M.set(t[0], t[1], t[2]), M.multiplyScalar(-e), D.add(M)
        }, this.panUp = function (e) {
            var t = this.object.matrix.elements;
            M.set(t[4], t[5], t[6]), M.multiplyScalar(e), D.add(M)
        }, this.pan = function (e, i) {
            var n = v.domElement === document ? v.domElement.body : v.domElement;
            if (v.object instanceof t.PerspectiveCamera) {
                var r = v.object.position.clone().sub(v.target).length();
                r *= Math.tan(v.object.fov / 2 * Math.PI / 180), v.panLeft(2 * e * r / n.clientHeight), v.panUp(2 * i * r / n.clientHeight)
            } else v.object instanceof t.OrthographicCamera ? (v.panLeft(e * (v.object.right - v.object.left) / n.clientWidth), v.panUp(i * (v.object.top - v.object.bottom) / n.clientHeight)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.")
        }, this.momentum = function () {
            F && (1e-4 > Math.abs(B) && 1e-4 > Math.abs(N) ? F = !1 : (N *= this.momentumDampingFactor, B *= this.momentumDampingFactor, O -= this.momentumScalingFactor * B, I -= this.momentumScalingFactor * N))
        }, this.dollyIn = function (e) {
            void 0 === e && (e = Math.pow(.95, v.zoomSpeed)), v.object instanceof t.PerspectiveCamera ? R /= e : v.object instanceof t.OrthographicCamera ? (v.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * e)), v.object.updateProjectionMatrix(), v.dispatchEvent(V)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.")
        }, this.dollyOut = function (e) {
            void 0 === e && (e = Math.pow(.95, v.zoomSpeed)), v.object instanceof t.PerspectiveCamera ? R *= e : v.object instanceof t.OrthographicCamera ? (v.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / e)), v.object.updateProjectionMatrix(), v.dispatchEvent(V)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.")
        }, this.update = function (e) {
            var t = this.object.position;
            S.copy(t).sub(this.target), S.applyQuaternion(j), L = Math.atan2(S.x, S.z), P = Math.atan2(Math.sqrt(S.x * S.x + S.z * S.z), S.y), this.autoRotate && U === H.NONE && this.rotateLeft(2 * Math.PI / 60 / 60 * v.autoRotateSpeed), this.momentum(), L += O, P += I, L = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, L)), P = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, P)), P = Math.max(1e-7, Math.min(Math.PI - 1e-7, P));
            var i = S.length() * R;
            i = Math.max(this.minDistance, Math.min(this.maxDistance, i)), this.target.add(D), S.x = i * Math.sin(P) * Math.sin(L), S.y = i * Math.cos(P), S.z = i * Math.sin(P) * Math.cos(L), S.applyQuaternion(G), t.copy(this.target).add(S), this.object.lookAt(this.target), I = O = 0, R = 1, D.set(0, 0, 0), (1e-7 < k.distanceToSquared(this.object.position) || 1e-7 < 8 * (1 - z.dot(this.object.quaternion))) && (!0 !== e && this.dispatchEvent(V), k.copy(this.object.position), z.copy(this.object.quaternion))
        }, this.reset = function () {
            U = H.NONE, this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(V), this.update()
        }, this.getPolarAngle = function () {
            return P
        }, this.getAzimuthalAngle = function () {
            return L
        }, this.dispose = function () {
            this.domElement.removeEventListener("mousedown", n), this.domElement.removeEventListener("mousewheel", s), this.domElement.removeEventListener("DOMMouseScroll", s), this.domElement.removeEventListener("touchstart", c), this.domElement.removeEventListener("touchend", h), this.domElement.removeEventListener("touchmove", u), window.removeEventListener("keyup", a), window.removeEventListener("keydown", l)
        }, this.domElement.addEventListener("mousedown", n, {
            passive: !1
        }), this.domElement.addEventListener("mousewheel", s, {
            passive: !1
        }), this.domElement.addEventListener("DOMMouseScroll", s, {
            passive: !1
        }), this.domElement.addEventListener("touchstart", c, {
            passive: !1
        }), this.domElement.addEventListener("touchend", h, {
            passive: !1
        }), this.domElement.addEventListener("touchmove", u, {
            passive: !1
        }), window.addEventListener("keyup", a, {
            passive: !1
        }), window.addEventListener("keydown", l, {
            passive: !1
        }), this.update()
    }

    function y(e, i) {
        var n = this,
            r = {
                type: "change"
            },
            o = 0,
            s = 0,
            a = 0,
            l = 0;
        this.camera = e, this.camera.rotation.reorder("YXZ"), this.domElement = void 0 !== i ? i : document, this.enabled = !0, this.deviceOrientation = {}, this.alphaOffsetAngle = this.alpha = this.screenOrientation = 0;
        var c = function (e) {
                n.deviceOrientation = e
            },
            u = function () {
                n.screenOrientation = window.orientation || 0
            },
            h = function (e) {
                e.preventDefault(), e.stopPropagation(), a = e.touches[0].pageX, l = e.touches[0].pageY
            },
            d = function (e) {
                e.preventDefault(), e.stopPropagation(), o += t.Math.degToRad((e.touches[0].pageX - a) / 4), s += t.Math.degToRad((l - e.touches[0].pageY) / 4), n.updateAlphaOffsetAngle(o), a = e.touches[0].pageX, l = e.touches[0].pageY
            };
        this.connect = function () {
            u(), window.addEventListener("orientationchange", u, {
                passive: !0
            }), window.addEventListener("deviceorientation", c, {
                passive: !0
            }), window.addEventListener("deviceorientation", this.update.bind(this), {
                passive: !0
            }), n.domElement.addEventListener("touchstart", h, {
                passive: !1
            }), n.domElement.addEventListener("touchmove", d, {
                passive: !1
            }), n.enabled = !0
        }, this.disconnect = function () {
            window.removeEventListener("orientationchange", u, !1), window.removeEventListener("deviceorientation", c, !1), window.removeEventListener("deviceorientation", this.update.bind(this), !1), n.domElement.removeEventListener("touchstart", h, !1), n.domElement.removeEventListener("touchmove", d, !1), n.enabled = !1
        }, this.update = function (e) {
            if (!1 !== n.enabled) {
                var i = n.deviceOrientation.alpha ? t.Math.degToRad(n.deviceOrientation.alpha) + n.alphaOffsetAngle : 0,
                    o = n.deviceOrientation.beta ? t.Math.degToRad(n.deviceOrientation.beta) : 0,
                    a = n.deviceOrientation.gamma ? t.Math.degToRad(n.deviceOrientation.gamma) : 0,
                    l = n.screenOrientation ? t.Math.degToRad(n.screenOrientation) : 0,
                    c = n.camera.quaternion,
                    u = new t.Vector3(0, 0, 1),
                    h = new t.Euler,
                    d = new t.Quaternion,
                    p = new t.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5)),
                    f = new t.Quaternion,
                    m = new t.Quaternion;
                if (0 == n.screenOrientation) {
                    var g = new t.Vector3(1, 0, 0);
                    f.setFromAxisAngle(g, -s)
                } else 180 == n.screenOrientation ? (g = new t.Vector3(1, 0, 0), f.setFromAxisAngle(g, s)) : 90 == n.screenOrientation ? (g = new t.Vector3(0, 1, 0), f.setFromAxisAngle(g, s)) : -90 == n.screenOrientation && (g = new t.Vector3(0, 1, 0), f.setFromAxisAngle(g, -s));
                p.multiply(f), p.multiply(m), h.set(o, i, -a, "YXZ"), c.setFromEuler(h), c.multiply(p), c.multiply(d.setFromAxisAngle(u, -l)), n.alpha = i, !0 !== e && n.dispatchEvent(r)
            }
        }, this.updateAlphaOffsetAngle = function (e) {
            this.alphaOffsetAngle = e, this.update()
        }, this.dispose = function () {
            this.disconnect()
        }, this.connect()
    }

    function b(e) {
        var i = new t.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            n = new t.Scene,
            r = new t.StereoCamera;
        r.aspect = .5;
        var o = new t.WebGLRenderTarget(512, 512, {
            minFilter: t.LinearFilter,
            magFilter: t.NearestFilter,
            format: t.RGBAFormat
        });
        o.scissorTest = !0, o.texture.generateMipmaps = !1;
        var s = new t.Vector2(.441, .156),
            a = new t.PlaneBufferGeometry(1, 1, 10, 20).removeAttribute("normal").toNonIndexed(),
            l = a.attributes.position.array,
            c = a.attributes.uv.array;
        a.attributes.position.count *= 2, a.attributes.uv.count *= 2;
        var u = new Float32Array(2 * l.length);
        u.set(l), u.set(l, l.length);
        var h = new Float32Array(2 * c.length);
        h.set(c), h.set(c, c.length), c = new t.Vector2, l = l.length / 3;
        for (var d = 0, p = u.length / 3; d < p; d++) {
            c.x = u[3 * d], c.y = u[3 * d + 1];
            var f = c.dot(c);
            f = 1.5 + (s.x + s.y * f) * f;
            var m = d < l ? 0 : 1;
            u[3 * d] = c.x / f * 1.5 - .5 + m, u[3 * d + 1] = c.y / f * 3, h[2 * d] = .5 * (h[2 * d] + m)
        }
        a.attributes.position.array = u, a.attributes.uv.array = h, s = new t.MeshBasicMaterial({
            map: o.texture
        }), a = new t.Mesh(a, s), n.add(a), this.setSize = function (t, i) {
            e.setSize(t, i);
            var n = e.getPixelRatio();
            o.setSize(t * n, i * n)
        }, this.render = function (t, s) {
            t.updateMatrixWorld(), null === s.parent && s.updateMatrixWorld(), r.update(s), s = o.width / 2;
            var a = o.height;
            e.autoClear && e.clear(), o.scissor.set(0, 0, s, a), o.viewport.set(0, 0, s, a), e.setRenderTarget(o), e.render(t, r.cameraL), e.clearDepth(), o.scissor.set(s, 0, s, a), o.viewport.set(s, 0, s, a), e.setRenderTarget(o), e.render(t, r.cameraR), e.clearDepth(), e.setRenderTarget(null), e.render(n, i)
        }
    }

    function x(e) {
        if ((e = e || {}).controlBar = void 0 === e.controlBar || e.controlBar, e.controlButtons = e.controlButtons || ["fullscreen", "setting", "video"], e.autoHideControlBar = void 0 !== e.autoHideControlBar && e.autoHideControlBar, e.autoHideInfospot = void 0 === e.autoHideInfospot || e.autoHideInfospot, e.horizontalView = void 0 !== e.horizontalView && e.horizontalView, e.clickTolerance = e.clickTolerance || 10, e.cameraFov = e.cameraFov || 60, e.reverseDragging = e.reverseDragging || !1, e.enableReticle = e.enableReticle || !1, e.dwellTime = e.dwellTime || 1500, e.autoReticleSelect = void 0 === e.autoReticleSelect || e.autoReticleSelect, e.viewIndicator = void 0 !== e.viewIndicator && e.viewIndicator, e.indicatorSize = e.indicatorSize || 30, e.output = e.output ? e.output : "none", e.autoRotate = e.autoRotate || !1, e.autoRotateSpeed = e.autoRotateSpeed || 2, e.autoRotateActivationDuration = e.autoRotateActivationDuration || 5e3, this.options = e, e.container) {
            var i = e.container;
            i._width = i.clientWidth, i._height = i.clientHeight
        } else(i = document.createElement("div")).classList.add("panolens-container"), i.style.width = "100%", i.style.height = "100%", i._width = window.innerWidth, i._height = window.innerHeight, document.body.appendChild(i);
        this.container = i, this.camera = e.camera || new t.PerspectiveCamera(this.options.cameraFov, this.container.clientWidth / this.container.clientHeight, 1, 1e4), this.scene = e.scene || new t.Scene, this.renderer = e.renderer || new t.WebGLRenderer({
            alpha: !0,
            antialias: !1
        }), this.sceneReticle = new t.Scene, this.viewIndicatorSize = this.options.indicatorSize, this.reticle = {}, this.tempEnableReticle = this.options.enableReticle, this.mode = E.NORMAL, this.pressObject = this.pressEntityObject = this.infospot = this.hoverObject = this.widget = this.panorama = null, this.raycaster = new t.Raycaster, this.raycasterPoint = new t.Vector2, this.userMouse = new t.Vector2, this.updateCallbacks = [], this.requestAnimationId = null, this.cameraFrustum = new t.Frustum, this.cameraViewProjectionMatrix = new t.Matrix4, this.outputDivElement = this.autoRotateRequestId = null, this.touchSupported = "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch, this.HANDLER_MOUSE_DOWN = this.onMouseDown.bind(this), this.HANDLER_MOUSE_UP = this.onMouseUp.bind(this), this.HANDLER_MOUSE_MOVE = this.onMouseMove.bind(this), this.HANDLER_WINDOW_RESIZE = this.onWindowResize.bind(this), this.HANDLER_KEY_DOWN = this.onKeyDown.bind(this), this.HANDLER_KEY_UP = this.onKeyUp.bind(this), this.HANDLER_TAP = this.onTap.bind(this, {
            clientX: this.container.clientWidth / 2,
            clientY: this.container.clientHeight / 2
        }), this.OUTPUT_INFOSPOT = !1, this.tweenLeftAnimation = new L.Tween, this.tweenUpAnimation = new L.Tween, this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.container.clientWidth, this.container.clientHeight), this.renderer.setClearColor(0, 0), this.renderer.autoClear = !1, this.renderer.domElement.classList.add("panolens-canvas"), this.renderer.domElement.style.display = "block", this.container.style.backgroundColor = "#000", this.container.appendChild(this.renderer.domElement), this.OrbitControls = new v(this.camera, this.container), this.OrbitControls.id = "orbit", this.OrbitControls.minDistance = 1, this.OrbitControls.noPan = !0, this.OrbitControls.autoRotate = this.options.autoRotate, this.OrbitControls.autoRotateSpeed = this.options.autoRotateSpeed, this.DeviceOrientationControls = new y(this.camera, this.container), this.DeviceOrientationControls.id = "device-orientation", this.DeviceOrientationControls.enabled = !1, this.camera.position.z = 1, this.options.passiveRendering && console.warn("passiveRendering is now deprecated"), this.controls = [this.OrbitControls, this.DeviceOrientationControls], this.control = this.OrbitControls, this.CardboardEffect = new b(this.renderer), this.CardboardEffect.setSize(this.container.clientWidth, this.container.clientHeight), this.StereoEffect = new I(this.renderer), this.StereoEffect.setSize(this.container.clientWidth, this.container.clientHeight), this.effect = this.CardboardEffect, this.addReticle(), this.options.horizontalView && (this.OrbitControls.minPolarAngle = Math.PI / 2, this.OrbitControls.maxPolarAngle = Math.PI / 2), !1 !== this.options.controlBar && this.addDefaultControlBar(this.options.controlButtons), this.options.viewIndicator && this.addViewIndicator(), this.options.reverseDragging && this.reverseDraggingDirection(), this.options.enableReticle ? this.enableReticleControl() : this.registerMouseAndTouchEvents(), "overlay" === this.options.output && this.addOutputElement(), this.registerEventListeners(), this.animate.call(this)
    }
    var w = "^0.105.2".replace(/[^0-9.]/g, ""),
        _ = {
            ORBIT: 0,
            DEVICEORIENTATION: 1
        },
        E = {
            UNKNOWN: 0,
            NORMAL: 1,
            CARDBOARD: 2,
            STEREO: 3
        },
        M = {
            Info: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADBklEQVR42u2bP08UQRiHnzFaSYCI/xoksdBIqGwIiYWRUBISExpCQ0ej38FWOmlIKKhoMPEbaCxsrrHiYrQgOSlQEaICrT+LHSPZzNzt3s3c3Hn7lHvLzvv82L2dm30XKioqKgYY062BJF0HpoA7wARwBbhsPz4DjoEG8AnYNcZ8Sx1Op8IXJM1KWpdUV3nq9m9nJV1I7VNGfEzSM0mNNqR9NOwxx1L7NRMflbQm6SSgeJ4TO8Zoat+8/LKkg4jieQ4kLaf2RtKwpJ0uiufZkTScSn5S0l5C+b/sSZrstvyMpKPU5uc4kjTTjkvpeYCkaeA1/+7hvcIZMGuMqUULQNIU8Aa4ltrWwyHwyBizGzwASSPAe+B2assW7AH3jTE/i+xcZoa12Qfy2Bo3i+5cKABl99zF1GYlWFTBeULLS0DZrOsDcDNggTXgc27bLWA64BhfgHvGmB8dHUXZ1DM0S45xliKMs9bKr+klIOkqsBrwv9JtVq1DewEAT4Ch1BYdMGQdygeg7Df4SmqDAKyoyXpCszPgITCeuvoAjFuX0gE8jljUdv7bCtiOOJ7XpdUZ8L/gdXHOA5QtYH5NXXVgbrgWWn1nwFTqaiPgdPIFcDd1tRFwOl307DwRuZgXwLvctgfA04hjOp18AcReZ6sZY16e3yDpUuQxnU6+S2AkcjEpcDr1zxOXSPgCKLSa0mc4nXwB/EpdbQScTr4AGqmrjYDTyRfAx9TVRsDp5Aug8LJyH+F0cgZg58z11BUHpO5ruGh2G3ybuuqAeF2aBfAqddUB8bq0OgP2U1cegH3aOQOMMb+BrdTVB2DLupQLwLIOnKY26IBT6+ClaQDGmO/ARmqLDtiwDn7HVkcY+EdjNoTlCI+tYhO2iUppm6HKslPUq2qQKHpUe8AFsjaUXuUQWCgqXyoAG8IuME/WkNRrnAHzZfqDSgdgQ6gBc2Td3b3CMTBXtkOsIzTIjZLnQhjcVtlcEIPZLJ0LoVvt8s/Va+3yuSAG84UJRxB98cpM9dJURUVFxSDzBxKde4Lk3/h2AAAAAElFTkSuQmCC",
            Arrow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADPklEQVR42u2bMUscQRiG30/SRaJEI1ZKUiRErNIELRUbQYSAnX8hpVUgkDYp0wgWVjYW+QcJaQzYpLojJIXhtDDEKBpj65ti58ixmdmb2ZvZ7+T2AUHudmfmeXf2bnb3O6CmpqZmgJGqOiI5AWAWwEMA0wDuArht3r4CcAagBeAbgIaI/NQOp1fhIZKLJN+SbDKcptl3keSQtk+I+BjJVyRbJaRdtEybY9p+ReKjJN+QvIwonufS9DGq7ZuXXyd5nFA8zzHJdW1vkLxDcrdC8Ty7JO9oyc+QPFCUb3NAcqZq+TmSp9rmHZySnCvjErwOIPkUwHv8+w7vF64ALIrIfrIASM4C+ADgnratgxMACyLSiB4AyREAnwE80LbswgGAJyJy4bNxyApr6wbIw4xxy3djrwCYfeeuaZsFsEbPdULXU4DZqusLgMkEA21P05EEbf8A8FhEzos28pkBLxLKL5s/r/M1kEkz9vKQHGeatf05yfmOfubNa7G5JDle5NhtBjwHMBz5yFwAWBaRT+0XzP8pZsKwcQiH2fX8Ycojb+kzxUw4ZJn7CSQXqpRPHMKCq7+iZJ71Mvdy/DftXSQ6HcJdSDaqPPKW/mPOBO+lcbvzCU35RCFM2PpwnQKzZQfdgfe0dxH5dLA6uQJ4pC2fIASrkyuA6X6QjxyC1ckVQNn7bNHlI4ZgdXIFUObiJJl8pBCsTjGfuIwA2Cv4FN7xbYjkjqsRAHuIePXoCiDF1Zk2VidXAL+1R5sAq5MrgJb2aBNgdXIF8FV7tAmwOrkCCFs73wysTtYATHFCU3vEEWm6Ci6KvgY/ao86Ik6XogDeaY86Ik6XbjPgSHvkEThCwQy45XpDRK5JbgN4GWkgUyR9H65MRQxgW0SunZ5FezK7pfwd8e8MV8UfAPdF5Jdrg8JrAbPjprZFD2wWyQP6j8ZSEufRmGlgQ9umBBvd5IOgbjFUKLu+XnWBhG+rpsFVZGUo/coJgFVf+aAATAgNACvICpL6jSsAKyH1QcEBmBD2ASwhq+7uF84ALIVWiPUEB7lQsiOEwS2VzQUxmMXSuRCqKpd/zX4rl88FMZg/mLAEcSN+MlP/aKqmpqZmkPkL0hSjwOpNKxwAAAAASUVORK5CYII=",
            FullscreenEnter: "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KICAgIDxwYXRoIGQ9Ik03IDE0SDV2NWg1di0ySDd2LTN6bS0yLTRoMlY3aDNWNUg1djV6bTEyIDdoLTN2Mmg1di01aC0ydjN6TTE0IDV2MmgzdjNoMlY1aC01eiIvPgo8L3N2Zz4=",
            FullscreenLeave: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE0SDE5VjE2SDE2VjE5SDE0VjE0TTUsMTRIMTBWMTlIOFYxNkg1VjE0TTgsNUgxMFYxMEg1VjhIOFY1TTE5LDhWMTBIMTRWNUgxNlY4SDE5WiIgLz48L3N2Zz4=",
            VideoPlay: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTgsNS4xNFYxOS4xNEwxOSwxMi4xNEw4LDUuMTRaIiAvPjwvc3ZnPg==",
            VideoPause: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE5LjE0SDE4VjUuMTRIMTRNNiwxOS4xNEgxMFY1LjE0SDZWMTkuMTRaIiAvPjwvc3ZnPg==",
            WhiteTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIABAMAAAAGVsnJAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB1WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KAtiABQAAACRQTFRFAAAAAAAABgYGBwcHHh4eKysrx8fHy8vLzMzM7OzsAAAABgYG+q7SZgAAAAp0Uk5TAP7+/v7+/v7+/iJx/a8AAAOwSURBVHja7d0hbsNAEAVQo6SFI6XEcALDcgNLvUBvEBQVhpkWVYWlhSsVFS7t5QIshRt695lEASZP+8c7a1kzDL1fz+/zyuvzp6FbvoddrL6uDd1yGZ5eXldeb18N3fIx7A+58prmhm65DfvDcd0952lu6JabFbD/zVprZj1lzcys+fj9z8xTZtbT8rv8yWlu6BYAIgAAAAAAAAAAAABAM6QXEAEAAAAAAAAAgJ2gnaAIiIA3Q2qAGgAAAAAAAAAAAAAAAAAAAAAAAAAAQJsADkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBVlfAcZ3aeZobusUKMGBhV6KUElHGKBERJR6/fxExRkQZl9/lT8S1oVsuhqyYMmPKjCkzvfcCpsxohrwY0Q06EAEAAAAAAAAAAACgGdILiAAAAAAAAAAAwE7QTlAERMCbITVADQAAAAAAAAAAAAAAAAAAAAAAAAAAwKmwQ1ERAAAAAACPQY9BERABERABERABERABERABAAAAAAAAAICdoJ2gCIiAT2bUADVADRABEQAAQBFUBEVABERgEyvAlJm+V4ApM6bMmDJjyowpM6bMdN0LmDKjGfJiRDfoQAQAAAAAAAAAAACAZkgvIAIAAAAAAAAAADtBO0EREAFvhtQANQAAAAAAAAAAAAAAAAAAAAAAAAAAAKfCDkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBTawAU2b6XgGmzJgyY8qMKTOmzJgy03UvYMqMZsiLEd2gAxEAAAAAAAAAAAAAmiG9gAgAAAAAAAAAAOwE7QRFQAS8GVID1AAAAAAAAAAAAAAAAAAAAAAAAAAAAJwKOxQVAQAAAADwGPQYFAEREAEREAEREAEREAERAAAAAAAAAADYCdoJioAI+GRGDVAD1AAREAEAABRBRVAEREAENrECTJnpewWYMmPKjCkzpsyYMmPKTNe9gCkzmiEvRnSDDkQAAAAAAAAAAAAAaIb0AiIAAAAAAAAAALATtBMUARHwZkgNUAMAAAAAAAAAAAAAAAAAAAAAAAAAAHAq7FBUBAAAAADAY9BjUAREQAREQAREQAREQAREAAAAAAAAAABgJ2gnKAIi4JMZNUANUANEQAQAAFAEFUEREAER2MQKMGWm7xVgyowpM50PWen9ugNGXz1XaocAFgAAAABJRU5ErkJggg==",
            Setting: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADn0lEQVR42u2bzUsVURjGnyO6CPzAMnTjppAo3LTwH1CqTfaxbeOiRS37A0wXtROFVi1aRBs3LWohSIGbQAQXViBGRhG0UIRKUCpK7q/FnOB2uc6cOXNmRnGe3eW+H8/7zLln3vNxpQoVKlQ4wjBFJAFOSRqX1O7osivpvjHmU1nChBZglvSYLYJbS0EanCvIJzWK+gnsyH34/8OuMaYjb265jwCgz6N4SWq3vodbAEmnS/KtBDgoAgyU5BteAOAkMAPcBroc7PskDWfgN+wyDwBdltMMcDI3tYBnde/pHeARMNTErgd4APzweP834oeN1dMkz5DlsFNn/yyv4kdiSK4At4AO4CqwGaDwRmza2B0210qM7YhrXU59ANAq6bWkwQTTn5KO5fIE0uVYlXTeGLOXFMx1DrjlULwKKN41x6DlnIjEEQCckPRe0okCiguJr5LOGGO+xhm5jICJQ1i8LOeJJKPYEQAMKvrtt5ZdjSf2FM0Fq/sZJI2A6UNcvCz36TiDfUcAcE1SPu/U6Mm8k/TFfu6XdFb5iX3dGPM8lQfwNod3+TowBnQ3yddtv1vPIe+b1JIBiwEJ1IAJ208k5W21trWA+V/5CHAcmAtU/A2P/DcCiTAHHE8tgCVhgLvAXgYCk17Jo/yTGfLuWe7Zd72AC8CWB4n3OAz7mLytNkZabAEXMhfeQKYfWEpJZCxA3rGUOZeA/qDF15FpAz47EvlNk9neI2e3jeWCz0BbmvipNkSMMX8kuSZYM8Z8zyqAjbHmaN5mOeYjgIXrU93MWrxHrNQjrqiDkQMLHwG+OdqF3NN3jeXKzU8AoF1SzdH8XKhJUO7HZDXLMbwAwICkJUULFxe0SbqSVQAbw3Xi7Ze0ZLmGAzAKbHs0JGU1QtvAaIjCW4B7ZOvJy2qFa5a730RPtBiaz0CgnkiZi6F5fBZDVMvho7EhcuS3xJJ2hV9IupgTqaLw0hhzab8vq23xOG/r+LDsKjLgYVzxUnU0ltwK2wDezUyJmEwqXgp/PL4rvxthaeCSI+zxuA10J8ZkWdJNSb2SLkvayKHwDRu71+ZajrG941J8agALDQ3GU/a/IvMkYCPzmCbtLNEVmacNtgs5iP9fYVNEV1Q6Hez7yNZSL+J2SarTcpqiyV2iUkG0IvPFvbz5FbEn+KEk3wMjwMeSfCsBXFBdly9CAPk9ydyffpECuB5tZfVJjaKWueOSfinln6YK4lahQoUKRxd/AcRPGTcQCAUQAAAAAElFTkSuQmCC",
            ChevronRight: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTguNTksMTYuNThMMTMuMTcsMTJMOC41OSw3LjQxTDEwLDZMMTYsMTJMMTAsMThMOC41OSwxNi41OFoiIC8+PC9zdmc+",
            Check: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIxLDdMOSwxOUwzLjUsMTMuNUw0LjkxLDEyLjA5TDksMTYuMTdMMTkuNTksNS41OUwyMSw3WiIgLz48L3N2Zz4=",
            ViewIndicator: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0idmlldy1pbmRpY2F0b3IiIGhlaWdodD0iMzAiIHdpZHRoPSIzMCIgdmlld0JveD0iLTIuNSAtMSAzMCAzMCI+Cgk8c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7ZmlsbDpub25lO30uc3Qxe3N0cm9rZS13aWR0aDo2O3N0cm9rZS1taXRlcmxpbWl0OjEwO30KCTwvc3R5bGU+Cgk8Zz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNIDEyLjUgMCBBIDEyLjUgMTIuNSAwIDAgMCAtMTIuNSAwIEEgMTIuNSAxMi41IDAgMCAwIDEyLjUgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0gMTMgMCBMIDEwIDIgTCAxNiAyIFoiPjwvcGF0aD4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNIDIgMCBBIDIgMiAwIDAgMCAtMiAwIEEgMiAyIDAgMCAwIDIgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDEiIGlkPSJpbmRpY2F0b3IiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTMsMTUuNSkiPjwvcGF0aD4KCTwvZz4KPC9zdmc+"
        },
        S = {
            load: function (e, i, n, r) {
                var o, s, a, l;
                for (l in i = void 0 === i ? function () {} : i, n = void 0 === n ? function () {} : n, r = void 0 === r ? function () {} : r, t.Cache.enabled = !0, M) M.hasOwnProperty(l) && e === M[l] && (o = l);
                var c = t.Cache.get(o || e);
                if (void 0 !== c) return i && setTimeout((function () {
                    n({
                        loaded: 1,
                        total: 1
                    }), i(c)
                }), 0), c;
                var u = window.URL || window.webkitURL,
                    h = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                t.Cache.add(o || e, h);
                var d = function () {
                    u.revokeObjectURL(h.src), i(h)
                };
                if (0 === e.indexOf("data:")) return h.addEventListener("load", d, !1), h.src = e, h;
                h.crossOrigin = void 0 !== this.crossOrigin ? this.crossOrigin : "", (o = new window.XMLHttpRequest).open("GET", e, !0), o.responseType = "arraybuffer", o.addEventListener("error", r), o.addEventListener("progress", (function (e) {
                    if (e) {
                        var t = e.loaded,
                            i = e.total;
                        e.lengthComputable && n({
                            loaded: t,
                            total: i
                        })
                    }
                })), o.addEventListener("loadend", (function (e) {
                    e && (s = new Uint8Array(e.currentTarget.response), a = new window.Blob([s]), h.addEventListener("load", d, !1), h.src = u.createObjectURL(a))
                })), o.send(null)
            }
        },
        T = {
            load: function (e, i, n, r) {
                i = void 0 === i ? function () {} : i;
                var o = new t.Texture;
                return S.load(e, (function (n) {
                    o.image = n, n = 0 < e.search(/\.(jpg|jpeg)$/) || 0 === e.search(/^data:image\/jpeg/), o.format = n ? t.RGBFormat : t.RGBAFormat, o.needsUpdate = !0, i(o)
                }), n, r), o
            }
        },
        A = {
            load: function (e, i, n, r) {
                var o;
                i = void 0 === i ? function () {} : i, n = void 0 === n ? function () {} : n;
                var s = new t.CubeTexture([]),
                    a = 0,
                    l = {},
                    c = {};
                return e.map((function (e, t) {
                    S.load(e, (function (e) {
                        s.images[t] = e, 6 === ++a && (s.needsUpdate = !0, i(s))
                    }), (function (e) {
                        for (var i in l[t] = {
                                loaded: e.loaded,
                                total: e.total
                            }, c.loaded = 0, o = c.total = 0, l) o++, c.loaded += l[i].loaded, c.total += l[i].total;
                        6 > o && (c.total = c.total / o * 6), n(c)
                    }), r)
                })), s
            }
        };
    i.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
        setContainer: function (e) {
            this.container = e
        },
        setScene: function (e) {
            this.scene = e
        },
        enumerateDevices: function () {
            var e = this.devices,
                t = new Promise((function (t) {
                    t(e)
                }));
            return 0 < e.length ? t : window.navigator.mediaDevices.enumerateDevices()
        },
        switchNextVideoDevice: function () {
            var e = this.stop.bind(this),
                t = this.start.bind(this),
                i = this.setVideDeviceIndex.bind(this),
                n = this.videoDeviceIndex;
            this.getDevices("video").then((function (r) {
                e(), ++n >= r.length ? (i(0), n--) : i(n), t(r[n])
            }))
        },
        getDevices: function (e) {
            e = void 0 === e ? "video" : e;
            var t = this.devices;
            return this.enumerateDevices().then((function (e) {
                return e.map((function (e) {
                    return t.includes(e) || t.push(e), e
                }))
            })).then((function (t) {
                var i = new RegExp(e, "i");
                return t.filter((function (e) {
                    return i.test(e.kind)
                }))
            }))
        },
        getUserMedia: function (e) {
            var t = this.setMediaStream.bind(this),
                i = this.playVideo.bind(this);
            return window.navigator.mediaDevices.getUserMedia(e).then(t).then(i).catch((function (e) {
                console.warn("PANOLENS.Media: " + e)
            }))
        },
        setVideDeviceIndex: function (e) {
            this.videoDeviceIndex = e
        },
        start: function (e) {
            var t = this.constraints,
                i = this.getUserMedia.bind(this);
            return this.element = this.createVideoElement(), this.getDevices().then((function (n) {
                if (!n || 0 === n.length) throw Error("no video device found");
                return t.video.deviceId = (e || n[0]).deviceId, i(t)
            }))
        },
        stop: function () {
            var e = this.stream;
            e && e.active && (e.getTracks()[0].stop(), window.removeEventListener("resize", this.onWindowResize.bind(this)), this.stream = this.element = null)
        },
        setMediaStream: function (e) {
            this.stream = e, this.element.srcObject = e, this.scene && (this.scene.background = this.createVideoTexture()), window.addEventListener("resize", this.onWindowResize.bind(this))
        },
        playVideo: function () {
            var e = this.element;
            e && (e.play(), this.dispatchEvent({
                type: "play"
            }))
        },
        pauseVideo: function () {
            var e = this.element;
            e && (e.pause(), this.dispatchEvent({
                type: "pause"
            }))
        },
        createVideoTexture: function () {
            var e = this.element,
                i = new t.VideoTexture(e);
            return i.generateMipmaps = !1, i.minFilter = t.LinearFilter, i.magFilter = t.LinearFilter, i.format = t.RGBFormat, i.center.set(.5, .5), e.addEventListener("canplay", this.onWindowResize.bind(this)), i
        },
        createVideoElement: function () {
            var e = this.dispatchEvent.bind(this),
                t = document.createElement("video");
            return t.setAttribute("autoplay", ""), t.setAttribute("muted", ""), t.setAttribute("playsinline", ""), t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.width = "100%", t.style.height = "100%", t.style.objectPosition = "center", t.style.objectFit = "cover", t.style.display = this.scene ? "none" : "", t.addEventListener("canplay", (function () {
                return e({
                    type: "canplay"
                })
            })), t
        },
        onWindowResize: function () {
            if (this.element && this.element.videoWidth && this.element.videoHeight && this.scene) {
                var e = this.container,
                    t = e.clientWidth;
                e = e.clientHeight;
                var i = this.scene.background,
                    n = this.element;
                n = n.videoHeight / n.videoWidth * (this.container ? t / e : 1) * this.ratioScalar, t > e ? i.repeat.set(n, 1) : i.repeat.set(1, 1 / n)
            }
        }
    }), n.prototype = Object.assign(Object.create(t.Sprite.prototype), {
        constructor: n,
        setColor: function (e) {
            this.material.color.copy(e instanceof t.Color ? e : new t.Color(e))
        },
        createCanvasTexture: function (e) {
            return (e = new t.CanvasTexture(e)).minFilter = t.LinearFilter, e.magFilter = t.LinearFilter, e.generateMipmaps = !1, e
        },
        createCanvas: function () {
            var e = document.createElement("canvas"),
                t = e.getContext("2d"),
                i = this.dpr;
            return e.width = 32 * i, e.height = 32 * i, t.scale(i, i), t.shadowBlur = 5, t.shadowColor = "rgba(200,200,200,0.9)", {
                canvas: e,
                context: t
            }
        },
        updateCanvasArcByProgress: function (e) {
            var t = this.context,
                i = this.canvasWidth,
                n = this.canvasHeight,
                r = this.material,
                o = this.dpr,
                s = e * Math.PI * 2,
                a = this.color.getStyle(),
                l = .5 * i / o;
            o = .5 * n / o, t.clearRect(0, 0, i, n), t.beginPath(), 0 === e ? (t.arc(l, o, i / 16, 0, 2 * Math.PI), t.fillStyle = a, t.fill()) : (t.arc(l, o, i / 4 - 3, -Math.PI / 2, -Math.PI / 2 + s), t.strokeStyle = a, t.lineWidth = 3, t.stroke()), t.closePath(), r.map.needsUpdate = !0
        },
        ripple: function () {
            var e = this,
                t = this.context,
                i = this.canvasWidth,
                n = this.canvasHeight,
                r = this.material,
                o = this.rippleDuration,
                s = performance.now(),
                a = this.color,
                l = this.dpr,
                c = .5 * i / l,
                u = .5 * n / l,
                h = function () {
                    var d = window.requestAnimationFrame(h),
                        p = (performance.now() - s) / o,
                        f = 0 < 1 - p ? 1 - p : 0,
                        m = p * i * .5 / l;
                    t.clearRect(0, 0, i, n), t.beginPath(), t.arc(c, u, m, 0, 2 * Math.PI), t.fillStyle = "rgba(" + 255 * a.r + ", " + 255 * a.g + ", " + 255 * a.b + ", " + f + ")", t.fill(), t.closePath(), 1 <= p && (window.cancelAnimationFrame(d), e.updateCanvasArcByProgress(0), e.dispatchEvent({
                        type: "reticle-ripple-end"
                    })), r.map.needsUpdate = !0
                };
            this.dispatchEvent({
                type: "reticle-ripple-start"
            }), h()
        },
        show: function () {
            this.visible = !0
        },
        hide: function () {
            this.visible = !1
        },
        start: function (e) {
            this.autoSelect && (this.dispatchEvent({
                type: "reticle-start"
            }), this.startTimestamp = performance.now(), this.callback = e, this.update())
        },
        end: function () {
            this.startTimestamp && (window.cancelAnimationFrame(this.timerId), this.updateCanvasArcByProgress(0), this.startTimestamp = this.timerId = this.callback = null, this.dispatchEvent({
                type: "reticle-end"
            }))
        },
        update: function () {
            this.timerId = window.requestAnimationFrame(this.update.bind(this));
            var e = (performance.now() - this.startTimestamp) / this.dwellTime;
            this.updateCanvasArcByProgress(e), this.dispatchEvent({
                type: "reticle-update",
                progress: e
            }), 1 <= e && (window.cancelAnimationFrame(this.timerId), this.callback && this.callback(), this.end(), this.ripple())
        }
    });
    var C, L = (function (e, t) {
        (t = function () {
            this._tweens = {}, this._tweensAddedDuringUpdate = {}
        }).prototype = {
            getAll: function () {
                return Object.keys(this._tweens).map(function (e) {
                    return this._tweens[e]
                }.bind(this))
            },
            removeAll: function () {
                this._tweens = {}
            },
            add: function (e) {
                this._tweens[e.getId()] = e, this._tweensAddedDuringUpdate[e.getId()] = e
            },
            remove: function (e) {
                delete this._tweens[e.getId()], delete this._tweensAddedDuringUpdate[e.getId()]
            },
            update: function (e, t) {
                var n = Object.keys(this._tweens);
                if (0 === n.length) return !1;
                for (e = void 0 !== e ? e : i.now(); 0 < n.length;) {
                    this._tweensAddedDuringUpdate = {};
                    for (var r = 0; r < n.length; r++) {
                        var o = this._tweens[n[r]];
                        o && !1 === o.update(e) && (o._isPlaying = !1, t || delete this._tweens[n[r]])
                    }
                    n = Object.keys(this._tweensAddedDuringUpdate)
                }
                return !0
            }
        };
        var i = new t;
        i.Group = t, i._nextId = 0, i.nextId = function () {
            return i._nextId++
        }, i.now = "undefined" == typeof self && "undefined" != typeof process && process.hrtime ? function () {
            var e = process.hrtime();
            return 1e3 * e[0] + e[1] / 1e6
        } : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now.bind(self.performance) : void 0 !== Date.now ? Date.now : function () {
            return (new Date).getTime()
        }, i.Tween = function (e, t) {
            this._object = e, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._reversed = this._isPlaying = this._yoyo = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = i.Easing.Linear.None, this._interpolationFunction = i.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onStopCallback = this._onCompleteCallback = this._onRepeatCallback = this._onUpdateCallback = null, this._group = t || i, this._id = i.nextId()
        }, i.Tween.prototype = {
            getId: function () {
                return this._id
            },
            isPlaying: function () {
                return this._isPlaying
            },
            to: function (e, t) {
                return this._valuesEnd = Object.create(e), void 0 !== t && (this._duration = t), this
            },
            duration: function (e) {
                return this._duration = e, this
            },
            start: function (e) {
                for (var t in this._group.add(this), this._isPlaying = !0, this._onStartCallbackFired = !1, this._startTime = void 0 !== e ? "string" == typeof e ? i.now() + parseFloat(e) : e : i.now(), this._startTime += this._delayTime, this._valuesEnd) {
                    if (this._valuesEnd[t] instanceof Array) {
                        if (0 === this._valuesEnd[t].length) continue;
                        this._valuesEnd[t] = [this._object[t]].concat(this._valuesEnd[t])
                    }
                    void 0 !== this._object[t] && (this._valuesStart[t] = this._object[t], 0 == this._valuesStart[t] instanceof Array && (this._valuesStart[t] *= 1), this._valuesStartRepeat[t] = this._valuesStart[t] || 0)
                }
                return this
            },
            stop: function () {
                return this._isPlaying ? (this._group.remove(this), this._isPlaying = !1, null !== this._onStopCallback && this._onStopCallback(this._object), this.stopChainedTweens(), this) : this
            },
            end: function () {
                return this.update(1 / 0), this
            },
            stopChainedTweens: function () {
                for (var e = 0, t = this._chainedTweens.length; e < t; e++) this._chainedTweens[e].stop()
            },
            group: function (e) {
                return this._group = e, this
            },
            delay: function (e) {
                return this._delayTime = e, this
            },
            repeat: function (e) {
                return this._repeat = e, this
            },
            repeatDelay: function (e) {
                return this._repeatDelayTime = e, this
            },
            yoyo: function (e) {
                return this._yoyo = e, this
            },
            easing: function (e) {
                return this._easingFunction = e, this
            },
            interpolation: function (e) {
                return this._interpolationFunction = e, this
            },
            chain: function () {
                return this._chainedTweens = arguments, this
            },
            onStart: function (e) {
                return this._onStartCallback = e, this
            },
            onUpdate: function (e) {
                return this._onUpdateCallback = e, this
            },
            onRepeat: function (e) {
                return this._onRepeatCallback = e, this
            },
            onComplete: function (e) {
                return this._onCompleteCallback = e, this
            },
            onStop: function (e) {
                return this._onStopCallback = e, this
            },
            update: function (e) {
                var t;
                if (e < this._startTime) return !0;
                !1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0);
                var i = (e - this._startTime) / this._duration;
                i = 0 === this._duration || 1 < i ? 1 : i;
                var n = this._easingFunction(i);
                for (t in this._valuesEnd)
                    if (void 0 !== this._valuesStart[t]) {
                        var r = this._valuesStart[t] || 0,
                            o = this._valuesEnd[t];
                        o instanceof Array ? this._object[t] = this._interpolationFunction(o, n) : ("string" == typeof o && (o = "+" === o.charAt(0) || "-" === o.charAt(0) ? r + parseFloat(o) : parseFloat(o)), "number" == typeof o && (this._object[t] = r + (o - r) * n))
                    } if (null !== this._onUpdateCallback && this._onUpdateCallback(this._object, i), 1 === i) {
                    if (!(0 < this._repeat)) {
                        for (null !== this._onCompleteCallback && this._onCompleteCallback(this._object), e = 0, t = this._chainedTweens.length; e < t; e++) this._chainedTweens[e].start(this._startTime + this._duration);
                        return !1
                    }
                    for (t in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) "string" == typeof this._valuesEnd[t] && (this._valuesStartRepeat[t] += parseFloat(this._valuesEnd[t])), this._yoyo && (i = this._valuesStartRepeat[t], this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = i), this._valuesStart[t] = this._valuesStartRepeat[t];
                    this._yoyo && (this._reversed = !this._reversed), this._startTime = void 0 !== this._repeatDelayTime ? e + this._repeatDelayTime : e + this._delayTime, null !== this._onRepeatCallback && this._onRepeatCallback(this._object)
                }
                return !0
            }
        }, i.Easing = {
            Linear: {
                None: function (e) {
                    return e
                }
            },
            Quadratic: {
                In: function (e) {
                    return e * e
                },
                Out: function (e) {
                    return e * (2 - e)
                },
                InOut: function (e) {
                    return 1 > (e *= 2) ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
                }
            },
            Cubic: {
                In: function (e) {
                    return e * e * e
                },
                Out: function (e) {
                    return --e * e * e + 1
                },
                InOut: function (e) {
                    return 1 > (e *= 2) ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
                }
            },
            Quartic: {
                In: function (e) {
                    return e * e * e * e
                },
                Out: function (e) {
                    return 1 - --e * e * e * e
                },
                InOut: function (e) {
                    return 1 > (e *= 2) ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
                }
            },
            Quintic: {
                In: function (e) {
                    return e * e * e * e * e
                },
                Out: function (e) {
                    return --e * e * e * e * e + 1
                },
                InOut: function (e) {
                    return 1 > (e *= 2) ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
                }
            },
            Sinusoidal: {
                In: function (e) {
                    return 1 - Math.cos(e * Math.PI / 2)
                },
                Out: function (e) {
                    return Math.sin(e * Math.PI / 2)
                },
                InOut: function (e) {
                    return .5 * (1 - Math.cos(Math.PI * e))
                }
            },
            Exponential: {
                In: function (e) {
                    return 0 === e ? 0 : Math.pow(1024, e - 1)
                },
                Out: function (e) {
                    return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
                },
                InOut: function (e) {
                    return 0 === e ? 0 : 1 === e ? 1 : 1 > (e *= 2) ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                }
            },
            Circular: {
                In: function (e) {
                    return 1 - Math.sqrt(1 - e * e)
                },
                Out: function (e) {
                    return Math.sqrt(1 - --e * e)
                },
                InOut: function (e) {
                    return 1 > (e *= 2) ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                }
            },
            Elastic: {
                In: function (e) {
                    return 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI)
                },
                Out: function (e) {
                    return 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin(5 * (e - .1) * Math.PI) + 1
                },
                InOut: function (e) {
                    return 0 === e ? 0 : 1 === e ? 1 : 1 > (e *= 2) ? -.5 * Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) + 1
                }
            },
            Back: {
                In: function (e) {
                    return e * e * (2.70158 * e - 1.70158)
                },
                Out: function (e) {
                    return --e * e * (2.70158 * e + 1.70158) + 1
                },
                InOut: function (e) {
                    return 1 > (e *= 2) ? .5 * e * e * (3.5949095 * e - 2.5949095) : .5 * ((e -= 2) * e * (3.5949095 * e + 2.5949095) + 2)
                }
            },
            Bounce: {
                In: function (e) {
                    return 1 - i.Easing.Bounce.Out(1 - e)
                },
                Out: function (e) {
                    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                },
                InOut: function (e) {
                    return .5 > e ? .5 * i.Easing.Bounce.In(2 * e) : .5 * i.Easing.Bounce.Out(2 * e - 1) + .5
                }
            }
        }, i.Interpolation = {
            Linear: function (e, t) {
                var n = e.length - 1,
                    r = n * t,
                    o = Math.floor(r),
                    s = i.Interpolation.Utils.Linear;
                return 0 > t ? s(e[0], e[1], r) : 1 < t ? s(e[n], e[n - 1], n - r) : s(e[o], e[o + 1 > n ? n : o + 1], r - o)
            },
            Bezier: function (e, t) {
                for (var n = 0, r = e.length - 1, o = Math.pow, s = i.Interpolation.Utils.Bernstein, a = 0; a <= r; a++) n += o(1 - t, r - a) * o(t, a) * e[a] * s(r, a);
                return n
            },
            CatmullRom: function (e, t) {
                var n = e.length - 1,
                    r = n * t,
                    o = Math.floor(r),
                    s = i.Interpolation.Utils.CatmullRom;
                return e[0] === e[n] ? (0 > t && (o = Math.floor(r = n * (1 + t))), s(e[(o - 1 + n) % n], e[o], e[(o + 1) % n], e[(o + 2) % n], r - o)) : 0 > t ? e[0] - (s(e[0], e[0], e[1], e[1], -r) - e[0]) : 1 < t ? e[n] - (s(e[n], e[n], e[n - 1], e[n - 1], r - n) - e[n]) : s(e[o ? o - 1 : 0], e[o], e[n < o + 1 ? n : o + 1], e[n < o + 2 ? n : o + 2], r - o)
            },
            Utils: {
                Linear: function (e, t, i) {
                    return (t - e) * i + e
                },
                Bernstein: function (e, t) {
                    var n = i.Interpolation.Utils.Factorial;
                    return n(e) / n(t) / n(e - t)
                },
                Factorial: function () {
                    var e = [1];
                    return function (t) {
                        var i = 1;
                        if (e[t]) return e[t];
                        for (var n = t; 1 < n; n--) i *= n;
                        return e[t] = i
                    }
                }(),
                CatmullRom: function (e, t, i, n, r) {
                    var o = r * r;
                    return (2 * t - 2 * i + (e = .5 * (i - e)) + (n = .5 * (n - t))) * r * o + (-3 * t + 3 * i - 2 * e - n) * o + e * r + t
                }
            }
        }, e.exports = i
    }(C = {
        exports: {}
    }, C.exports), C.exports);
    r.prototype = Object.assign(Object.create(t.Sprite.prototype), {
        constructor: r,
        setContainer: function (e) {
            if (e instanceof HTMLElement) var t = e;
            else e && e.container && (t = e.container);
            t && this.element && t.appendChild(this.element), this.container = t
        },
        getContainer: function () {
            return this.container
        },
        onClick: function (e) {
            this.element && this.getContainer() && (this.onHoverStart(e), this.lockHoverElement())
        },
        onDismiss: function () {
            this.element && (this.unlockHoverElement(), this.onHoverEnd())
        },
        onHover: function () {},
        onHoverStart: function (e) {
            if (this.getContainer()) {
                var t = this.cursorStyle || (this.mode === E.NORMAL ? "pointer" : "default"),
                    i = this.scaleDownAnimation,
                    n = this.scaleUpAnimation,
                    r = this.element;
                this.isHovering = !0, this.container.style.cursor = t, this.animated && (i.stop(), n.start()), r && 0 <= e.mouseEvent.clientX && 0 <= e.mouseEvent.clientY && (e = r.left, t = r.right, i = r.style, this.mode === E.CARDBOARD || this.mode === E.STEREO ? (i.display = "none", e.style.display = "block", t.style.display = "block", r._width = e.clientWidth, r._height = e.clientHeight) : (i.display = "block", e && (e.style.display = "none"), t && (t.style.display = "none"), r._width = r.clientWidth, r._height = r.clientHeight))
            }
        },
        onHoverEnd: function () {
            if (this.getContainer()) {
                var e = this.scaleDownAnimation,
                    t = this.scaleUpAnimation,
                    i = this.element;
                this.isHovering = !1, this.container.style.cursor = "default", this.animated && (t.stop(), e.start()), i && !this.element.locked && (e = i.left, t = i.right, i.style.display = "none", e && (e.style.display = "none"), t && (t.style.display = "none"), this.unlockHoverElement())
            }
        },
        onDualEyeEffect: function (e) {
            if (this.getContainer()) {
                this.mode = e.mode, e = this.element;
                var t = this.container.clientWidth / 2,
                    i = this.container.clientHeight / 2;
                e && (e.left || e.right || (e.left = e.cloneNode(!0), e.right = e.cloneNode(!0)), this.mode === E.CARDBOARD || this.mode === E.STEREO ? (e.left.style.display = e.style.display, e.right.style.display = e.style.display, e.style.display = "none") : (e.style.display = e.left.style.display, e.left.style.display = "none", e.right.style.display = "none"), this.translateElement(t, i), this.container.appendChild(e.left), this.container.appendChild(e.right))
            }
        },
        translateElement: function (e, t) {
            if (this.element._width && this.element._height && this.getContainer()) {
                var i = this.container,
                    n = this.element,
                    r = n._width / 2,
                    o = n._height / 2,
                    s = void 0 !== n.verticalDelta ? n.verticalDelta : 40,
                    a = e - r,
                    l = t - o - s;
                this.mode !== E.CARDBOARD && this.mode !== E.STEREO || !n.left || !n.right || e === i.clientWidth / 2 && t === i.clientHeight / 2 ? this.setElementStyle("transform", n, "translate(" + a + "px, " + l + "px)") : (a = i.clientWidth / 4 - r + (e - i.clientWidth / 2), l = i.clientHeight / 2 - o - s + (t - i.clientHeight / 2), this.setElementStyle("transform", n.left, "translate(" + a + "px, " + l + "px)"), a += i.clientWidth / 2, this.setElementStyle("transform", n.right, "translate(" + a + "px, " + l + "px)"))
            }
        },
        setElementStyle: function (e, t, i) {
            t = t.style, "transform" === e && (t.webkitTransform = t.msTransform = t.transform = i)
        },
        setText: function (e) {
            this.element && (this.element.textContent = e)
        },
        setCursorHoverStyle: function (e) {
            this.cursorStyle = e
        },
        addHoverText: function (e, t) {
            t = void 0 === t ? 40 : t, this.element || (this.element = document.createElement("div"), this.element.style.display = "none", this.element.style.color = "#fff", this.element.style.top = 0, this.element.style.maxWidth = "50%", this.element.style.maxHeight = "50%", this.element.style.textShadow = "0 0 3px #000000", this.element.style.fontFamily = '"Trebuchet MS", Helvetica, sans-serif', this.element.style.position = "absolute", this.element.classList.add("panolens-infospot"), this.element.verticalDelta = t), this.setText(e)
        },
        addHoverElement: function (e, t) {
            t = void 0 === t ? 40 : t, this.element || (this.element = e.cloneNode(!0), this.element.style.display = "none", this.element.style.top = 0, this.element.style.position = "absolute", this.element.classList.add("panolens-infospot"), this.element.verticalDelta = t)
        },
        removeHoverElement: function () {
            this.element && (this.element.left && (this.container.removeChild(this.element.left), this.element.left = null), this.element.right && (this.container.removeChild(this.element.right), this.element.right = null), this.container.removeChild(this.element), this.element = null)
        },
        lockHoverElement: function () {
            this.element && (this.element.locked = !0)
        },
        unlockHoverElement: function () {
            this.element && (this.element.locked = !1)
        },
        enableRaycast: function (e) {
            this.raycast = void 0 === e || e ? this.originalRaycast : function () {}
        },
        show: function (e) {
            e = void 0 === e ? 0 : e;
            var t = this.hideAnimation,
                i = this.showAnimation,
                n = this.material;
            this.animated ? (t.stop(), i.delay(e).start()) : (this.enableRaycast(!0), n.opacity = 1)
        },
        hide: function (e) {
            e = void 0 === e ? 0 : e;
            var t = this.hideAnimation,
                i = this.showAnimation,
                n = this.material;
            this.animated ? (i.stop(), t.delay(e).start()) : (this.enableRaycast(!1), n.opacity = 0)
        },
        setFocusMethod: function (e) {
            e && (this.HANDLER_FOCUS = e.method)
        },
        focus: function (e, t) {
            this.HANDLER_FOCUS && (this.HANDLER_FOCUS(this.position, e, t), this.onDismiss())
        },
        dispose: function () {
            var e = this.geometry,
                t = this.material,
                i = t.map;
            this.removeHoverElement(), this.parent && this.parent.remove(this), i && (i.dispose(), t.map = null), e && (e.dispose(), this.geometry = null), t && (t.dispose(), this.material = null)
        }
    }), o.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
        constructor: o,
        addControlBar: function () {
            if (this.container) {
                var e, t, i = this,
                    n = document.createElement("div");
                n.style.width = "100%", n.style.height = "44px", n.style.float = "left", n.style.transform = n.style.webkitTransform = n.style.msTransform = "translateY(-100%)", n.style.background = "-webkit-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "-moz-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "-o-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "-ms-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.transition = this.DEFAULT_TRANSITION, n.style.pointerEvents = "none", n.isHidden = !1, n.toggle = function () {
                    n.isHidden = !n.isHidden, e = n.isHidden ? "translateY(0)" : "translateY(-100%)", t = n.isHidden ? 0 : 1, n.style.transform = n.style.webkitTransform = n.style.msTransform = e, n.style.opacity = t
                };
                var r = this.createDefaultMenu();
                this.mainMenu = this.createMainMenu(r), n.appendChild(this.mainMenu), this.mask = r = this.createMask(), this.container.appendChild(r), n.dispose = function () {
                    i.fullscreenElement && (n.removeChild(i.fullscreenElement), i.fullscreenElement.dispose(), i.fullscreenElement = null), i.settingElement && (n.removeChild(i.settingElement), i.settingElement.dispose(), i.settingElement = null), i.videoElement && (n.removeChild(i.videoElement), i.videoElement.dispose(), i.videoElement = null)
                }, this.container.appendChild(n), this.mask.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener(i.TOUCH_ENABLED ? "touchend" : "click", (function (e) {
                    e.preventDefault(), e.stopPropagation(), i.mask.hide(), i.settingElement.deactivate()
                }), !1), this.addEventListener("control-bar-toggle", n.toggle), this.barElement = n
            } else console.warn("Widget container not set")
        },
        createDefaultMenu: function () {
            var e = this,
                t = function (t, i) {
                    return function () {
                        e.dispatchEvent({
                            type: "panolens-viewer-handler",
                            method: t,
                            data: i
                        })
                    }
                };
            return [{
                title: "Control",
                subMenu: [{
                    title: this.TOUCH_ENABLED ? "Touch" : "Mouse",
                    handler: t("enableControl", _.ORBIT)
                }, {
                    title: "Sensor",
                    handler: t("enableControl", _.DEVICEORIENTATION)
                }]
            }, {
                title: "Mode",
                subMenu: [{
                    title: "Normal",
                    handler: t("disableEffect")
                }, {
                    title: "Cardboard",
                    handler: t("enableEffect", E.CARDBOARD)
                }, {
                    title: "Stereoscopic",
                    handler: t("enableEffect", E.STEREO)
                }]
            }]
        },
        addControlButton: function (e) {
            switch (e) {
                case "fullscreen":
                    this.fullscreenElement = e = this.createFullscreenButton();
                    break;
                case "setting":
                    this.settingElement = e = this.createSettingButton();
                    break;
                case "video":
                    this.videoElement = e = this.createVideoControl();
                    break;
                default:
                    return
            }
            e && this.barElement.appendChild(e)
        },
        createMask: function () {
            var e = document.createElement("div");
            return e.style.position = "absolute", e.style.top = 0, e.style.left = 0, e.style.width = "100%", e.style.height = "100%", e.style.background = "transparent", e.style.display = "none", e.show = function () {
                this.style.display = "block"
            }, e.hide = function () {
                this.style.display = "none"
            }, e
        },
        createSettingButton: function () {
            var e = this,
                t = this.createCustomItem({
                    style: {
                        backgroundImage: 'url("' + M.Setting + '")',
                        webkitTransition: this.DEFAULT_TRANSITION,
                        transition: this.DEFAULT_TRANSITION
                    },
                    onTap: function (t) {
                        t.preventDefault(), t.stopPropagation(), e.mainMenu.toggle(), this.activated ? this.deactivate() : this.activate()
                    }
                });
            return t.activate = function () {
                this.style.transform = "rotate3d(0,0,1,90deg)", this.activated = !0, e.mask.show()
            }, t.deactivate = function () {
                this.style.transform = "rotate3d(0,0,0,0)", this.activated = !1, e.mask.hide(), e.mainMenu && e.mainMenu.visible && e.mainMenu.hide(), e.activeSubMenu && e.activeSubMenu.visible && e.activeSubMenu.hide(), e.mainMenu && e.mainMenu._width && (e.mainMenu.changeSize(e.mainMenu._width), e.mainMenu.unslideAll())
            }, t.activated = !1, t
        },
        createFullscreenButton: function () {
            function e() {
                n && (i = !i, o.style.backgroundImage = i ? 'url("' + M.FullscreenLeave + '")' : 'url("' + M.FullscreenEnter + '")'), t.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "onWindowResize"
                }), n = !0
            }
            var t = this,
                i = !1,
                n = !0,
                r = this.container;
            if (document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled) {
                document.addEventListener("fullscreenchange", e, !1), document.addEventListener("webkitfullscreenchange", e, !1), document.addEventListener("mozfullscreenchange", e, !1), document.addEventListener("MSFullscreenChange", e, !1);
                var o = this.createCustomItem({
                    style: {
                        backgroundImage: 'url("' + M.FullscreenEnter + '")'
                    },
                    onTap: function (e) {
                        e.preventDefault(), e.stopPropagation(), n = !1, i ? (document.exitFullscreen && document.exitFullscreen(), document.msExitFullscreen && document.msExitFullscreen(), document.mozCancelFullScreen && document.mozCancelFullScreen(), document.webkitExitFullscreen && document.webkitExitFullscreen(), i = !1) : (r.requestFullscreen && r.requestFullscreen(), r.msRequestFullscreen && r.msRequestFullscreen(), r.mozRequestFullScreen && r.mozRequestFullScreen(), r.webkitRequestFullscreen && r.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT), i = !0), this.style.backgroundImage = i ? 'url("' + M.FullscreenLeave + '")' : 'url("' + M.FullscreenEnter + '")'
                    }
                });
                if (!document.querySelector("panolens-style-addon")) {
                    var s = document.createElement("style");
                    s.id = "panolens-style-addon", s.innerHTML = ":-webkit-full-screen { width: 100% !important; height: 100% !important }", document.body.appendChild(s)
                }
                return o
            }
        },
        createVideoControl: function () {
            var e = document.createElement("span");
            return e.style.display = "none", e.show = function () {
                e.style.display = ""
            }, e.hide = function () {
                e.style.display = "none", e.controlButton.paused = !0, e.controlButton.update()
            }, e.controlButton = this.createVideoControlButton(), e.seekBar = this.createVideoControlSeekbar(), e.appendChild(e.controlButton), e.appendChild(e.seekBar), e.dispose = function () {
                e.removeChild(e.controlButton), e.removeChild(e.seekBar), e.controlButton.dispose(), e.controlButton = null, e.seekBar.dispose(), e.seekBar = null
            }, this.addEventListener("video-control-show", e.show), this.addEventListener("video-control-hide", e.hide), e
        },
        createVideoControlButton: function () {
            var e = this,
                t = this.createCustomItem({
                    style: {
                        float: "left",
                        backgroundImage: 'url("' + M.VideoPlay + '")'
                    },
                    onTap: function (i) {
                        i.preventDefault(), i.stopPropagation(), e.dispatchEvent({
                            type: "panolens-viewer-handler",
                            method: "toggleVideoPlay",
                            data: !this.paused
                        }), this.paused = !this.paused, t.update()
                    }
                });
            return t.paused = !0, t.update = function (e) {
                this.paused = void 0 !== e ? e : this.paused, this.style.backgroundImage = 'url("' + (this.paused ? M.VideoPlay : M.VideoPause) + '")'
            }, t
        },
        createVideoControlSeekbar: function () {
            function e(e) {
                e.stopPropagation(), l = !0, r = e.clientX || e.changedTouches && e.changedTouches[0].clientX, o = parseInt(c.style.width) / 100, a.container.addEventListener("mousemove", t, {
                    passive: !0
                }), a.container.addEventListener("mouseup", i, {
                    passive: !0
                }), a.container.addEventListener("touchmove", t, {
                    passive: !0
                }), a.container.addEventListener("touchend", i, {
                    passive: !0
                })
            }

            function t(e) {
                l && (s = ((e.clientX || e.changedTouches && e.changedTouches[0].clientX) - r) / h.clientWidth, s = 1 < (s = o + s) ? 1 : 0 > s ? 0 : s, h.setProgress(s), a.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "setVideoCurrentTime",
                    data: s
                }))
            }

            function i(e) {
                e.stopPropagation(), l = !1, n()
            }

            function n() {
                a.container.removeEventListener("mousemove", t, !1), a.container.removeEventListener("mouseup", i, !1), a.container.removeEventListener("touchmove", t, !1), a.container.removeEventListener("touchend", i, !1)
            }
            var r, o, s, a = this,
                l = !1,
                c = document.createElement("div");
            c.style.width = "0%", c.style.height = "100%", c.style.backgroundColor = "#fff";
            var u = document.createElement("div");
            u.style.float = "right", u.style.width = "14px", u.style.height = "14px", u.style.transform = "translate(7px, -5px)", u.style.borderRadius = "50%", u.style.backgroundColor = "#ddd", u.addEventListener("mousedown", e, {
                passive: !0
            }), u.addEventListener("touchstart", e, {
                passive: !0
            }), c.appendChild(u);
            var h = this.createCustomItem({
                style: {
                    float: "left",
                    width: "30%",
                    height: "4px",
                    marginTop: "20px",
                    backgroundColor: "rgba(188,188,188,0.8)"
                },
                onTap: function (e) {
                    if (e.preventDefault(), e.stopPropagation(), e.target !== u) {
                        var t = e.changedTouches && 0 < e.changedTouches.length ? (e.changedTouches[0].pageX - e.target.getBoundingClientRect().left) / this.clientWidth : e.offsetX / this.clientWidth;
                        a.dispatchEvent({
                            type: "panolens-viewer-handler",
                            method: "setVideoCurrentTime",
                            data: t
                        }), h.setProgress(e.offsetX / this.clientWidth)
                    }
                },
                onDispose: function () {
                    n(), u = c = null
                }
            });
            return h.appendChild(c), h.setProgress = function (e) {
                c.style.width = 100 * e + "%"
            }, this.addEventListener("video-update", (function (e) {
                h.setProgress(e.percentage)
            })), h.progressElement = c, h.progressElementControl = u, h
        },
        createMenuItem: function (e) {
            var t = this,
                i = document.createElement("a");
            return i.textContent = e, i.style.display = "block", i.style.padding = "10px", i.style.textDecoration = "none", i.style.cursor = "pointer", i.style.pointerEvents = "auto", i.style.transition = this.DEFAULT_TRANSITION, i.slide = function (e) {
                this.style.transform = "translateX(" + (e ? "" : "-") + "100%)"
            }, i.unslide = function () {
                this.style.transform = "translateX(0)"
            }, i.setIcon = function (e) {
                this.icon && (this.icon.style.backgroundImage = "url(" + e + ")")
            }, i.setSelectionTitle = function (e) {
                this.selection && (this.selection.textContent = e)
            }, i.addSelection = function (e) {
                var t = document.createElement("span");
                return t.style.fontSize = "13px", t.style.fontWeight = "300", t.style.float = "right", this.selection = t, this.setSelectionTitle(e), this.appendChild(t), this
            }, i.addIcon = function (e, t, i) {
                e = void 0 === e ? M.ChevronRight : e, t = void 0 !== t && t, i = void 0 !== i && i;
                var n = document.createElement("span");
                return n.style.float = t ? "left" : "right", n.style.width = "17px", n.style.height = "17px", n.style["margin" + (t ? "Right" : "Left")] = "12px", n.style.backgroundSize = "cover", i && (n.style.transform = "rotateZ(180deg)"), this.icon = n, this.setIcon(e), this.appendChild(n), this
            }, i.addSubMenu = function (e, i) {
                return this.subMenu = t.createSubMenu(e, i), this
            }, i.addEventListener("mouseenter", (function () {
                this.style.backgroundColor = "#e0e0e0"
            }), !1), i.addEventListener("mouseleave", (function () {
                this.style.backgroundColor = "#fafafa"
            }), !1), i
        },
        createMenuItemHeader: function (e) {
            return (e = this.createMenuItem(e)).style.borderBottom = "1px solid #333", e.style.paddingBottom = "15px", e
        },
        createMainMenu: function (e) {
            function t(e) {
                e.preventDefault(), e.stopPropagation();
                var t = i.mainMenu,
                    n = this.subMenu;
                t.hide(), t.slideAll(), t.parentElement.appendChild(n), i.activeMainItem = this, i.activeSubMenu = n, window.requestAnimationFrame((function () {
                    t.changeSize(n.clientWidth), n.show(), n.unslideAll()
                }))
            }
            var i = this,
                n = this.createMenu();
            n._width = 200, n.changeSize(n._width);
            for (var r = 0; r < e.length; r++) {
                var o = n.addItem(e[r].title);
                o.style.paddingLeft = "20px", o.addIcon().addEventListener(i.TOUCH_ENABLED ? "touchend" : "click", t, !1), e[r].subMenu && 0 < e[r].subMenu.length && o.addSelection(e[r].subMenu[0].title).addSubMenu(e[r].title, e[r].subMenu)
            }
            return n
        },
        createSubMenu: function (e, t) {
            function i(e) {
                e.preventDefault(), e.stopPropagation(), (n = r.mainMenu).changeSize(n._width), n.unslideAll(), n.show(), o.slideAll(!0), o.hide(), "header" !== this.type && (o.setActiveItem(this), r.activeMainItem.setSelectionTitle(this.textContent), this.handler && this.handler())
            }
            var n, r = this,
                o = this.createMenu();
            for (o.items = t, o.activeItem = null, o.addHeader(e).addIcon(void 0, !0, !0).addEventListener(r.TOUCH_ENABLED ? "touchend" : "click", i, !1), e = 0; e < t.length; e++) {
                var s = o.addItem(t[e].title);
                s.style.fontWeight = 300, s.handler = t[e].handler, s.addIcon(" ", !0), s.addEventListener(r.TOUCH_ENABLED ? "touchend" : "click", i, !1), o.activeItem || o.setActiveItem(s)
            }
            return o.slideAll(!0), o
        },
        createMenu: function () {
            var e = this,
                t = document.createElement("span"),
                i = t.style;
            return i.padding = "5px 0", i.position = "fixed", i.bottom = "100%", i.right = "14px", i.backgroundColor = "#fafafa", i.fontFamily = "Helvetica Neue", i.fontSize = "14px", i.visibility = "hidden", i.opacity = 0, i.boxShadow = "0 0 12pt rgba(0,0,0,0.25)", i.borderRadius = "2px", i.overflow = "hidden", i.willChange = "width, height, opacity", i.pointerEvents = "auto", i.transition = this.DEFAULT_TRANSITION, t.visible = !1, t.changeSize = function (e, t) {
                e && (this.style.width = e + "px"), t && (this.style.height = t + "px")
            }, t.show = function () {
                this.style.opacity = 1, this.style.visibility = "visible", this.visible = !0
            }, t.hide = function () {
                this.style.opacity = 0, this.style.visibility = "hidden", this.visible = !1
            }, t.toggle = function () {
                this.visible ? this.hide() : this.show()
            }, t.slideAll = function (e) {
                for (var i = 0; i < t.children.length; i++) t.children[i].slide && t.children[i].slide(e)
            }, t.unslideAll = function () {
                for (var e = 0; e < t.children.length; e++) t.children[e].unslide && t.children[e].unslide()
            }, t.addHeader = function (t) {
                return (t = e.createMenuItemHeader(t)).type = "header", this.appendChild(t), t
            }, t.addItem = function (t) {
                return (t = e.createMenuItem(t)).type = "item", this.appendChild(t), t
            }, t.setActiveItem = function (e) {
                this.activeItem && this.activeItem.setIcon(" "), e.setIcon(M.Check), this.activeItem = e
            }, t.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, !0), t.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, !0), t.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, !0), t
        },
        createCustomItem: function (e) {
            var t = this,
                i = (e = void 0 === e ? {} : e).element || document.createElement("span"),
                n = e.onDispose;
            return i.style.cursor = "pointer", i.style.float = "right", i.style.width = "44px", i.style.height = "100%", i.style.backgroundSize = "60%", i.style.backgroundRepeat = "no-repeat", i.style.backgroundPosition = "center", i.style.webkitUserSelect = i.style.MozUserSelect = i.style.userSelect = "none", i.style.position = "relative", i.style.pointerEvents = "auto", i.addEventListener(t.TOUCH_ENABLED ? "touchstart" : "mouseenter", (function () {
                i.style.filter = i.style.webkitFilter = "drop-shadow(0 0 5px rgba(255,255,255,1))"
            }), {
                passive: !0
            }), i.addEventListener(t.TOUCH_ENABLED ? "touchend" : "mouseleave", (function () {
                i.style.filter = i.style.webkitFilter = ""
            }), {
                passive: !0
            }), this.mergeStyleOptions(i, e.style), e.onTap && i.addEventListener(t.TOUCH_ENABLED ? "touchend" : "click", e.onTap, !1), i.dispose = function () {
                i.removeEventListener(t.TOUCH_ENABLED ? "touchend" : "click", e.onTap, !1), n && e.onDispose()
            }, i
        },
        mergeStyleOptions: function (e, t) {
            for (var i in t = void 0 === t ? {} : t) t.hasOwnProperty(i) && (e.style[i] = t[i]);
            return e
        },
        dispose: function () {
            this.barElement && (this.container.removeChild(this.barElement), this.barElement.dispose(), this.barElement = null)
        }
    }), s.prototype = Object.assign(Object.create(t.Mesh.prototype), {
        constructor: s,
        add: function (e) {
            var i;
            if (1 < arguments.length) {
                for (i = 0; i < arguments.length; i++) this.add(arguments[i]);
                return this
            }
            if (e instanceof r) {
                if (i = e, e.dispatchEvent) {
                    var n = this.container;
                    n && e.dispatchEvent({
                        type: "panolens-container",
                        container: n
                    }), e.dispatchEvent({
                        type: "panolens-infospot-focus",
                        method: function (e, t, i) {
                            this.dispatchEvent({
                                type: "panolens-viewer-handler",
                                method: "tweenControlCenter",
                                data: [e, t, i]
                            })
                        }.bind(this)
                    })
                }
            } else(i = new t.Object3D).scale.x = -1, i.scalePlaceHolder = !0, i.add(e);
            t.Object3D.prototype.add.call(this, i)
        },
        load: function () {
            this.onLoad()
        },
        onClick: function (e) {
            e.intersects && 0 === e.intersects.length && this.traverse((function (e) {
                e.dispatchEvent({
                    type: "dismiss"
                })
            }))
        },
        setContainer: function (e) {
            if (e instanceof HTMLElement) var t = e;
            else e && e.container && (t = e.container);
            t && (this.children.forEach((function (e) {
                e instanceof r && e.dispatchEvent && e.dispatchEvent({
                    type: "panolens-container",
                    container: t
                })
            })), this.container = t)
        },
        onLoad: function () {
            this.loaded = !0, this.dispatchEvent({
                type: "load"
            })
        },
        onProgress: function (e) {
            this.dispatchEvent({
                type: "progress",
                progress: e
            })
        },
        onError: function () {
            this.dispatchEvent({
                type: "error"
            })
        },
        getZoomLevel: function () {
            return 800 >= window.innerWidth ? this.ImageQualityFair : 800 < window.innerWidth && 1280 >= window.innerWidth ? this.ImageQualityMedium : 1280 < window.innerWidth && 1920 >= window.innerWidth ? this.ImageQualityHigh : 1920 < window.innerWidth ? this.ImageQualitySuperHigh : this.ImageQualityLow
        },
        updateTexture: function (e) {
            this.material.map = e, this.material.needsUpdate = !0
        },
        toggleInfospotVisibility: function (e, t) {
            t = void 0 !== t ? t : 0;
            var i = void 0 !== e ? e : !this.isInfospotVisible;
            this.traverse((function (e) {
                e instanceof r && (i ? e.show(t) : e.hide(t))
            })), this.isInfospotVisible = i, this.infospotAnimation.onComplete(function () {
                this.dispatchEvent({
                    type: "infospot-animation-complete",
                    visible: i
                })
            }.bind(this)).delay(t).start()
        },
        setLinkingImage: function (e, t) {
            this.linkingImageURL = e, this.linkingImageScale = t
        },
        link: function (e, t, i, n) {
            this.visible = !0, t ? ((n = new r(i = void 0 !== i ? i : void 0 !== e.linkingImageScale ? e.linkingImageScale : 300, n = n || (e.linkingImageURL ? e.linkingImageURL : M.Arrow))).position.copy(t), n.toPanorama = e, n.addEventListener("click", function () {
                this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "setPanorama",
                    data: e
                })
            }.bind(this)), this.linkedSpots.push(n), this.add(n), this.visible = !1) : console.warn("Please specify infospot position for linking")
        },
        reset: function () {
            this.children.length = 0
        },
        setupTransitions: function () {
            this.fadeInAnimation = new L.Tween(this.material).easing(L.Easing.Quartic.Out).onStart(function () {
                this.visible = !0, this.dispatchEvent({
                    type: "enter-fade-start"
                })
            }.bind(this)), this.fadeOutAnimation = new L.Tween(this.material).easing(L.Easing.Quartic.Out).onComplete(function () {
                this.visible = !1, this.dispatchEvent({
                    type: "leave-complete"
                })
            }.bind(this)), this.enterTransition = new L.Tween(this).easing(L.Easing.Quartic.Out).onComplete(function () {
                this.dispatchEvent({
                    type: "enter-complete"
                })
            }.bind(this)).start(), this.leaveTransition = new L.Tween(this).easing(L.Easing.Quartic.Out)
        },
        onFadeAnimationUpdate: function () {
            var e = this.material.opacity,
                t = this.material.uniforms;
            t && t.opacity && (t.opacity.value = e)
        },
        fadeIn: function (e) {
            e = 0 <= e ? e : this.animationDuration, this.fadeOutAnimation.stop(), this.fadeInAnimation.to({
                opacity: 1
            }, e).onUpdate(this.onFadeAnimationUpdate.bind(this)).onComplete(function () {
                this.toggleInfospotVisibility(!0, e / 2), this.dispatchEvent({
                    type: "enter-fade-complete"
                })
            }.bind(this)).start()
        },
        fadeOut: function (e) {
            e = 0 <= e ? e : this.animationDuration, this.fadeInAnimation.stop(), this.fadeOutAnimation.to({
                opacity: 0
            }, e).onUpdate(this.onFadeAnimationUpdate.bind(this)).start()
        },
        onEnter: function () {
            var e = this.animationDuration;
            this.leaveTransition.stop(), this.enterTransition.to({}, e).onStart(function () {
                this.dispatchEvent({
                    type: "enter-start"
                }), this.loaded ? this.fadeIn(e) : this.load()
            }.bind(this)).start(), this.dispatchEvent({
                type: "enter"
            }), this.children.forEach((function (e) {
                e.dispatchEvent({
                    type: "panorama-enter"
                })
            })), this.active = !0
        },
        onLeave: function () {
            var e = this.animationDuration;
            this.enterTransition.stop(), this.leaveTransition.to({}, e).onStart(function () {
                this.dispatchEvent({
                    type: "leave-start"
                }), this.fadeOut(e), this.toggleInfospotVisibility(!1)
            }.bind(this)).start(), this.dispatchEvent({
                type: "leave"
            }), this.children.forEach((function (e) {
                e.dispatchEvent({
                    type: "panorama-leave"
                })
            })), this.active = !1
        },
        dispose: function () {
            this.infospotAnimation.stop(), this.fadeInAnimation.stop(), this.fadeOutAnimation.stop(), this.enterTransition.stop(), this.leaveTransition.stop(), this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "onPanoramaDispose",
                    data: this
                }),
                function e(t) {
                    for (var i = t.geometry, n = t.material, o = t.children.length - 1; 0 <= o; o--) e(t.children[o]), t.remove(t.children[o]);
                    t instanceof r && t.dispose(), i && (i.dispose(), t.geometry = null), n && (n.dispose(), t.material = null)
                }(this), this.parent && this.parent.remove(this)
        }
    }), a.prototype = Object.assign(Object.create(s.prototype), {
        constructor: a,
        load: function (e) {
            (e = e || this.src) ? "string" == typeof e ? T.load(e, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this)) : e instanceof HTMLImageElement && this.onLoad(new t.Texture(e)): console.warn("Image source undefined")
        },
        onLoad: function (e) {
            e.minFilter = e.magFilter = t.LinearFilter, e.needsUpdate = !0, this.updateTexture(e), window.requestAnimationFrame(s.prototype.onLoad.bind(this))
        },
        reset: function () {
            s.prototype.reset.call(this)
        },
        dispose: function () {
            var e = this.material.map;
            t.Cache.remove(this.src), e && e.dispose(), s.prototype.dispose.call(this)
        }
    }), l.prototype = Object.assign(Object.create(s.prototype), {
        constructor: l
    }), c.prototype = Object.assign(Object.create(s.prototype), {
        constructor: c,
        load: function () {
            A.load(this.images, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this))
        },
        onLoad: function (e) {
            this.material.uniforms.tCube.value = e, s.prototype.onLoad.call(this)
        },
        dispose: function () {
            var e = this.material.uniforms.tCube.value;
            this.images.forEach((function (e) {
                t.Cache.remove(e)
            })), e instanceof t.CubeTexture && e.dispose(), s.prototype.dispose.call(this)
        }
    }), u.prototype = Object.assign(Object.create(c.prototype), {
        constructor: u
    }), h.prototype = Object.assign(Object.create(s.prototype), {
        constructor: h,
        isMobile: function () {
            var e = !1,
                t = window.navigator.userAgent || window.navigator.vendor || window.opera;
            return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0), e
        },
        load: function () {
            var e = this.options,
                t = e.muted,
                i = e.loop,
                n = e.autoplay,
                r = e.playsinline;
            e = e.crossOrigin;
            var o = this.videoElement,
                s = this.material,
                a = this.onProgress.bind(this),
                l = this.onLoad.bind(this);
            o.loop = i, o.autoplay = n, o.playsinline = r, o.crossOrigin = e, o.muted = t, r && (o.setAttribute("playsinline", ""), o.setAttribute("webkit-playsinline", "")), r = function () {
                this.setVideoTexture(o), n && this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "updateVideoPlayButton",
                    data: !1
                }), this.isMobile() && (o.pause(), n && t ? this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "updateVideoPlayButton",
                    data: !1
                }) : this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "updateVideoPlayButton",
                    data: !0
                })), window.requestAnimationFrame((function () {
                    s.map.needsUpdate = !0, a({
                        loaded: 1,
                        total: 1
                    }), l()
                }))
            }, 2 < o.readyState ? r.call(this) : (0 === o.querySelectorAll("source").length && ((e = document.createElement("source")).src = this.src, o.appendChild(e)), o.load()), o.addEventListener("loadeddata", r.bind(this)), o.addEventListener("timeupdate", function () {
                this.videoProgress = 0 <= o.duration ? o.currentTime / o.duration : 0, this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "onVideoUpdate",
                    data: this.videoProgress
                })
            }.bind(this)), o.addEventListener("ended", function () {
                i || (this.resetVideo(), this.dispatchEvent({
                    type: "panolens-viewer-handler",
                    method: "updateVideoPlayButton",
                    data: !0
                }))
            }.bind(this), !1)
        },
        setVideoTexture: function (e) {
            e && ((e = new t.VideoTexture(e)).minFilter = t.LinearFilter, e.magFilter = t.LinearFilter, e.format = t.RGBFormat, this.updateTexture(e))
        },
        reset: function () {
            this.videoElement = void 0, s.prototype.reset.call(this)
        },
        isVideoPaused: function () {
            return this.videoElement.paused
        },
        toggleVideo: function () {
            var e = this.videoElement;
            e && e[e.paused ? "play" : "pause"]()
        },
        setVideoCurrentTime: function (e) {
            e = e.percentage;
            var t = this.videoElement;
            t && !Number.isNaN(e) && 1 !== e && (t.currentTime = t.duration * e, this.dispatchEvent({
                type: "panolens-viewer-handler",
                method: "onVideoUpdate",
                data: e
            }))
        },
        playVideo: function () {
            var e = this.videoElement,
                t = this.playVideo.bind(this),
                i = this.dispatchEvent.bind(this);
            e && e.paused && e.play().then((function () {
                i({
                    type: "play"
                })
            })).catch((function (e) {
                window.requestAnimationFrame(t), i({
                    type: "play-error",
                    error: e
                })
            }))
        },
        pauseVideo: function () {
            var e = this.videoElement;
            e && !e.paused && e.pause(), this.dispatchEvent({
                type: "pause"
            })
        },
        resumeVideoProgress: function () {
            var e = this.videoElement;
            4 <= e.readyState && e.autoplay && !this.isMobile() ? (this.playVideo(), this.dispatchEvent({
                type: "panolens-viewer-handler",
                method: "updateVideoPlayButton",
                data: !1
            })) : (this.pauseVideo(), this.dispatchEvent({
                type: "panolens-viewer-handler",
                method: "updateVideoPlayButton",
                data: !0
            })), this.setVideoCurrentTime({
                percentage: this.videoProgress
            })
        },
        resetVideo: function () {
            this.videoElement && this.setVideoCurrentTime({
                percentage: 0
            })
        },
        isVideoMuted: function () {
            return this.videoElement.muted
        },
        muteVideo: function () {
            var e = this.videoElement;
            e && !e.muted && (e.muted = !0), this.dispatchEvent({
                type: "volumechange"
            })
        },
        unmuteVideo: function () {
            var e = this.videoElement;
            e && this.isVideoMuted() && (e.muted = !1), this.dispatchEvent({
                type: "volumechange"
            })
        },
        getVideoElement: function () {
            return this.videoElement
        },
        dispose: function () {
            var e = this.material.map;
            this.pauseVideo(), this.removeEventListener("leave", this.pauseVideo.bind(this)), this.removeEventListener("enter-fade-start", this.resumeVideoProgress.bind(this)), this.removeEventListener("video-toggle", this.toggleVideo.bind(this)), this.removeEventListener("video-time", this.setVideoCurrentTime.bind(this)), e && e.dispose(), s.prototype.dispose.call(this)
        }
    }), Object.assign(d.prototype, {
        constructor: d,
        setProgress: function (e, t) {
            this.onProgress && this.onProgress({
                loaded: e,
                total: t
            })
        },
        adaptTextureToZoom: function () {
            var e = this.widths[this._zoom],
                t = this.heights[this._zoom],
                i = this.maxW,
                n = this.maxH;
            this._wc = Math.ceil(e / i), this._hc = Math.ceil(t / n);
            for (var r = 0; r < this._hc; r++)
                for (var o = 0; o < this._wc; o++) {
                    var s = document.createElement("canvas");
                    s.width = o < this._wc - 1 ? i : e - i * o, s.height = r < this._hc - 1 ? n : t - n * r, this._canvas.push(s), this._ctx.push(s.getContext("2d"))
                }
        },
        composeFromTile: function (e, t, i) {
            var n = this.maxW,
                r = this.maxH;
            e *= 512, t *= 512;
            var o = Math.floor(e / n),
                s = Math.floor(t / r);
            this._ctx[s * this._wc + o].drawImage(i, 0, 0, i.width, i.height, e - o * n, t - s * r, 512, 512), this.progress()
        },
        progress: function () {
            this._count++, this.setProgress(this._count, this._total), this._count === this._total && (this.canvas = this._canvas, this.panoId = this._panoId, this.zoom = this._zoom, this.onPanoramaLoad) && this.onPanoramaLoad(this._canvas[0])
        },
        composePanorama: function () {
            this.setProgress(0, 1);
            var e = this.levelsW[this._zoom],
                t = this.levelsH[this._zoom],
                i = this;
            this._count = 0, this._total = e * t;
            for (var n = this._parameters.useWebGL, r = 0; r < t; r++)
                for (var o = {}, s = 0; s < e; o = {
                        $jscomp$loop$prop$url$1: o.$jscomp$loop$prop$url$1
                    }, s++) o.$jscomp$loop$prop$url$1 = "https://geo0.ggpht.com/cbk?cb_client=maps_sv.tactile&authuser=0&hl=en&output=tile&zoom=" + this._zoom + "&x=" + s + "&y=" + r + "&panoid=" + this._panoId + "&nbt&fover=2",
                    function (e) {
                        return function (t, r) {
                            if (n) var o = T.load(e.$jscomp$loop$prop$url$1, null, (function () {
                                i.composeFromTile(t, r, o)
                            }));
                            else {
                                var s = new Image;
                                s.addEventListener("load", (function () {
                                    i.composeFromTile(t, r, this)
                                })), s.crossOrigin = "", s.src = e.$jscomp$loop$prop$url$1
                            }
                        }
                    }(o)(s, r)
        },
        load: function (e) {
            this.loadPano(e)
        },
        loadPano: function (e) {
            var t = this;
            this._panoClient.getPanoramaById(e, (function (e, i) {
                i === google.maps.StreetViewStatus.OK && (t.result = e, t.copyright = e.copyright, t._panoId = e.location.pano, t.composePanorama())
            }))
        },
        setZoom: function (e) {
            this._zoom = e, this.adaptTextureToZoom()
        }
    }), p.prototype = Object.assign(Object.create(a.prototype), {
        constructor: p,
        load: function (e) {
            this.loadRequested = !0, e = e || this.panoId || {}, this.gsvLoader && this.loadGSVLoader(e)
        },
        setupGoogleMapAPI: function (e) {
            var t = document.createElement("script");
            t.src = "https://maps.googleapis.com/maps/api/js?", t.src += e ? "key=" + e : "", t.onreadystatechange = this.setGSVLoader.bind(this), t.onload = this.setGSVLoader.bind(this), document.querySelector("head").appendChild(t)
        },
        setGSVLoader: function () {
            this.gsvLoader = new d, this.loadRequested && this.load()
        },
        getGSVLoader: function () {
            return this.gsvLoader
        },
        loadGSVLoader: function (e) {
            this.loadRequested = !1, this.gsvLoader.onProgress = this.onProgress.bind(this), this.gsvLoader.onPanoramaLoad = this.onLoad.bind(this), this.gsvLoader.setZoom(this.getZoomLevel()), this.gsvLoader.load(e), this.gsvLoader.loaded = !0
        },
        onLoad: function (e) {
            a.prototype.onLoad.call(this, new t.Texture(e))
        },
        reset: function () {
            this.gsvLoader = void 0, a.prototype.reset.call(this)
        }
    });
    var P = {
        uniforms: {
            tDiffuse: {
                value: new t.Texture
            },
            resolution: {
                value: 1
            },
            transform: {
                value: new t.Matrix4
            },
            zoom: {
                value: 1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = vec4( position, 1.0 );\n}",
        fragmentShader: "uniform sampler2D tDiffuse;\nuniform float resolution;\nuniform mat4 transform;\nuniform float zoom;\nuniform float opacity;\nvarying vec2 vUv;\nconst float PI = 3.141592653589793;\nvoid main(){\nvec2 position = -1.0 +  2.0 * vUv;\nposition *= vec2( zoom * resolution, zoom * 0.5 );\nfloat x2y2 = position.x * position.x + position.y * position.y;\nvec3 sphere_pnt = vec3( 2. * position, x2y2 - 1. ) / ( x2y2 + 1. );\nsphere_pnt = vec3( transform * vec4( sphere_pnt, 1.0 ) );\nvec2 sampleUV = vec2(\n(atan(sphere_pnt.y, sphere_pnt.x) / PI + 1.0) * 0.5,\n(asin(sphere_pnt.z) / PI + 0.5)\n);\ngl_FragColor = texture2D( tDiffuse, sampleUV );\ngl_FragColor.a *= opacity;\n}"
    };
    f.prototype = Object.assign(Object.create(a.prototype), {
        constructor: f,
        add: function (e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            e instanceof r && (e.material.depthTest = !1), a.prototype.add.call(this, e)
        },
        createGeometry: function (e, i) {
            return new t.PlaneBufferGeometry(e, e * i)
        },
        createMaterial: function (e) {
            var i = Object.assign({}, P),
                n = i.uniforms;
            return n.zoom.value = e, n.opacity.value = 0, new t.ShaderMaterial({
                uniforms: n,
                vertexShader: i.vertexShader,
                fragmentShader: i.fragmentShader,
                side: t.BackSide,
                transparent: !0
            })
        },
        registerMouseEvents: function () {
            this.container.addEventListener("mousedown", this.onMouseDown.bind(this), {
                passive: !0
            }), this.container.addEventListener("mousemove", this.onMouseMove.bind(this), {
                passive: !0
            }), this.container.addEventListener("mouseup", this.onMouseUp.bind(this), {
                passive: !0
            }), this.container.addEventListener("touchstart", this.onMouseDown.bind(this), {
                passive: !0
            }), this.container.addEventListener("touchmove", this.onMouseMove.bind(this), {
                passive: !0
            }), this.container.addEventListener("touchend", this.onMouseUp.bind(this), {
                passive: !0
            }), this.container.addEventListener("mousewheel", this.onMouseWheel.bind(this), {
                passive: !1
            }), this.container.addEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), {
                passive: !1
            }), this.container.addEventListener("contextmenu", this.onContextMenu.bind(this), {
                passive: !0
            })
        },
        unregisterMouseEvents: function () {
            this.container.removeEventListener("mousedown", this.onMouseDown.bind(this), !1), this.container.removeEventListener("mousemove", this.onMouseMove.bind(this), !1), this.container.removeEventListener("mouseup", this.onMouseUp.bind(this), !1), this.container.removeEventListener("touchstart", this.onMouseDown.bind(this), !1), this.container.removeEventListener("touchmove", this.onMouseMove.bind(this), !1), this.container.removeEventListener("touchend", this.onMouseUp.bind(this), !1), this.container.removeEventListener("mousewheel", this.onMouseWheel.bind(this), !1), this.container.removeEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), !1), this.container.removeEventListener("contextmenu", this.onContextMenu.bind(this), !1)
        },
        onMouseDown: function (e) {
            switch (e.touches && e.touches.length || 1) {
                case 1:
                    var t = 0 <= e.clientX ? e.clientX : e.touches[0].clientX;
                    e = 0 <= e.clientY ? e.clientY : e.touches[0].clientY, this.dragging = !0, this.userMouse.set(t, e);
                    break;
                case 2:
                    t = e.touches[0].pageX - e.touches[1].pageX, e = e.touches[0].pageY - e.touches[1].pageY, this.userMouse.pinchDistance = Math.sqrt(t * t + e * e)
            }
            this.onUpdateCallback()
        },
        onMouseMove: function (e) {
            switch (e.touches && e.touches.length || 1) {
                case 1:
                    var i = 0 <= e.clientX ? e.clientX : e.touches[0].clientX;
                    e = 0 <= e.clientY ? e.clientY : e.touches[0].clientY;
                    var n = .4 * t.Math.degToRad(i - this.userMouse.x),
                        r = .4 * t.Math.degToRad(e - this.userMouse.y);
                    this.dragging && (this.quatA.setFromAxisAngle(this.vectorY, n), this.quatB.setFromAxisAngle(this.vectorX, r), this.quatCur.multiply(this.quatA).multiply(this.quatB), this.userMouse.set(i, e));
                    break;
                case 2:
                    i = e.touches[0].pageX - e.touches[1].pageX, e = e.touches[0].pageY - e.touches[1].pageY, this.addZoomDelta(this.userMouse.pinchDistance - Math.sqrt(i * i + e * e))
            }
        },
        onMouseUp: function () {
            this.dragging = !1
        },
        onMouseWheel: function (e) {
            e.preventDefault(), e.stopPropagation();
            var t = 0;
            void 0 !== e.wheelDelta ? t = e.wheelDelta : void 0 !== e.detail && (t = -e.detail), this.addZoomDelta(t), this.onUpdateCallback()
        },
        addZoomDelta: function (e) {
            var t = this.material.uniforms,
                i = .1 * this.size,
                n = 10 * this.size;
            t.zoom.value += e, t.zoom.value <= i ? t.zoom.value = i : t.zoom.value >= n && (t.zoom.value = n)
        },
        onUpdateCallback: function () {
            this.frameId = window.requestAnimationFrame(this.onUpdateCallback.bind(this)), this.quatSlerp.slerp(this.quatCur, .1), this.material && this.material.uniforms.transform.value.makeRotationFromQuaternion(this.quatSlerp), !this.dragging && 1 - this.quatSlerp.clone().dot(this.quatCur) < this.EPS && window.cancelAnimationFrame(this.frameId)
        },
        reset: function () {
            this.quatCur.set(0, 0, 0, 1), this.quatSlerp.set(0, 0, 0, 1), this.onUpdateCallback()
        },
        onLoad: function (e) {
            this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight, this.registerMouseEvents(), this.onUpdateCallback(), this.dispatchEvent({
                type: "panolens-viewer-handler",
                method: "disableControl"
            }), a.prototype.onLoad.call(this, e)
        },
        onLeave: function () {
            this.unregisterMouseEvents(), this.dispatchEvent({
                type: "panolens-viewer-handler",
                method: "enableControl",
                data: _.ORBIT
            }), window.cancelAnimationFrame(this.frameId), a.prototype.onLeave.call(this)
        },
        onWindowResize: function () {
            this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight
        },
        onContextMenu: function () {
            this.dragging = !1
        },
        dispose: function () {
            this.unregisterMouseEvents(), a.prototype.dispose.call(this)
        }
    }), m.prototype = Object.assign(Object.create(f.prototype), {
        constructor: m,
        onLoad: function (e) {
            this.updateTexture(e), f.prototype.onLoad.call(this, e)
        },
        updateTexture: function (e) {
            e.minFilter = e.magFilter = t.LinearFilter, this.material.uniforms.tDiffuse.value = e
        },
        dispose: function () {
            var e = this.material.uniforms.tDiffuse;
            e && e.value && e.value.dispose(), f.prototype.dispose.call(this)
        }
    }), g.prototype = Object.assign(Object.create(s.prototype), {
        constructor: g,
        onPanolensContainer: function (e) {
            this.media.setContainer(e.container)
        },
        onPanolensScene: function (e) {
            this.media.setScene(e.scene)
        },
        start: function () {
            return this.media.start()
        },
        stop: function () {
            this.media.stop()
        }
    }), v.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
        constructor: v
    }), y.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
        constructor: y
    });
    var I = function (e) {
        var i = new t.StereoCamera;
        i.aspect = .5;
        var n = new t.Vector2;
        this.setEyeSeparation = function (e) {
            i.eyeSep = e
        }, this.setSize = function (t, i) {
            e.setSize(t, i)
        }, this.render = function (t, r) {
            t.updateMatrixWorld(), null === r.parent && r.updateMatrixWorld(), i.update(r), e.getSize(n), e.autoClear && e.clear(), e.setScissorTest(!0), e.setScissor(0, 0, n.width / 2, n.height), e.setViewport(0, 0, n.width / 2, n.height), e.render(t, i.cameraL), e.setScissor(n.width / 2, 0, n.width / 2, n.height), e.setViewport(n.width / 2, 0, n.width / 2, n.height), e.render(t, i.cameraR), e.setScissorTest(!1)
        }
    };
    x.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
        constructor: x,
        add: function (e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            this.scene.add(e), e.addEventListener && e.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), e instanceof s && e.dispatchEvent && e.dispatchEvent({
                type: "panolens-container",
                container: this.container
            }), e instanceof g && e.dispatchEvent({
                type: "panolens-scene",
                scene: this.scene
            }), "panorama" === e.type && (this.addPanoramaEventListener(e), this.panorama || this.setPanorama(e))
        },
        remove: function (e) {
            e.removeEventListener && e.removeEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), this.scene.remove(e)
        },
        addDefaultControlBar: function (e) {
            if (this.widget) console.warn("Default control bar exists");
            else {
                var t = new o(this.container);
                t.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), t.addControlBar(), e.forEach((function (e) {
                    t.addControlButton(e)
                })), this.widget = t
            }
        },
        setPanorama: function (e) {
            var t = this.panorama;
            if ("panorama" === e.type && t !== e) {
                this.hideInfospot();
                var i = function () {
                    t && t.onLeave(), e.removeEventListener("enter-fade-start", i)
                };
                e.addEventListener("enter-fade-start", i), (this.panorama = e).onEnter()
            }
        },
        eventHandler: function (e) {
            e.method && this[e.method] && this[e.method](e.data)
        },
        dispatchEventToChildren: function (e) {
            this.scene.traverse((function (t) {
                t.dispatchEvent && t.dispatchEvent(e)
            }))
        },
        activateWidgetItem: function (e, t) {
            var i = this.widget.mainMenu,
                n = i.children[0];
            if (i = i.children[1], void 0 !== e) {
                switch (e) {
                    case 0:
                        e = n.subMenu.children[1];
                        break;
                    case 1:
                        e = n.subMenu.children[2];
                        break;
                    default:
                        e = n.subMenu.children[1]
                }
                n.subMenu.setActiveItem(e), n.setSelectionTitle(e.textContent)
            }
            if (void 0 !== t) {
                switch (t) {
                    case E.CARDBOARD:
                        e = i.subMenu.children[2];
                        break;
                    case E.STEREO:
                        e = i.subMenu.children[3];
                        break;
                    default:
                        e = i.subMenu.children[1]
                }
                i.subMenu.setActiveItem(e), i.setSelectionTitle(e.textContent)
            }
        },
        enableEffect: function (e) {
            if (this.mode !== e)
                if (e === E.NORMAL) this.disableEffect();
                else {
                    this.mode = e;
                    var t = this.camera.fov;
                    switch (e) {
                        case E.CARDBOARD:
                            this.effect = this.CardboardEffect, this.enableReticleControl();
                            break;
                        case E.STEREO:
                            this.effect = this.StereoEffect, this.enableReticleControl();
                            break;
                        default:
                            this.effect = null, this.disableReticleControl()
                    }
                    this.activateWidgetItem(void 0, this.mode), this.dispatchEventToChildren({
                        type: "panolens-dual-eye-effect",
                        mode: this.mode
                    }), this.camera.fov = t + .01, this.effect.setSize(this.container.clientWidth, this.container.clientHeight), this.render(), this.camera.fov = t, this.dispatchEvent({
                        type: "mode-change",
                        mode: this.mode
                    })
                }
        },
        disableEffect: function () {
            this.mode !== E.NORMAL && (this.mode = E.NORMAL, this.disableReticleControl(), this.activateWidgetItem(void 0, this.mode), this.dispatchEventToChildren({
                type: "panolens-dual-eye-effect",
                mode: this.mode
            }), this.renderer.setSize(this.container.clientWidth, this.container.clientHeight), this.render(), this.dispatchEvent({
                type: "mode-change",
                mode: this.mode
            }))
        },
        enableReticleControl: function () {
            this.reticle.visible || (this.tempEnableReticle = !0, this.unregisterMouseAndTouchEvents(), this.reticle.show(), this.registerReticleEvent(), this.updateReticleEvent())
        },
        disableReticleControl: function () {
            this.tempEnableReticle = !1, this.options.enableReticle ? this.updateReticleEvent() : (this.reticle.hide(), this.unregisterReticleEvent(), this.registerMouseAndTouchEvents())
        },
        enableAutoRate: function () {
            this.options.autoRotate = !0, this.OrbitControls.autoRotate = !0
        },
        disableAutoRate: function () {
            clearTimeout(this.autoRotateRequestId), this.options.autoRotate = !1, this.OrbitControls.autoRotate = !1
        },
        toggleVideoPlay: function (e) {
            this.panorama instanceof h && this.panorama.dispatchEvent({
                type: "video-toggle",
                pause: e
            })
        },
        setVideoCurrentTime: function (e) {
            this.panorama instanceof h && this.panorama.dispatchEvent({
                type: "video-time",
                percentage: e
            })
        },
        onVideoUpdate: function (e) {
            var t = this.widget;
            t && t.dispatchEvent({
                type: "video-update",
                percentage: e
            })
        },
        addUpdateCallback: function (e) {
            e && this.updateCallbacks.push(e)
        },
        removeUpdateCallback: function (e) {
            var t = this.updateCallbacks.indexOf(e);
            e && 0 <= t && this.updateCallbacks.splice(t, 1)
        },
        showVideoWidget: function () {
            var e = this.widget;
            e && e.dispatchEvent({
                type: "video-control-show"
            })
        },
        hideVideoWidget: function () {
            var e = this.widget;
            e && e.dispatchEvent({
                type: "video-control-hide"
            })
        },
        updateVideoPlayButton: function (e) {
            var t = this.widget;
            t && t.videoElement && t.videoElement.controlButton && t.videoElement.controlButton.update(e)
        },
        addPanoramaEventListener: function (e) {
            e.addEventListener("enter-fade-start", this.setCameraControl.bind(this)), e instanceof h && (e.addEventListener("enter-fade-start", this.showVideoWidget.bind(this)), e.addEventListener("leave", function () {
                this.panorama instanceof h || this.hideVideoWidget.call(this)
            }.bind(this)))
        },
        setCameraControl: function () {
            this.OrbitControls.target.copy(this.panorama.position)
        },
        getControl: function () {
            return this.control
        },
        getScene: function () {
            return this.scene
        },
        getCamera: function () {
            return this.camera
        },
        getRenderer: function () {
            return this.renderer
        },
        getContainer: function () {
            return this.container
        },
        getControlId: function () {
            return this.control.id
        },
        getNextControlId: function () {
            return this.controls[this.getNextControlIndex()].id
        },
        getNextControlIndex: function () {
            var e = this.controls,
                t = e.indexOf(this.control) + 1;
            return t >= e.length ? 0 : t
        },
        setCameraFov: function (e) {
            this.camera.fov = e, this.camera.updateProjectionMatrix()
        },
        enableControl: function (e) {
            switch (e = 0 <= e && e < this.controls.length ? e : 0, this.control.enabled = !1, this.control = this.controls[e], this.control.enabled = !0, e) {
                case _.ORBIT:
                    this.camera.position.copy(this.panorama.position), this.camera.position.z += 1;
                    break;
                case _.DEVICEORIENTATION:
                    this.camera.position.copy(this.panorama.position)
            }
            this.control.update(), this.activateWidgetItem(e, void 0)
        },
        disableControl: function () {
            this.control.enabled = !1
        },
        toggleNextControl: function () {
            this.enableControl(this.getNextControlIndex())
        },
        getScreenVector: function (e) {
            e = e.clone();
            var t = this.container.clientWidth / 2,
                i = this.container.clientHeight / 2;
            return e.project(this.camera), e.x = e.x * t + t, e.y = -e.y * i + i, e.z = 0, e
        },
        checkSpriteInViewport: function (e) {
            return this.camera.matrixWorldInverse.getInverse(this.camera.matrixWorld), this.cameraViewProjectionMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse), this.cameraFrustum.setFromMatrix(this.cameraViewProjectionMatrix), e.visible && this.cameraFrustum.intersectsSprite(e)
        },
        reverseDraggingDirection: function () {
            this.OrbitControls.rotateSpeed *= -1, this.OrbitControls.momentumScalingFactor *= -1
        },
        addReticle: function () {
            this.reticle = new n(16777215, !0, this.options.dwellTime), this.reticle.hide(), this.camera.add(this.reticle), this.sceneReticle.add(this.camera)
        },
        tweenControlCenter: function (e, i, n) {
            var r;
            if (this.control === this.OrbitControls) {
                e instanceof Array && (i = e[1], n = e[2], e = e[0]), i = void 0 !== i ? i : 1e3, n = n || L.Easing.Exponential.Out;
                var o = this,
                    s = this.camera.getWorldDirection(new t.Vector3),
                    a = s.clone(),
                    l = this.panorama.getWorldPosition(new t.Vector3).sub(this.camera.getWorldPosition(new t.Vector3));
                (e = e.clone()).x *= -1, e.add(l).normalize();
                var c = e.clone();
                s.y = 0, e.y = 0, l = (l = (l = Math.atan2(e.z, e.x) - Math.atan2(s.z, s.x)) > Math.PI ? l - 2 * Math.PI : l) < -Math.PI ? l + 2 * Math.PI : l, s = Math.abs(a.angleTo(s) + (0 >= a.y * c.y ? c.angleTo(e) : -c.angleTo(e))), s *= c.y < a.y ? 1 : -1, a = {
                    left: 0,
                    up: 0
                };
                var u = r = 0;
                this.tweenLeftAnimation.stop(), this.tweenUpAnimation.stop(), this.tweenLeftAnimation = new L.Tween(a).to({
                    left: l
                }, i).easing(n).onUpdate((function (e) {
                    o.control.rotateLeft(e.left - r), r = e.left
                })).start(), this.tweenUpAnimation = new L.Tween(a).to({
                    up: s
                }, i).easing(n).onUpdate((function (e) {
                    o.control.rotateUp(e.up - u), u = e.up
                })).start()
            }
        },
        tweenControlCenterByObject: function (e, i, n) {
            var r = !1;
            if (e.traverseAncestors((function (e) {
                    e.scalePlaceHolder && (r = !0)
                })), r) {
                var o = new t.Vector3(-1, 1, 1);
                this.tweenControlCenter(e.getWorldPosition(new t.Vector3).multiply(o), i, n)
            } else this.tweenControlCenter(e.getWorldPosition(new t.Vector3), i, n)
        },
        onWindowResize: function (e, t) {
            var i = this.container.classList.contains("panolens-container") || this.container.isFullscreen;
            if (void 0 !== e && void 0 !== t) {
                var n = e,
                    r = t;
                this.container._width = e, this.container._height = t
            } else e = (t = /(android)/i.test(window.navigator.userAgent)) ? Math.min(document.documentElement.clientWidth, window.innerWidth || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0), t = t ? Math.min(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientHeight, window.innerHeight || 0), n = i ? e : this.container.clientWidth, r = i ? t : this.container.clientHeight, this.container._width = n, this.container._height = r;
            this.camera.aspect = n / r, this.camera.updateProjectionMatrix(), this.renderer.setSize(n, r), (this.options.enableReticle || this.tempEnableReticle) && this.updateReticleEvent(), this.dispatchEvent({
                type: "window-resize",
                width: n,
                height: r
            }), this.scene.traverse((function (e) {
                e.dispatchEvent && e.dispatchEvent({
                    type: "window-resize",
                    width: n,
                    height: r
                })
            }))
        },
        addOutputElement: function () {
            var e = document.createElement("div");
            e.style.position = "absolute", e.style.right = "10px", e.style.top = "10px", e.style.color = "#fff", this.container.appendChild(e), this.outputDivElement = e
        },
        outputPosition: function () {
            var e = this.raycaster.intersectObject(this.panorama, !0);
            if (0 < e.length) {
                e = e[0].point.clone();
                var i = new t.Vector3(-1, 1, 1),
                    n = this.panorama.getWorldPosition(new t.Vector3);
                if (e.sub(n).multiply(i), i = e.x.toFixed(2) + ", " + e.y.toFixed(2) + ", " + e.z.toFixed(2), 0 !== e.length()) switch (this.options.output) {
                    case "console":
                        console.info(i);
                        break;
                    case "overlay":
                        this.outputDivElement.textContent = i
                }
            }
        },
        onMouseDown: function (e) {
            e.preventDefault(), this.userMouse.x = 0 <= e.clientX ? e.clientX : e.touches[0].clientX, this.userMouse.y = 0 <= e.clientY ? e.clientY : e.touches[0].clientY, this.userMouse.type = "mousedown", this.onTap(e)
        },
        onMouseMove: function (e) {
            e.preventDefault(), this.userMouse.type = "mousemove", this.onTap(e)
        },
        onMouseUp: function (e) {
            this.userMouse.type = "mouseup";
            var t = this.userMouse.x >= e.clientX - this.options.clickTolerance && this.userMouse.x <= e.clientX + this.options.clickTolerance && this.userMouse.y >= e.clientY - this.options.clickTolerance && this.userMouse.y <= e.clientY + this.options.clickTolerance || e.changedTouches && this.userMouse.x >= e.changedTouches[0].clientX - this.options.clickTolerance && this.userMouse.x <= e.changedTouches[0].clientX + this.options.clickTolerance && this.userMouse.y >= e.changedTouches[0].clientY - this.options.clickTolerance && this.userMouse.y <= e.changedTouches[0].clientY + this.options.clickTolerance ? "click" : void 0;
            if ((!e || !e.target || e.target.classList.contains("panolens-canvas")) && (e.preventDefault(), e = e.changedTouches && 1 === e.changedTouches.length ? this.onTap({
                    clientX: e.changedTouches[0].clientX,
                    clientY: e.changedTouches[0].clientY
                }, t) : this.onTap(e, t), this.userMouse.type = "none", !e && "click" === t)) {
                e = (t = this.options).autoHideControlBar;
                var i = this.panorama,
                    n = this.toggleControlBar;
                t.autoHideInfospot && i && i.toggleInfospotVisibility(), e && n()
            }
        },
        onTap: function (e, t) {
            var i = this.container.getBoundingClientRect(),
                n = i.top,
                o = this.container,
                s = o.clientHeight;
            if (this.raycasterPoint.x = (e.clientX - i.left) / o.clientWidth * 2 - 1, this.raycasterPoint.y = -(e.clientY - n) / s * 2 + 1, this.raycaster.setFromCamera(this.raycasterPoint, this.camera), this.panorama) {
                if (("mousedown" !== e.type && this.touchSupported || this.OUTPUT_INFOSPOT) && this.outputPosition(), i = this.raycaster.intersectObjects(this.panorama.children, !0), n = this.getConvertedIntersect(i), o = 0 < i.length ? i[0].object : void 0, "mouseup" === this.userMouse.type && (n && this.pressEntityObject === n && this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
                        type: "pressstop-entity",
                        mouseEvent: e
                    }), this.pressEntityObject = void 0), "mouseup" === this.userMouse.type && (o && this.pressObject === o && this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
                        type: "pressstop",
                        mouseEvent: e
                    }), this.pressObject = void 0), "click" === t ? (this.panorama.dispatchEvent({
                        type: "click",
                        intersects: i,
                        mouseEvent: e
                    }), n && n.dispatchEvent && n.dispatchEvent({
                        type: "click-entity",
                        mouseEvent: e
                    }), o && o.dispatchEvent && o.dispatchEvent({
                        type: "click",
                        mouseEvent: e
                    })) : (this.panorama.dispatchEvent({
                        type: "hover",
                        intersects: i,
                        mouseEvent: e
                    }), (this.hoverObject && 0 < i.length && this.hoverObject !== n || this.hoverObject && 0 === i.length) && (this.hoverObject.dispatchEvent && (this.hoverObject.dispatchEvent({
                        type: "hoverleave",
                        mouseEvent: e
                    }), this.reticle.end()), this.hoverObject = void 0), n && 0 < i.length && (this.hoverObject !== n && (this.hoverObject = n, this.hoverObject.dispatchEvent && (this.hoverObject.dispatchEvent({
                        type: "hoverenter",
                        mouseEvent: e
                    }), (this.options.autoReticleSelect && this.options.enableReticle || this.tempEnableReticle) && this.reticle.start(this.onTap.bind(this, e, "click")))), "mousedown" === this.userMouse.type && this.pressEntityObject != n && (this.pressEntityObject = n, this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
                        type: "pressstart-entity",
                        mouseEvent: e
                    })), "mousedown" === this.userMouse.type && this.pressObject != o && (this.pressObject = o, this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
                        type: "pressstart",
                        mouseEvent: e
                    })), "mousemove" === this.userMouse.type || this.options.enableReticle) && (o && o.dispatchEvent && o.dispatchEvent({
                        type: "hover",
                        mouseEvent: e
                    }), this.pressEntityObject && this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
                        type: "pressmove-entity",
                        mouseEvent: e
                    }), this.pressObject && this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
                        type: "pressmove",
                        mouseEvent: e
                    })), !n && this.pressEntityObject && this.pressEntityObject.dispatchEvent && (this.pressEntityObject.dispatchEvent({
                        type: "pressstop-entity",
                        mouseEvent: e
                    }), this.pressEntityObject = void 0), !o && this.pressObject && this.pressObject.dispatchEvent && (this.pressObject.dispatchEvent({
                        type: "pressstop",
                        mouseEvent: e
                    }), this.pressObject = void 0)), o && o instanceof r) {
                    if (this.infospot = o, "click" === t) return !0
                } else this.infospot && this.hideInfospot();
                this.options.autoRotate && "mousemove" !== this.userMouse.type && (clearTimeout(this.autoRotateRequestId), this.control === this.OrbitControls && (this.OrbitControls.autoRotate = !1, this.autoRotateRequestId = window.setTimeout(this.enableAutoRate.bind(this), this.options.autoRotateActivationDuration)))
            }
        },
        getConvertedIntersect: function (e) {
            for (var t, i = 0; i < e.length; i++)
                if (0 <= e[i].distance && e[i].object && !e[i].object.passThrough && (!e[i].object.entity || !e[i].object.entity.passThrough)) {
                    t = e[i].object.entity && !e[i].object.entity.passThrough ? e[i].object.entity : e[i].object;
                    break
                } return t
        },
        hideInfospot: function () {
            this.infospot && (this.infospot.onHoverEnd(), this.infospot = void 0)
        },
        toggleControlBar: function () {
            var e = this.widget;
            e && e.dispatchEvent({
                type: "control-bar-toggle"
            })
        },
        onKeyDown: function (e) {
            this.options.output && "none" !== this.options.output && "Control" === e.key && (this.OUTPUT_INFOSPOT = !0)
        },
        onKeyUp: function () {
            this.OUTPUT_INFOSPOT = !1
        },
        update: function () {
            L.update(), this.updateCallbacks.forEach((function (e) {
                e()
            })), this.control.update(), this.scene.traverse(function (e) {
                if (e instanceof r && e.element && (this.hoverObject === e || "none" !== e.element.style.display || e.element.left && "none" !== e.element.left.style.display || e.element.right && "none" !== e.element.right.style.display))
                    if (this.checkSpriteInViewport(e)) {
                        var i = this.getScreenVector(e.getWorldPosition(new t.Vector3));
                        e.translateElement(i.x, i.y)
                    } else e.onDismiss()
            }.bind(this))
        },
        render: function () {
            this.mode === E.CARDBOARD || this.mode === E.STEREO ? (this.renderer.clear(), this.effect.render(this.scene, this.camera), this.effect.render(this.sceneReticle, this.camera)) : (this.renderer.clear(), this.renderer.render(this.scene, this.camera), this.renderer.clearDepth(), this.renderer.render(this.sceneReticle, this.camera))
        },
        animate: function () {
            this.requestAnimationId = window.requestAnimationFrame(this.animate.bind(this)), this.onChange()
        },
        onChange: function () {
            this.update(), this.render()
        },
        registerMouseAndTouchEvents: function () {
            var e = {
                passive: !1
            };
            this.container.addEventListener("mousedown", this.HANDLER_MOUSE_DOWN, e), this.container.addEventListener("mousemove", this.HANDLER_MOUSE_MOVE, e), this.container.addEventListener("mouseup", this.HANDLER_MOUSE_UP, e), this.container.addEventListener("touchstart", this.HANDLER_MOUSE_DOWN, e), this.container.addEventListener("touchend", this.HANDLER_MOUSE_UP, e)
        },
        unregisterMouseAndTouchEvents: function () {
            this.container.removeEventListener("mousedown", this.HANDLER_MOUSE_DOWN, !1), this.container.removeEventListener("mousemove", this.HANDLER_MOUSE_MOVE, !1), this.container.removeEventListener("mouseup", this.HANDLER_MOUSE_UP, !1), this.container.removeEventListener("touchstart", this.HANDLER_MOUSE_DOWN, !1), this.container.removeEventListener("touchend", this.HANDLER_MOUSE_UP, !1)
        },
        registerReticleEvent: function () {
            this.addUpdateCallback(this.HANDLER_TAP)
        },
        unregisterReticleEvent: function () {
            this.removeUpdateCallback(this.HANDLER_TAP)
        },
        updateReticleEvent: function () {
            var e = this.container.clientWidth / 2 + this.container.offsetLeft,
                t = this.container.clientHeight / 2;
            this.removeUpdateCallback(this.HANDLER_TAP), this.HANDLER_TAP = this.onTap.bind(this, {
                clientX: e,
                clientY: t
            }), this.addUpdateCallback(this.HANDLER_TAP)
        },
        registerEventListeners: function () {
            window.addEventListener("resize", this.HANDLER_WINDOW_RESIZE, !0), window.addEventListener("keydown", this.HANDLER_KEY_DOWN, !0), window.addEventListener("keyup", this.HANDLER_KEY_UP, !0)
        },
        unregisterEventListeners: function () {
            window.removeEventListener("resize", this.HANDLER_WINDOW_RESIZE, !0), window.removeEventListener("keydown", this.HANDLER_KEY_DOWN, !0), window.removeEventListener("keyup", this.HANDLER_KEY_UP, !0)
        },
        dispose: function () {
            this.tweenLeftAnimation.stop(), this.tweenUpAnimation.stop(), this.unregisterEventListeners(),
                function e(t) {
                    for (var i = t.children.length - 1; 0 <= i; i--) e(t.children[i]), t.remove(t.children[i]);
                    t instanceof s || t instanceof r ? t.dispose() : t.dispatchEvent && t.dispatchEvent("dispose")
                }(this.scene), this.widget && (this.widget.dispose(), this.widget = null), t.Cache && t.Cache.enabled && t.Cache.clear()
        },
        destroy: function () {
            this.dispose(), this.render(), window.cancelAnimationFrame(this.requestAnimationId)
        },
        onPanoramaDispose: function (e) {
            e instanceof h && this.hideVideoWidget(), e === this.panorama && (this.panorama = null)
        },
        loadAsyncRequest: function (e, t) {
            t = void 0 === t ? function () {} : t;
            var i = new window.XMLHttpRequest;
            i.onloadend = function (e) {
                t(e)
            }, i.open("GET", e, !0), i.send(null)
        },
        addViewIndicator: function () {
            var e = this;
            this.loadAsyncRequest(M.ViewIndicator, (function (i) {
                if (0 !== i.loaded) {
                    (i = i.target.responseXML.documentElement).style.width = e.viewIndicatorSize + "px", i.style.height = e.viewIndicatorSize + "px", i.style.position = "absolute", i.style.top = "10px", i.style.left = "10px", i.style.opacity = "0.5", i.style.cursor = "pointer", i.id = "panolens-view-indicator-container", e.container.appendChild(i);
                    var n = i.querySelector("#indicator");
                    e.addUpdateCallback((function () {
                        e.radius = .225 * e.viewIndicatorSize, e.currentPanoAngle = e.camera.rotation.y - t.Math.degToRad(90), e.fovAngle = t.Math.degToRad(e.camera.fov), e.leftAngle = -e.currentPanoAngle - e.fovAngle / 2, e.rightAngle = -e.currentPanoAngle + e.fovAngle / 2, e.leftX = e.radius * Math.cos(e.leftAngle), e.leftY = e.radius * Math.sin(e.leftAngle), e.rightX = e.radius * Math.cos(e.rightAngle), e.rightY = e.radius * Math.sin(e.rightAngle), e.indicatorD = "M " + e.leftX + " " + e.leftY + " A " + e.radius + " " + e.radius + " 0 0 1 " + e.rightX + " " + e.rightY, e.leftX && e.leftY && e.rightX && e.rightY && e.radius && n.setAttribute("d", e.indicatorD)
                    })), i.addEventListener("mouseenter", (function () {
                        this.style.opacity = "1"
                    })), i.addEventListener("mouseleave", (function () {
                        this.style.opacity = "0.5"
                    }))
                }
            }))
        },
        appendControlItem: function (e) {
            var t = this.widget.createCustomItem(e);
            return "video" === e.group ? this.widget.videoElement.appendChild(t) : this.widget.barElement.appendChild(t), t
        },
        clearAllCache: function () {
            t.Cache.clear()
        }
    }), "105" != t.REVISION && console.warn("three.js version is not matched. Please consider use the target revision 105"), window.TWEEN = L, e.BasicPanorama = u, e.CONTROLS = _, e.CameraPanorama = g, e.CubePanorama = c, e.CubeTextureLoader = A, e.DataImage = M, e.EmptyPanorama = l, e.GoogleStreetviewPanorama = p, e.ImageLittlePlanet = m, e.ImageLoader = S, e.ImagePanorama = a, e.Infospot = r, e.LittlePlanet = f, e.MODES = E, e.Media = i, e.Panorama = s, e.REVISION = "11", e.Reticle = n, e.THREE_REVISION = "105", e.THREE_VERSION = w, e.TextureLoader = T, e.VERSION = "0.11.0", e.VideoPanorama = h, e.Viewer = x, e.Widget = o, Object.defineProperty(e, "__esModule", {
        value: !0
    })
}));
var Swiper = function () {
    "use strict";

    function e(e) {
        return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object
    }

    function t(i, n) {
        void 0 === i && (i = {}), void 0 === n && (n = {});
        const r = ["__proto__", "constructor", "prototype"];
        Object.keys(n).filter(e => r.indexOf(e) < 0).forEach(r => {
            void 0 === i[r] ? i[r] = n[r] : e(n[r]) && e(i[r]) && Object.keys(n[r]).length > 0 && t(i[r], n[r])
        })
    }
    const i = {
        body: {},
        addEventListener() {},
        removeEventListener() {},
        activeElement: {
            blur() {},
            nodeName: ""
        },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({
            initEvent() {}
        }),
        createElement: () => ({
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName: () => []
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        }
    };

    function n() {
        const e = "undefined" != typeof document ? document : {};
        return t(e, i), e
    }
    const r = {
        document: i,
        navigator: {
            userAgent: ""
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        },
        history: {
            replaceState() {},
            pushState() {},
            go() {},
            back() {}
        },
        CustomEvent: function () {
            return this
        },
        addEventListener() {},
        removeEventListener() {},
        getComputedStyle: () => ({
            getPropertyValue: () => ""
        }),
        Image() {},
        Date() {},
        screen: {},
        setTimeout() {},
        clearTimeout() {},
        matchMedia: () => ({}),
        requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
        cancelAnimationFrame(e) {
            "undefined" != typeof setTimeout && clearTimeout(e)
        }
    };

    function o() {
        const e = "undefined" != typeof window ? window : {};
        return t(e, r), e
    }

    function s(e) {
        return void 0 === e && (e = ""), e.trim().split(" ").filter(e => !!e.trim())
    }

    function a(e, t) {
        return void 0 === t && (t = 0), setTimeout(e, t)
    }

    function l() {
        return Date.now()
    }

    function c(e, t) {
        void 0 === t && (t = "x");
        const i = o();
        let n, r, s;
        const a = function (e) {
            const t = o();
            let i;
            return t.getComputedStyle && (i = t.getComputedStyle(e, null)), !i && e.currentStyle && (i = e.currentStyle), i || (i = e.style), i
        }(e);
        return i.WebKitCSSMatrix ? (r = a.transform || a.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map(e => e.replace(",", ".")).join(", ")), s = new i.WebKitCSSMatrix("none" === r ? "" : r)) : (s = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), n = s.toString().split(",")), "x" === t && (r = i.WebKitCSSMatrix ? s.m41 : 16 === n.length ? parseFloat(n[12]) : parseFloat(n[4])), "y" === t && (r = i.WebKitCSSMatrix ? s.m42 : 16 === n.length ? parseFloat(n[13]) : parseFloat(n[5])), r || 0
    }

    function u(e) {
        return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
    }

    function h() {
        const e = Object(arguments.length <= 0 ? void 0 : arguments[0]),
            t = ["__proto__", "constructor", "prototype"];
        for (let n = 1; n < arguments.length; n += 1) {
            const r = n < 0 || arguments.length <= n ? void 0 : arguments[n];
            if (null != r && (i = r, !("undefined" != typeof window && void 0 !== window.HTMLElement ? i instanceof HTMLElement : i && (1 === i.nodeType || 11 === i.nodeType)))) {
                const i = Object.keys(Object(r)).filter(e => t.indexOf(e) < 0);
                for (let t = 0, n = i.length; t < n; t += 1) {
                    const n = i[t],
                        o = Object.getOwnPropertyDescriptor(r, n);
                    void 0 !== o && o.enumerable && (u(e[n]) && u(r[n]) ? r[n].__swiper__ ? e[n] = r[n] : h(e[n], r[n]) : !u(e[n]) && u(r[n]) ? (e[n] = {}, r[n].__swiper__ ? e[n] = r[n] : h(e[n], r[n])) : e[n] = r[n])
                }
            }
        }
        var i;
        return e
    }

    function d(e, t, i) {
        e.style.setProperty(t, i)
    }

    function p(e) {
        let {
            swiper: t,
            targetPosition: i,
            side: n
        } = e;
        const r = o(),
            s = -t.translate;
        let a, l = null;
        const c = t.params.speed;
        t.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(t.cssModeFrameID);
        const u = i > s ? "next" : "prev",
            h = (e, t) => "next" === u && e >= t || "prev" === u && e <= t,
            d = () => {
                a = (new Date).getTime(), null === l && (l = a);
                const e = Math.max(Math.min((a - l) / c, 1), 0),
                    o = .5 - Math.cos(e * Math.PI) / 2;
                let u = s + o * (i - s);
                if (h(u, i) && (u = i), t.wrapperEl.scrollTo({
                        [n]: u
                    }), h(u, i)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
                    t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({
                        [n]: u
                    })
                }), void r.cancelAnimationFrame(t.cssModeFrameID);
                t.cssModeFrameID = r.requestAnimationFrame(d)
            };
        d()
    }

    function f(e) {
        return e.querySelector(".swiper-slide-transform") || e.shadowRoot && e.shadowRoot.querySelector(".swiper-slide-transform") || e
    }

    function m(e, t) {
        void 0 === t && (t = "");
        const i = o(),
            n = [...e.children];
        return i.HTMLSlotElement && e instanceof HTMLSlotElement && n.push(...e.assignedElements()), t ? n.filter(e => e.matches(t)) : n
    }

    function g(e) {
        try {
            return void console.warn(e)
        } catch (e) {}
    }

    function v(e, t) {
        void 0 === t && (t = []);
        const i = document.createElement(e);
        return i.classList.add(...Array.isArray(t) ? t : s(t)), i
    }

    function y(e) {
        const t = o(),
            i = n(),
            r = e.getBoundingClientRect(),
            s = i.body,
            a = e.clientTop || s.clientTop || 0,
            l = e.clientLeft || s.clientLeft || 0,
            c = e === t ? t.scrollY : e.scrollTop,
            u = e === t ? t.scrollX : e.scrollLeft;
        return {
            top: r.top + c - a,
            left: r.left + u - l
        }
    }

    function b(e, t) {
        return o().getComputedStyle(e, null).getPropertyValue(t)
    }

    function x(e) {
        let t, i = e;
        if (i) {
            for (t = 0; null !== (i = i.previousSibling);) 1 === i.nodeType && (t += 1);
            return t
        }
    }

    function w(e, t) {
        const i = [];
        let n = e.parentElement;
        for (; n;) t ? n.matches(t) && i.push(n) : i.push(n), n = n.parentElement;
        return i
    }

    function _(e, t) {
        t && e.addEventListener("transitionend", (function i(n) {
            n.target === e && (t.call(e, n), e.removeEventListener("transitionend", i))
        }))
    }

    function E(e, t, i) {
        const n = o();
        return i ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth
    }

    function M(e) {
        return (Array.isArray(e) ? e : [e]).filter(e => !!e)
    }

    function S(e) {
        return t => Math.abs(t) > 0 && e.browser && e.browser.need3dFix && Math.abs(t) % 90 == 0 ? t + .001 : t
    }
    let T, A, C;

    function L() {
        return T || (T = function () {
            const e = o(),
                t = n();
            return {
                smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style,
                touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch)
            }
        }()), T
    }

    function P(e) {
        return void 0 === e && (e = {}), A || (A = function (e) {
            let {
                userAgent: t
            } = void 0 === e ? {} : e;
            const i = L(),
                n = o(),
                r = n.navigator.platform,
                s = t || n.navigator.userAgent,
                a = {
                    ios: !1,
                    android: !1
                },
                l = n.screen.width,
                c = n.screen.height,
                u = s.match(/(Android);?[\s\/]+([\d.]+)?/);
            let h = s.match(/(iPad).*OS\s([\d_]+)/);
            const d = s.match(/(iPod)(.*OS\s([\d_]+))?/),
                p = !h && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                f = "Win32" === r;
            let m = "MacIntel" === r;
            return !h && m && i.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${l}x${c}`) >= 0 && (h = s.match(/(Version)\/([\d.]+)/), h || (h = [0, 1, "13_0_0"]), m = !1), u && !f && (a.os = "android", a.android = !0), (h || p || d) && (a.os = "ios", a.ios = !0), a
        }(e)), A
    }

    function I() {
        return C || (C = function () {
            const e = o(),
                t = P();
            let i = !1;

            function n() {
                const t = e.navigator.userAgent.toLowerCase();
                return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
            }
            if (n()) {
                const t = String(e.navigator.userAgent);
                if (t.includes("Version/")) {
                    const [e, n] = t.split("Version/")[1].split(" ")[0].split(".").map(e => Number(e));
                    i = e < 16 || 16 === e && n < 2
                }
            }
            const r = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent),
                s = n();
            return {
                isSafari: i || s,
                needPerspectiveFix: i,
                need3dFix: s || r && t.ios,
                isWebView: r
            }
        }()), C
    }
    const O = (e, t, i) => {
            t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i)
        },
        R = (e, t, i) => {
            t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i)
        },
        D = (e, t) => {
            if (!e || e.destroyed || !e.params) return;
            const i = t.closest(e.isElement ? "swiper-slide" : "." + e.params.slideClass);
            if (i) {
                let t = i.querySelector("." + e.params.lazyPreloaderClass);
                !t && e.isElement && (i.shadowRoot ? t = i.shadowRoot.querySelector("." + e.params.lazyPreloaderClass) : requestAnimationFrame(() => {
                    i.shadowRoot && (t = i.shadowRoot.querySelector("." + e.params.lazyPreloaderClass), t && t.remove())
                })), t && t.remove()
            }
        },
        k = (e, t) => {
            if (!e.slides[t]) return;
            const i = e.slides[t].querySelector('[loading="lazy"]');
            i && i.removeAttribute("loading")
        },
        z = e => {
            if (!e || e.destroyed || !e.params) return;
            let t = e.params.lazyPreloadPrevNext;
            const i = e.slides.length;
            if (!i || !t || t < 0) return;
            t = Math.min(t, i);
            const n = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView),
                r = e.activeIndex;
            if (e.params.grid && e.params.grid.rows > 1) {
                const i = r,
                    o = [i - t];
                return o.push(...Array.from({
                    length: t
                }).map((e, t) => i + n + t)), void e.slides.forEach((t, i) => {
                    o.includes(t.column) && k(e, i)
                })
            }
            const o = r + n - 1;
            if (e.params.rewind || e.params.loop)
                for (let n = r - t; n <= o + t; n += 1) {
                    const t = (n % i + i) % i;
                    (t < r || t > o) && k(e, t)
                } else
                    for (let n = Math.max(r - t, 0); n <= Math.min(o + t, i - 1); n += 1) n !== r && (n > o || n < r) && k(e, n)
        };

    function B(e) {
        let {
            swiper: t,
            runCallbacks: i,
            direction: n,
            step: r
        } = e;
        const {
            activeIndex: o,
            previousIndex: s
        } = t;
        let a = n;
        if (a || (a = o > s ? "next" : o < s ? "prev" : "reset"), t.emit("transition" + r), i && o !== s) {
            if ("reset" === a) return void t.emit("slideResetTransition" + r);
            t.emit("slideChangeTransition" + r), "next" === a ? t.emit("slideNextTransition" + r) : t.emit("slidePrevTransition" + r)
        }
    }

    function N(e, t, i) {
        const n = o(),
            {
                params: r
            } = e,
            s = r.edgeSwipeDetection,
            a = r.edgeSwipeThreshold;
        return !s || !(i <= a || i >= n.innerWidth - a) || "prevent" === s && (t.preventDefault(), !0)
    }

    function F(e) {
        const t = this,
            i = n();
        let r = e;
        r.originalEvent && (r = r.originalEvent);
        const s = t.touchEventsData;
        if ("pointerdown" === r.type) {
            if (null !== s.pointerId && s.pointerId !== r.pointerId) return;
            s.pointerId = r.pointerId
        } else "touchstart" === r.type && 1 === r.targetTouches.length && (s.touchId = r.targetTouches[0].identifier);
        if ("touchstart" === r.type) return void N(t, r, r.targetTouches[0].pageX);
        const {
            params: a,
            touches: c,
            enabled: u
        } = t;
        if (!u) return;
        if (!a.simulateTouch && "mouse" === r.pointerType) return;
        if (t.animating && a.preventInteractionOnTransition) return;
        !t.animating && a.cssMode && a.loop && t.loopFix();
        let h = r.target;
        if ("wrapper" === a.touchEventsTarget && ! function (e, t) {
                const i = o();
                let n = t.contains(e);
                return !n && i.HTMLSlotElement && t instanceof HTMLSlotElement && (n = [...t.assignedElements()].includes(e), n || (n = function (e, t) {
                    const i = [t];
                    for (; i.length > 0;) {
                        const t = i.shift();
                        if (e === t) return !0;
                        i.push(...t.children, ...t.shadowRoot ? t.shadowRoot.children : [], ...t.assignedElements ? t.assignedElements() : [])
                    }
                }(e, t))), n
            }(h, t.wrapperEl)) return;
        if ("which" in r && 3 === r.which) return;
        if ("button" in r && r.button > 0) return;
        if (s.isTouched && s.isMoved) return;
        const d = !!a.noSwipingClass && "" !== a.noSwipingClass,
            p = r.composedPath ? r.composedPath() : r.path;
        d && r.target && r.target.shadowRoot && p && (h = p[0]);
        const f = a.noSwipingSelector ? a.noSwipingSelector : "." + a.noSwipingClass,
            m = !(!r.target || !r.target.shadowRoot);
        if (a.noSwiping && (m ? function (e, t) {
                return void 0 === t && (t = this),
                    function t(i) {
                        if (!i || i === n() || i === o()) return null;
                        i.assignedSlot && (i = i.assignedSlot);
                        const r = i.closest(e);
                        return r || i.getRootNode ? r || t(i.getRootNode().host) : null
                    }(t)
            }(f, h) : h.closest(f))) return void(t.allowClick = !0);
        if (a.swipeHandler && !h.closest(a.swipeHandler)) return;
        c.currentX = r.pageX, c.currentY = r.pageY;
        const g = c.currentX,
            v = c.currentY;
        if (!N(t, r, g)) return;
        Object.assign(s, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0
        }), c.startX = g, c.startY = v, s.touchStartTime = l(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, a.threshold > 0 && (s.allowThresholdMove = !1);
        let y = !0;
        h.matches(s.focusableElements) && (y = !1, "SELECT" === h.nodeName && (s.isTouched = !1)), i.activeElement && i.activeElement.matches(s.focusableElements) && i.activeElement !== h && ("mouse" === r.pointerType || "mouse" !== r.pointerType && !h.matches(s.focusableElements)) && i.activeElement.blur();
        const b = y && t.allowTouchMove && a.touchStartPreventDefault;
        !a.touchStartForcePreventDefault && !b || h.isContentEditable || r.preventDefault(), a.freeMode && a.freeMode.enabled && t.freeMode && t.animating && !a.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", r)
    }

    function H(e) {
        const t = n(),
            i = this,
            r = i.touchEventsData,
            {
                params: o,
                touches: s,
                rtlTranslate: a,
                enabled: c
            } = i;
        if (!c) return;
        if (!o.simulateTouch && "mouse" === e.pointerType) return;
        let u, h = e;
        if (h.originalEvent && (h = h.originalEvent), "pointermove" === h.type) {
            if (null !== r.touchId) return;
            if (h.pointerId !== r.pointerId) return
        }
        if ("touchmove" === h.type) {
            if (u = [...h.changedTouches].find(e => e.identifier === r.touchId), !u || u.identifier !== r.touchId) return
        } else u = h;
        if (!r.isTouched) return void(r.startMoving && r.isScrolling && i.emit("touchMoveOpposite", h));
        const d = u.pageX,
            p = u.pageY;
        if (h.preventedByNestedSwiper) return s.startX = d, void(s.startY = p);
        if (!i.allowTouchMove) return h.target.matches(r.focusableElements) || (i.allowClick = !1), void(r.isTouched && (Object.assign(s, {
            startX: d,
            startY: p,
            currentX: d,
            currentY: p
        }), r.touchStartTime = l()));
        if (o.touchReleaseOnEdges && !o.loop)
            if (i.isVertical()) {
                if (p < s.startY && i.translate <= i.maxTranslate() || p > s.startY && i.translate >= i.minTranslate()) return r.isTouched = !1, void(r.isMoved = !1)
            } else if (d < s.startX && i.translate <= i.maxTranslate() || d > s.startX && i.translate >= i.minTranslate()) return;
        if (t.activeElement && t.activeElement.matches(r.focusableElements) && t.activeElement !== h.target && "mouse" !== h.pointerType && t.activeElement.blur(), t.activeElement && h.target === t.activeElement && h.target.matches(r.focusableElements)) return r.isMoved = !0, void(i.allowClick = !1);
        r.allowTouchCallbacks && i.emit("touchMove", h), s.previousX = s.currentX, s.previousY = s.currentY, s.currentX = d, s.currentY = p;
        const f = s.currentX - s.startX,
            m = s.currentY - s.startY;
        if (i.params.threshold && Math.sqrt(f ** 2 + m ** 2) < i.params.threshold) return;
        if (void 0 === r.isScrolling) {
            let e;
            i.isHorizontal() && s.currentY === s.startY || i.isVertical() && s.currentX === s.startX ? r.isScrolling = !1 : f * f + m * m >= 25 && (e = 180 * Math.atan2(Math.abs(m), Math.abs(f)) / Math.PI, r.isScrolling = i.isHorizontal() ? e > o.touchAngle : 90 - e > o.touchAngle)
        }
        if (r.isScrolling && i.emit("touchMoveOpposite", h), void 0 === r.startMoving && (s.currentX === s.startX && s.currentY === s.startY || (r.startMoving = !0)), r.isScrolling || "touchmove" === h.type && r.preventTouchMoveFromPointerMove) return void(r.isTouched = !1);
        if (!r.startMoving) return;
        i.allowClick = !1, !o.cssMode && h.cancelable && h.preventDefault(), o.touchMoveStopPropagation && !o.nested && h.stopPropagation();
        let g = i.isHorizontal() ? f : m,
            v = i.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY;
        o.oneWayMovement && (g = Math.abs(g) * (a ? 1 : -1), v = Math.abs(v) * (a ? 1 : -1)), s.diff = g, g *= o.touchRatio, a && (g = -g, v = -v);
        const y = i.touchesDirection;
        i.swipeDirection = g > 0 ? "prev" : "next", i.touchesDirection = v > 0 ? "prev" : "next";
        const b = i.params.loop && !o.cssMode,
            x = "next" === i.touchesDirection && i.allowSlideNext || "prev" === i.touchesDirection && i.allowSlidePrev;
        if (!r.isMoved) {
            if (b && x && i.loopFix({
                    direction: i.swipeDirection
                }), r.startTranslate = i.getTranslate(), i.setTransition(0), i.animating) {
                const e = new window.CustomEvent("transitionend", {
                    bubbles: !0,
                    cancelable: !0,
                    detail: {
                        bySwiperTouchMove: !0
                    }
                });
                i.wrapperEl.dispatchEvent(e)
            }
            r.allowMomentumBounce = !1, !o.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0), i.emit("sliderFirstMove", h)
        }
        if ((new Date).getTime(), !1 !== o._loopSwapReset && r.isMoved && r.allowThresholdMove && y !== i.touchesDirection && b && x && Math.abs(g) >= 1) return Object.assign(s, {
            startX: d,
            startY: p,
            currentX: d,
            currentY: p,
            startTranslate: r.currentTranslate
        }), r.loopSwapReset = !0, void(r.startTranslate = r.currentTranslate);
        i.emit("sliderMove", h), r.isMoved = !0, r.currentTranslate = g + r.startTranslate;
        let w = !0,
            _ = o.resistanceRatio;
        if (o.touchReleaseOnEdges && (_ = 0), g > 0 ? (b && x && r.allowThresholdMove && r.currentTranslate > (o.centeredSlides ? i.minTranslate() - i.slidesSizesGrid[i.activeIndex + 1] - ("auto" !== o.slidesPerView && i.slides.length - o.slidesPerView >= 2 ? i.slidesSizesGrid[i.activeIndex + 1] + i.params.spaceBetween : 0) - i.params.spaceBetween : i.minTranslate()) && i.loopFix({
                direction: "prev",
                setTranslate: !0,
                activeSlideIndex: 0
            }), r.currentTranslate > i.minTranslate() && (w = !1, o.resistance && (r.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + r.startTranslate + g) ** _))) : g < 0 && (b && x && r.allowThresholdMove && r.currentTranslate < (o.centeredSlides ? i.maxTranslate() + i.slidesSizesGrid[i.slidesSizesGrid.length - 1] + i.params.spaceBetween + ("auto" !== o.slidesPerView && i.slides.length - o.slidesPerView >= 2 ? i.slidesSizesGrid[i.slidesSizesGrid.length - 1] + i.params.spaceBetween : 0) : i.maxTranslate()) && i.loopFix({
                direction: "next",
                setTranslate: !0,
                activeSlideIndex: i.slides.length - ("auto" === o.slidesPerView ? i.slidesPerViewDynamic() : Math.ceil(parseFloat(o.slidesPerView, 10)))
            }), r.currentTranslate < i.maxTranslate() && (w = !1, o.resistance && (r.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - r.startTranslate - g) ** _))), w && (h.preventedByNestedSwiper = !0), !i.allowSlideNext && "next" === i.swipeDirection && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !i.allowSlidePrev && "prev" === i.swipeDirection && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), i.allowSlidePrev || i.allowSlideNext || (r.currentTranslate = r.startTranslate), o.threshold > 0) {
            if (!(Math.abs(g) > o.threshold || r.allowThresholdMove)) return void(r.currentTranslate = r.startTranslate);
            if (!r.allowThresholdMove) return r.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, r.currentTranslate = r.startTranslate, void(s.diff = i.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY)
        }
        o.followFinger && !o.cssMode && ((o.freeMode && o.freeMode.enabled && i.freeMode || o.watchSlidesProgress) && (i.updateActiveIndex(), i.updateSlidesClasses()), o.freeMode && o.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(), i.updateProgress(r.currentTranslate), i.setTranslate(r.currentTranslate))
    }

    function U(e) {
        const t = this,
            i = t.touchEventsData;
        let n, r = e;
        if (r.originalEvent && (r = r.originalEvent), "touchend" === r.type || "touchcancel" === r.type) {
            if (n = [...r.changedTouches].find(e => e.identifier === i.touchId), !n || n.identifier !== i.touchId) return
        } else {
            if (null !== i.touchId) return;
            if (r.pointerId !== i.pointerId) return;
            n = r
        }
        if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(r.type) && (!["pointercancel", "contextmenu"].includes(r.type) || !t.browser.isSafari && !t.browser.isWebView)) return;
        i.pointerId = null, i.touchId = null;
        const {
            params: o,
            touches: s,
            rtlTranslate: c,
            slidesGrid: u,
            enabled: h
        } = t;
        if (!h) return;
        if (!o.simulateTouch && "mouse" === r.pointerType) return;
        if (i.allowTouchCallbacks && t.emit("touchEnd", r), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && o.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void(i.startMoving = !1);
        o.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
        const d = l(),
            p = d - i.touchStartTime;
        if (t.allowClick) {
            const e = r.path || r.composedPath && r.composedPath();
            t.updateClickedSlide(e && e[0] || r.target, e), t.emit("tap click", r), p < 300 && d - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", r)
        }
        if (i.lastClickTime = l(), a(() => {
                t.destroyed || (t.allowClick = !0)
            }), !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === s.diff && !i.loopSwapReset || i.currentTranslate === i.startTranslate && !i.loopSwapReset) return i.isTouched = !1, i.isMoved = !1, void(i.startMoving = !1);
        let f;
        if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, f = o.followFinger ? c ? t.translate : -t.translate : -i.currentTranslate, o.cssMode) return;
        if (o.freeMode && o.freeMode.enabled) return void t.freeMode.onTouchEnd({
            currentPos: f
        });
        const m = f >= -t.maxTranslate() && !t.params.loop;
        let g = 0,
            v = t.slidesSizesGrid[0];
        for (let e = 0; e < u.length; e += e < o.slidesPerGroupSkip ? 1 : o.slidesPerGroup) {
            const t = e < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup;
            void 0 !== u[e + t] ? (m || f >= u[e] && f < u[e + t]) && (g = e, v = u[e + t] - u[e]) : (m || f >= u[e]) && (g = e, v = u[u.length - 1] - u[u.length - 2])
        }
        let y = null,
            b = null;
        o.rewind && (t.isBeginning ? b = o.virtual && o.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (y = 0));
        const x = (f - u[g]) / v,
            w = g < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup;
        if (p > o.longSwipesMs) {
            if (!o.longSwipes) return void t.slideTo(t.activeIndex);
            "next" === t.swipeDirection && (x >= o.longSwipesRatio ? t.slideTo(o.rewind && t.isEnd ? y : g + w) : t.slideTo(g)), "prev" === t.swipeDirection && (x > 1 - o.longSwipesRatio ? t.slideTo(g + w) : null !== b && x < 0 && Math.abs(x) > o.longSwipesRatio ? t.slideTo(b) : t.slideTo(g))
        } else {
            if (!o.shortSwipes) return void t.slideTo(t.activeIndex);
            !t.navigation || r.target !== t.navigation.nextEl && r.target !== t.navigation.prevEl ? ("next" === t.swipeDirection && t.slideTo(null !== y ? y : g + w), "prev" === t.swipeDirection && t.slideTo(null !== b ? b : g)) : r.target === t.navigation.nextEl ? t.slideTo(g + w) : t.slideTo(g)
        }
    }

    function j() {
        const e = this,
            {
                params: t,
                el: i
            } = e;
        if (i && 0 === i.offsetWidth) return;
        t.breakpoints && e.setBreakpoint();
        const {
            allowSlideNext: n,
            allowSlidePrev: r,
            snapGrid: o
        } = e, s = e.virtual && e.params.virtual.enabled;
        e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses();
        const a = s && t.loop;
        !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || a ? e.params.loop && !s ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout(() => {
            e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume()
        }, 500)), e.allowSlidePrev = r, e.allowSlideNext = n, e.params.watchOverflow && o !== e.snapGrid && e.checkOverflow()
    }

    function G(e) {
        const t = this;
        t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
    }

    function V() {
        const e = this,
            {
                wrapperEl: t,
                rtlTranslate: i,
                enabled: n
            } = e;
        if (!n) return;
        let r;
        e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
        const o = e.maxTranslate() - e.minTranslate();
        r = 0 === o ? 0 : (e.translate - e.minTranslate()) / o, r !== e.progress && e.updateProgress(i ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1)
    }

    function W(e) {
        const t = this;
        D(t, e.target), t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update()
    }

    function q() {
        const e = this;
        e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0, e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto"))
    }
    const X = (e, t) => {
            const i = n(),
                {
                    params: r,
                    el: o,
                    wrapperEl: s,
                    device: a
                } = e,
                l = !!r.nested,
                c = "on" === t ? "addEventListener" : "removeEventListener",
                u = t;
            o && "string" != typeof o && (i[c]("touchstart", e.onDocumentTouchStart, {
                passive: !1,
                capture: l
            }), o[c]("touchstart", e.onTouchStart, {
                passive: !1
            }), o[c]("pointerdown", e.onTouchStart, {
                passive: !1
            }), i[c]("touchmove", e.onTouchMove, {
                passive: !1,
                capture: l
            }), i[c]("pointermove", e.onTouchMove, {
                passive: !1,
                capture: l
            }), i[c]("touchend", e.onTouchEnd, {
                passive: !0
            }), i[c]("pointerup", e.onTouchEnd, {
                passive: !0
            }), i[c]("pointercancel", e.onTouchEnd, {
                passive: !0
            }), i[c]("touchcancel", e.onTouchEnd, {
                passive: !0
            }), i[c]("pointerout", e.onTouchEnd, {
                passive: !0
            }), i[c]("pointerleave", e.onTouchEnd, {
                passive: !0
            }), i[c]("contextmenu", e.onTouchEnd, {
                passive: !0
            }), (r.preventClicks || r.preventClicksPropagation) && o[c]("click", e.onClick, !0), r.cssMode && s[c]("scroll", e.onScroll), r.updateOnWindowResize ? e[u](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", j, !0) : e[u]("observerUpdate", j, !0), o[c]("load", e.onLoad, {
                capture: !0
            }))
        },
        Y = (e, t) => e.grid && t.grid && t.grid.rows > 1;
    var Z = {
        init: !0,
        direction: "horizontal",
        oneWayMovement: !1,
        swiperElementNodeName: "SWIPER-CONTAINER",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        eventsPrefix: "swiper",
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 5,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        loop: !1,
        loopAddBlankSlides: !0,
        loopAdditionalSlides: 0,
        loopPreventsSliding: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-blank",
        slideActiveClass: "swiper-slide-active",
        slideVisibleClass: "swiper-slide-visible",
        slideFullyVisibleClass: "swiper-slide-fully-visible",
        slideNextClass: "swiper-slide-next",
        slidePrevClass: "swiper-slide-prev",
        wrapperClass: "swiper-wrapper",
        lazyPreloaderClass: "swiper-lazy-preloader",
        lazyPreloadPrevNext: 0,
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

    function Q(e, t) {
        return function (i) {
            void 0 === i && (i = {});
            const n = Object.keys(i)[0],
                r = i[n];
            "object" == typeof r && null !== r ? (!0 === e[n] && (e[n] = {
                enabled: !0
            }), "navigation" === n && e[n] && e[n].enabled && !e[n].prevEl && !e[n].nextEl && (e[n].auto = !0), ["pagination", "scrollbar"].indexOf(n) >= 0 && e[n] && e[n].enabled && !e[n].el && (e[n].auto = !0), n in e && "enabled" in r ? ("object" != typeof e[n] || "enabled" in e[n] || (e[n].enabled = !0), e[n] || (e[n] = {
                enabled: !1
            }), h(t, i)) : h(t, i)) : h(t, i)
        }
    }
    const J = {
            eventsEmitter: {
                on(e, t, i) {
                    const n = this;
                    if (!n.eventsListeners || n.destroyed) return n;
                    if ("function" != typeof t) return n;
                    const r = i ? "unshift" : "push";
                    return e.split(" ").forEach(e => {
                        n.eventsListeners[e] || (n.eventsListeners[e] = []), n.eventsListeners[e][r](t)
                    }), n
                },
                once(e, t, i) {
                    const n = this;
                    if (!n.eventsListeners || n.destroyed) return n;
                    if ("function" != typeof t) return n;

                    function r() {
                        n.off(e, r), r.__emitterProxy && delete r.__emitterProxy;
                        for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
                        t.apply(n, o)
                    }
                    return r.__emitterProxy = t, n.on(e, r, i)
                },
                onAny(e, t) {
                    const i = this;
                    if (!i.eventsListeners || i.destroyed) return i;
                    if ("function" != typeof e) return i;
                    const n = t ? "unshift" : "push";
                    return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[n](e), i
                },
                offAny(e) {
                    const t = this;
                    if (!t.eventsListeners || t.destroyed) return t;
                    if (!t.eventsAnyListeners) return t;
                    const i = t.eventsAnyListeners.indexOf(e);
                    return i >= 0 && t.eventsAnyListeners.splice(i, 1), t
                },
                off(e, t) {
                    const i = this;
                    return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (e.split(" ").forEach(e => {
                        void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach((n, r) => {
                            (n === t || n.__emitterProxy && n.__emitterProxy === t) && i.eventsListeners[e].splice(r, 1)
                        })
                    }), i) : i
                },
                emit() {
                    const e = this;
                    if (!e.eventsListeners || e.destroyed) return e;
                    if (!e.eventsListeners) return e;
                    let t, i, n;
                    for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];
                    return "string" == typeof o[0] || Array.isArray(o[0]) ? (t = o[0], i = o.slice(1, o.length), n = e) : (t = o[0].events, i = o[0].data, n = o[0].context || e), i.unshift(n), (Array.isArray(t) ? t : t.split(" ")).forEach(t => {
                        e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(e => {
                            e.apply(n, [t, ...i])
                        }), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach(e => {
                            e.apply(n, i)
                        })
                    }), e
                }
            },
            update: {
                updateSize: function () {
                    const e = this;
                    let t, i;
                    const n = e.el;
                    t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : n.clientWidth, i = void 0 !== e.params.height && null !== e.params.height ? e.params.height : n.clientHeight, 0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(b(n, "padding-left") || 0, 10) - parseInt(b(n, "padding-right") || 0, 10), i = i - parseInt(b(n, "padding-top") || 0, 10) - parseInt(b(n, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(i) && (i = 0), Object.assign(e, {
                        width: t,
                        height: i,
                        size: e.isHorizontal() ? t : i
                    }))
                },
                updateSlides: function () {
                    const e = this;

                    function t(t, i) {
                        return parseFloat(t.getPropertyValue(e.getDirectionLabel(i)) || 0)
                    }
                    const i = e.params,
                        {
                            wrapperEl: n,
                            slidesEl: r,
                            size: o,
                            rtlTranslate: s,
                            wrongRTL: a
                        } = e,
                        l = e.virtual && i.virtual.enabled,
                        c = l ? e.virtual.slides.length : e.slides.length,
                        u = m(r, `.${e.params.slideClass}, swiper-slide`),
                        h = l ? e.virtual.slides.length : u.length;
                    let p = [];
                    const f = [],
                        g = [];
                    let v = i.slidesOffsetBefore;
                    "function" == typeof v && (v = i.slidesOffsetBefore.call(e));
                    let y = i.slidesOffsetAfter;
                    "function" == typeof y && (y = i.slidesOffsetAfter.call(e));
                    const x = e.snapGrid.length,
                        w = e.slidesGrid.length;
                    let _ = i.spaceBetween,
                        M = -v,
                        S = 0,
                        T = 0;
                    if (void 0 === o) return;
                    "string" == typeof _ && _.indexOf("%") >= 0 ? _ = parseFloat(_.replace("%", "")) / 100 * o : "string" == typeof _ && (_ = parseFloat(_)), e.virtualSize = -_, u.forEach(e => {
                        s ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = ""
                    }), i.centeredSlides && i.cssMode && (d(n, "--swiper-centered-offset-before", ""), d(n, "--swiper-centered-offset-after", ""));
                    const A = i.grid && i.grid.rows > 1 && e.grid;
                    let C;
                    A ? e.grid.initSlides(u) : e.grid && e.grid.unsetSlides();
                    const L = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter(e => void 0 !== i.breakpoints[e].slidesPerView).length > 0;
                    for (let n = 0; n < h; n += 1) {
                        let r;
                        if (C = 0, u[n] && (r = u[n]), A && e.grid.updateSlide(n, r, u), !u[n] || "none" !== b(r, "display")) {
                            if ("auto" === i.slidesPerView) {
                                L && (u[n].style[e.getDirectionLabel("width")] = "");
                                const o = getComputedStyle(r),
                                    s = r.style.transform,
                                    a = r.style.webkitTransform;
                                if (s && (r.style.transform = "none"), a && (r.style.webkitTransform = "none"), i.roundLengths) C = e.isHorizontal() ? E(r, "width", !0) : E(r, "height", !0);
                                else {
                                    const e = t(o, "width"),
                                        i = t(o, "padding-left"),
                                        n = t(o, "padding-right"),
                                        s = t(o, "margin-left"),
                                        a = t(o, "margin-right"),
                                        l = o.getPropertyValue("box-sizing");
                                    if (l && "border-box" === l) C = e + s + a;
                                    else {
                                        const {
                                            clientWidth: t,
                                            offsetWidth: o
                                        } = r;
                                        C = e + i + n + s + a + (o - t)
                                    }
                                }
                                s && (r.style.transform = s), a && (r.style.webkitTransform = a), i.roundLengths && (C = Math.floor(C))
                            } else C = (o - (i.slidesPerView - 1) * _) / i.slidesPerView, i.roundLengths && (C = Math.floor(C)), u[n] && (u[n].style[e.getDirectionLabel("width")] = C + "px");
                            u[n] && (u[n].swiperSlideSize = C), g.push(C), i.centeredSlides ? (M = M + C / 2 + S / 2 + _, 0 === S && 0 !== n && (M = M - o / 2 - _), 0 === n && (M = M - o / 2 - _), Math.abs(M) < .001 && (M = 0), i.roundLengths && (M = Math.floor(M)), T % i.slidesPerGroup == 0 && p.push(M), f.push(M)) : (i.roundLengths && (M = Math.floor(M)), (T - Math.min(e.params.slidesPerGroupSkip, T)) % e.params.slidesPerGroup == 0 && p.push(M), f.push(M), M = M + C + _), e.virtualSize += C + _, S = C, T += 1
                        }
                    }
                    if (e.virtualSize = Math.max(e.virtualSize, o) + y, s && a && ("slide" === i.effect || "coverflow" === i.effect) && (n.style.width = e.virtualSize + _ + "px"), i.setWrapperSize && (n.style[e.getDirectionLabel("width")] = e.virtualSize + _ + "px"), A && e.grid.updateWrapperSize(C, p), !i.centeredSlides) {
                        const t = [];
                        for (let n = 0; n < p.length; n += 1) {
                            let r = p[n];
                            i.roundLengths && (r = Math.floor(r)), p[n] <= e.virtualSize - o && t.push(r)
                        }
                        p = t, Math.floor(e.virtualSize - o) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - o)
                    }
                    if (l && i.loop) {
                        const t = g[0] + _;
                        if (i.slidesPerGroup > 1) {
                            const n = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / i.slidesPerGroup),
                                r = t * i.slidesPerGroup;
                            for (let e = 0; e < n; e += 1) p.push(p[p.length - 1] + r)
                        }
                        for (let n = 0; n < e.virtual.slidesBefore + e.virtual.slidesAfter; n += 1) 1 === i.slidesPerGroup && p.push(p[p.length - 1] + t), f.push(f[f.length - 1] + t), e.virtualSize += t
                    }
                    if (0 === p.length && (p = [0]), 0 !== _) {
                        const t = e.isHorizontal() && s ? "marginLeft" : e.getDirectionLabel("marginRight");
                        u.filter((e, t) => !(i.cssMode && !i.loop) || t !== u.length - 1).forEach(e => {
                            e.style[t] = _ + "px"
                        })
                    }
                    if (i.centeredSlides && i.centeredSlidesBounds) {
                        let e = 0;
                        g.forEach(t => {
                            e += t + (_ || 0)
                        }), e -= _;
                        const t = e > o ? e - o : 0;
                        p = p.map(e => e <= 0 ? -v : e > t ? t + y : e)
                    }
                    if (i.centerInsufficientSlides) {
                        let e = 0;
                        g.forEach(t => {
                            e += t + (_ || 0)
                        }), e -= _;
                        const t = (i.slidesOffsetBefore || 0) + (i.slidesOffsetAfter || 0);
                        if (e + t < o) {
                            const i = (o - e - t) / 2;
                            p.forEach((e, t) => {
                                p[t] = e - i
                            }), f.forEach((e, t) => {
                                f[t] = e + i
                            })
                        }
                    }
                    if (Object.assign(e, {
                            slides: u,
                            snapGrid: p,
                            slidesGrid: f,
                            slidesSizesGrid: g
                        }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) {
                        d(n, "--swiper-centered-offset-before", -p[0] + "px"), d(n, "--swiper-centered-offset-after", e.size / 2 - g[g.length - 1] / 2 + "px");
                        const t = -e.snapGrid[0],
                            i = -e.slidesGrid[0];
                        e.snapGrid = e.snapGrid.map(e => e + t), e.slidesGrid = e.slidesGrid.map(e => e + i)
                    }
                    if (h !== c && e.emit("slidesLengthChange"), p.length !== x && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), f.length !== w && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset(), e.emit("slidesUpdated"), !(l || i.cssMode || "slide" !== i.effect && "fade" !== i.effect)) {
                        const t = i.containerModifierClass + "backface-hidden",
                            n = e.el.classList.contains(t);
                        h <= i.maxBackfaceHiddenSlides ? n || e.el.classList.add(t) : n && e.el.classList.remove(t)
                    }
                },
                updateAutoHeight: function (e) {
                    const t = this,
                        i = [],
                        n = t.virtual && t.params.virtual.enabled;
                    let r, o = 0;
                    "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
                    const s = e => n ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
                    if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
                        if (t.params.centeredSlides)(t.visibleSlides || []).forEach(e => {
                            i.push(e)
                        });
                        else
                            for (r = 0; r < Math.ceil(t.params.slidesPerView); r += 1) {
                                const e = t.activeIndex + r;
                                if (e > t.slides.length && !n) break;
                                i.push(s(e))
                            } else i.push(s(t.activeIndex));
                    for (r = 0; r < i.length; r += 1)
                        if (void 0 !== i[r]) {
                            const e = i[r].offsetHeight;
                            o = e > o ? e : o
                        }(o || 0 === o) && (t.wrapperEl.style.height = o + "px")
                },
                updateSlidesOffset: function () {
                    const e = this,
                        t = e.slides,
                        i = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
                    for (let n = 0; n < t.length; n += 1) t[n].swiperSlideOffset = (e.isHorizontal() ? t[n].offsetLeft : t[n].offsetTop) - i - e.cssOverflowAdjustment()
                },
                updateSlidesProgress: function (e) {
                    void 0 === e && (e = this && this.translate || 0);
                    const t = this,
                        i = t.params,
                        {
                            slides: n,
                            rtlTranslate: r,
                            snapGrid: o
                        } = t;
                    if (0 === n.length) return;
                    void 0 === n[0].swiperSlideOffset && t.updateSlidesOffset();
                    let s = -e;
                    r && (s = e), t.visibleSlidesIndexes = [], t.visibleSlides = [];
                    let a = i.spaceBetween;
                    "string" == typeof a && a.indexOf("%") >= 0 ? a = parseFloat(a.replace("%", "")) / 100 * t.size : "string" == typeof a && (a = parseFloat(a));
                    for (let e = 0; e < n.length; e += 1) {
                        const l = n[e];
                        let c = l.swiperSlideOffset;
                        i.cssMode && i.centeredSlides && (c -= n[0].swiperSlideOffset);
                        const u = (s + (i.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + a),
                            h = (s - o[0] + (i.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + a),
                            d = -(s - c),
                            p = d + t.slidesSizesGrid[e],
                            f = d >= 0 && d <= t.size - t.slidesSizesGrid[e],
                            m = d >= 0 && d < t.size - 1 || p > 1 && p <= t.size || d <= 0 && p >= t.size;
                        m && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e)), O(l, m, i.slideVisibleClass), O(l, f, i.slideFullyVisibleClass), l.progress = r ? -u : u, l.originalProgress = r ? -h : h
                    }
                },
                updateProgress: function (e) {
                    const t = this;
                    if (void 0 === e) {
                        const i = t.rtlTranslate ? -1 : 1;
                        e = t && t.translate && t.translate * i || 0
                    }
                    const i = t.params,
                        n = t.maxTranslate() - t.minTranslate();
                    let {
                        progress: r,
                        isBeginning: o,
                        isEnd: s,
                        progressLoop: a
                    } = t;
                    const l = o,
                        c = s;
                    if (0 === n) r = 0, o = !0, s = !0;
                    else {
                        r = (e - t.minTranslate()) / n;
                        const i = Math.abs(e - t.minTranslate()) < 1,
                            a = Math.abs(e - t.maxTranslate()) < 1;
                        o = i || r <= 0, s = a || r >= 1, i && (r = 0), a && (r = 1)
                    }
                    if (i.loop) {
                        const i = t.getSlideIndexByData(0),
                            n = t.getSlideIndexByData(t.slides.length - 1),
                            r = t.slidesGrid[i],
                            o = t.slidesGrid[n],
                            s = t.slidesGrid[t.slidesGrid.length - 1],
                            l = Math.abs(e);
                        a = l >= r ? (l - r) / s : (l + s - o) / s, a > 1 && (a -= 1)
                    }
                    Object.assign(t, {
                        progress: r,
                        progressLoop: a,
                        isBeginning: o,
                        isEnd: s
                    }), (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e), o && !l && t.emit("reachBeginning toEdge"), s && !c && t.emit("reachEnd toEdge"), (l && !o || c && !s) && t.emit("fromEdge"), t.emit("progress", r)
                },
                updateSlidesClasses: function () {
                    const e = this,
                        {
                            slides: t,
                            params: i,
                            slidesEl: n,
                            activeIndex: r
                        } = e,
                        o = e.virtual && i.virtual.enabled,
                        s = e.grid && i.grid && i.grid.rows > 1,
                        a = e => m(n, `.${i.slideClass}${e}, swiper-slide${e}`)[0];
                    let l, c, u;
                    if (o)
                        if (i.loop) {
                            let t = r - e.virtual.slidesBefore;
                            t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), l = a(`[data-swiper-slide-index="${t}"]`)
                        } else l = a(`[data-swiper-slide-index="${r}"]`);
                    else s ? (l = t.find(e => e.column === r), u = t.find(e => e.column === r + 1), c = t.find(e => e.column === r - 1)) : l = t[r];
                    l && (s || (u = function (e, t) {
                        const i = [];
                        for (; e.nextElementSibling;) {
                            const n = e.nextElementSibling;
                            t ? n.matches(t) && i.push(n) : i.push(n), e = n
                        }
                        return i
                    }(l, `.${i.slideClass}, swiper-slide`)[0], i.loop && !u && (u = t[0]), c = function (e, t) {
                        const i = [];
                        for (; e.previousElementSibling;) {
                            const n = e.previousElementSibling;
                            t ? n.matches(t) && i.push(n) : i.push(n), e = n
                        }
                        return i
                    }(l, `.${i.slideClass}, swiper-slide`)[0], i.loop && 0 === !c && (c = t[t.length - 1]))), t.forEach(e => {
                        R(e, e === l, i.slideActiveClass), R(e, e === u, i.slideNextClass), R(e, e === c, i.slidePrevClass)
                    }), e.emitSlidesClasses()
                },
                updateActiveIndex: function (e) {
                    const t = this,
                        i = t.rtlTranslate ? t.translate : -t.translate,
                        {
                            snapGrid: n,
                            params: r,
                            activeIndex: o,
                            realIndex: s,
                            snapIndex: a
                        } = t;
                    let l, c = e;
                    const u = e => {
                        let i = e - t.virtual.slidesBefore;
                        return i < 0 && (i = t.virtual.slides.length + i), i >= t.virtual.slides.length && (i -= t.virtual.slides.length), i
                    };
                    if (void 0 === c && (c = function (e) {
                            const {
                                slidesGrid: t,
                                params: i
                            } = e, n = e.rtlTranslate ? e.translate : -e.translate;
                            let r;
                            for (let e = 0; e < t.length; e += 1) void 0 !== t[e + 1] ? n >= t[e] && n < t[e + 1] - (t[e + 1] - t[e]) / 2 ? r = e : n >= t[e] && n < t[e + 1] && (r = e + 1) : n >= t[e] && (r = e);
                            return i.normalizeSlideIndex && (r < 0 || void 0 === r) && (r = 0), r
                        }(t)), n.indexOf(i) >= 0) l = n.indexOf(i);
                    else {
                        const e = Math.min(r.slidesPerGroupSkip, c);
                        l = e + Math.floor((c - e) / r.slidesPerGroup)
                    }
                    if (l >= n.length && (l = n.length - 1), c === o && !t.params.loop) return void(l !== a && (t.snapIndex = l, t.emit("snapIndexChange")));
                    if (c === o && t.params.loop && t.virtual && t.params.virtual.enabled) return void(t.realIndex = u(c));
                    const h = t.grid && r.grid && r.grid.rows > 1;
                    let d;
                    if (t.virtual && r.virtual.enabled && r.loop) d = u(c);
                    else if (h) {
                        const e = t.slides.find(e => e.column === c);
                        let i = parseInt(e.getAttribute("data-swiper-slide-index"), 10);
                        Number.isNaN(i) && (i = Math.max(t.slides.indexOf(e), 0)), d = Math.floor(i / r.grid.rows)
                    } else if (t.slides[c]) {
                        const e = t.slides[c].getAttribute("data-swiper-slide-index");
                        d = e ? parseInt(e, 10) : c
                    } else d = c;
                    Object.assign(t, {
                        previousSnapIndex: a,
                        snapIndex: l,
                        previousRealIndex: s,
                        realIndex: d,
                        previousIndex: o,
                        activeIndex: c
                    }), t.initialized && z(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && (s !== d && t.emit("realIndexChange"), t.emit("slideChange"))
                },
                updateClickedSlide: function (e, t) {
                    const i = this,
                        n = i.params;
                    let r = e.closest(`.${n.slideClass}, swiper-slide`);
                    !r && i.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach(e => {
                        !r && e.matches && e.matches(`.${n.slideClass}, swiper-slide`) && (r = e)
                    });
                    let o, s = !1;
                    if (r)
                        for (let e = 0; e < i.slides.length; e += 1)
                            if (i.slides[e] === r) {
                                s = !0, o = e;
                                break
                            } if (!r || !s) return i.clickedSlide = void 0, void(i.clickedIndex = void 0);
                    i.clickedSlide = r, i.virtual && i.params.virtual.enabled ? i.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : i.clickedIndex = o, n.slideToClickedSlide && void 0 !== i.clickedIndex && i.clickedIndex !== i.activeIndex && i.slideToClickedSlide()
                }
            },
            translate: {
                getTranslate: function (e) {
                    void 0 === e && (e = this.isHorizontal() ? "x" : "y");
                    const {
                        params: t,
                        rtlTranslate: i,
                        translate: n,
                        wrapperEl: r
                    } = this;
                    if (t.virtualTranslate) return i ? -n : n;
                    if (t.cssMode) return n;
                    let o = c(r, e);
                    return o += this.cssOverflowAdjustment(), i && (o = -o), o || 0
                },
                setTranslate: function (e, t) {
                    const i = this,
                        {
                            rtlTranslate: n,
                            params: r,
                            wrapperEl: o,
                            progress: s
                        } = i;
                    let a, l = 0,
                        c = 0;
                    i.isHorizontal() ? l = n ? -e : e : c = e, r.roundLengths && (l = Math.floor(l), c = Math.floor(c)), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? l : c, r.cssMode ? o[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -l : -c : r.virtualTranslate || (i.isHorizontal() ? l -= i.cssOverflowAdjustment() : c -= i.cssOverflowAdjustment(), o.style.transform = `translate3d(${l}px, ${c}px, 0px)`);
                    const u = i.maxTranslate() - i.minTranslate();
                    a = 0 === u ? 0 : (e - i.minTranslate()) / u, a !== s && i.updateProgress(e), i.emit("setTranslate", i.translate, t)
                },
                minTranslate: function () {
                    return -this.snapGrid[0]
                },
                maxTranslate: function () {
                    return -this.snapGrid[this.snapGrid.length - 1]
                },
                translateTo: function (e, t, i, n, r) {
                    void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0), void 0 === n && (n = !0);
                    const o = this,
                        {
                            params: s,
                            wrapperEl: a
                        } = o;
                    if (o.animating && s.preventInteractionOnTransition) return !1;
                    const l = o.minTranslate(),
                        c = o.maxTranslate();
                    let u;
                    if (u = n && e > l ? l : n && e < c ? c : e, o.updateProgress(u), s.cssMode) {
                        const e = o.isHorizontal();
                        if (0 === t) a[e ? "scrollLeft" : "scrollTop"] = -u;
                        else {
                            if (!o.support.smoothScroll) return p({
                                swiper: o,
                                targetPosition: -u,
                                side: e ? "left" : "top"
                            }), !0;
                            a.scrollTo({
                                [e ? "left" : "top"]: -u,
                                behavior: "smooth"
                            })
                        }
                        return !0
                    }
                    return 0 === t ? (o.setTransition(0), o.setTranslate(u), i && (o.emit("beforeTransitionStart", t, r), o.emit("transitionEnd"))) : (o.setTransition(t), o.setTranslate(u), i && (o.emit("beforeTransitionStart", t, r), o.emit("transitionStart")), o.animating || (o.animating = !0, o.onTranslateToWrapperTransitionEnd || (o.onTranslateToWrapperTransitionEnd = function (e) {
                        o && !o.destroyed && e.target === this && (o.wrapperEl.removeEventListener("transitionend", o.onTranslateToWrapperTransitionEnd), o.onTranslateToWrapperTransitionEnd = null, delete o.onTranslateToWrapperTransitionEnd, o.animating = !1, i && o.emit("transitionEnd"))
                    }), o.wrapperEl.addEventListener("transitionend", o.onTranslateToWrapperTransitionEnd))), !0
                }
            },
            transition: {
                setTransition: function (e, t) {
                    const i = this;
                    i.params.cssMode || (i.wrapperEl.style.transitionDuration = e + "ms", i.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""), i.emit("setTransition", e, t)
                },
                transitionStart: function (e, t) {
                    void 0 === e && (e = !0);
                    const i = this,
                        {
                            params: n
                        } = i;
                    n.cssMode || (n.autoHeight && i.updateAutoHeight(), B({
                        swiper: i,
                        runCallbacks: e,
                        direction: t,
                        step: "Start"
                    }))
                },
                transitionEnd: function (e, t) {
                    void 0 === e && (e = !0);
                    const i = this,
                        {
                            params: n
                        } = i;
                    i.animating = !1, n.cssMode || (i.setTransition(0), B({
                        swiper: i,
                        runCallbacks: e,
                        direction: t,
                        step: "End"
                    }))
                }
            },
            slide: {
                slideTo: function (e, t, i, n, r) {
                    void 0 === e && (e = 0), void 0 === i && (i = !0), "string" == typeof e && (e = parseInt(e, 10));
                    const o = this;
                    let s = e;
                    s < 0 && (s = 0);
                    const {
                        params: a,
                        snapGrid: l,
                        slidesGrid: c,
                        previousIndex: u,
                        activeIndex: h,
                        rtlTranslate: d,
                        wrapperEl: f,
                        enabled: m
                    } = o;
                    if (!m && !n && !r || o.destroyed || o.animating && a.preventInteractionOnTransition) return !1;
                    void 0 === t && (t = o.params.speed);
                    const g = Math.min(o.params.slidesPerGroupSkip, s);
                    let v = g + Math.floor((s - g) / o.params.slidesPerGroup);
                    v >= l.length && (v = l.length - 1);
                    const y = -l[v];
                    if (a.normalizeSlideIndex)
                        for (let e = 0; e < c.length; e += 1) {
                            const t = -Math.floor(100 * y),
                                i = Math.floor(100 * c[e]),
                                n = Math.floor(100 * c[e + 1]);
                            void 0 !== c[e + 1] ? t >= i && t < n - (n - i) / 2 ? s = e : t >= i && t < n && (s = e + 1) : t >= i && (s = e)
                        }
                    if (o.initialized && s !== h) {
                        if (!o.allowSlideNext && (d ? y > o.translate && y > o.minTranslate() : y < o.translate && y < o.minTranslate())) return !1;
                        if (!o.allowSlidePrev && y > o.translate && y > o.maxTranslate() && (h || 0) !== s) return !1
                    }
                    let b;
                    s !== (u || 0) && i && o.emit("beforeSlideChangeStart"), o.updateProgress(y), b = s > h ? "next" : s < h ? "prev" : "reset";
                    const x = o.virtual && o.params.virtual.enabled;
                    if ((!x || !r) && (d && -y === o.translate || !d && y === o.translate)) return o.updateActiveIndex(s), a.autoHeight && o.updateAutoHeight(), o.updateSlidesClasses(), "slide" !== a.effect && o.setTranslate(y), "reset" !== b && (o.transitionStart(i, b), o.transitionEnd(i, b)), !1;
                    if (a.cssMode) {
                        const e = o.isHorizontal(),
                            i = d ? y : -y;
                        if (0 === t) x && (o.wrapperEl.style.scrollSnapType = "none", o._immediateVirtual = !0), x && !o._cssModeVirtualInitialSet && o.params.initialSlide > 0 ? (o._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
                            f[e ? "scrollLeft" : "scrollTop"] = i
                        })) : f[e ? "scrollLeft" : "scrollTop"] = i, x && requestAnimationFrame(() => {
                            o.wrapperEl.style.scrollSnapType = "", o._immediateVirtual = !1
                        });
                        else {
                            if (!o.support.smoothScroll) return p({
                                swiper: o,
                                targetPosition: i,
                                side: e ? "left" : "top"
                            }), !0;
                            f.scrollTo({
                                [e ? "left" : "top"]: i,
                                behavior: "smooth"
                            })
                        }
                        return !0
                    }
                    const w = I().isSafari;
                    return x && !r && w && o.isElement && o.virtual.update(!1, !1, s), o.setTransition(t), o.setTranslate(y), o.updateActiveIndex(s), o.updateSlidesClasses(), o.emit("beforeTransitionStart", t, n), o.transitionStart(i, b), 0 === t ? o.transitionEnd(i, b) : o.animating || (o.animating = !0, o.onSlideToWrapperTransitionEnd || (o.onSlideToWrapperTransitionEnd = function (e) {
                        o && !o.destroyed && e.target === this && (o.wrapperEl.removeEventListener("transitionend", o.onSlideToWrapperTransitionEnd), o.onSlideToWrapperTransitionEnd = null, delete o.onSlideToWrapperTransitionEnd, o.transitionEnd(i, b))
                    }), o.wrapperEl.addEventListener("transitionend", o.onSlideToWrapperTransitionEnd)), !0
                },
                slideToLoop: function (e, t, i, n) {
                    void 0 === e && (e = 0), void 0 === i && (i = !0), "string" == typeof e && (e = parseInt(e, 10));
                    const r = this;
                    if (r.destroyed) return;
                    void 0 === t && (t = r.params.speed);
                    const o = r.grid && r.params.grid && r.params.grid.rows > 1;
                    let s = e;
                    if (r.params.loop)
                        if (r.virtual && r.params.virtual.enabled) s += r.virtual.slidesBefore;
                        else {
                            let e;
                            if (o) {
                                const t = s * r.params.grid.rows;
                                e = r.slides.find(e => 1 * e.getAttribute("data-swiper-slide-index") === t).column
                            } else e = r.getSlideIndexByData(s);
                            const t = o ? Math.ceil(r.slides.length / r.params.grid.rows) : r.slides.length,
                                {
                                    centeredSlides: i
                                } = r.params;
                            let a = r.params.slidesPerView;
                            "auto" === a ? a = r.slidesPerViewDynamic() : (a = Math.ceil(parseFloat(r.params.slidesPerView, 10)), i && a % 2 == 0 && (a += 1));
                            let l = t - e < a;
                            if (i && (l = l || e < Math.ceil(a / 2)), n && i && "auto" !== r.params.slidesPerView && !o && (l = !1), l) {
                                const n = i ? e < r.activeIndex ? "prev" : "next" : e - r.activeIndex - 1 < r.params.slidesPerView ? "next" : "prev";
                                r.loopFix({
                                    direction: n,
                                    slideTo: !0,
                                    activeSlideIndex: "next" === n ? e + 1 : e - t + 1,
                                    slideRealIndex: "next" === n ? r.realIndex : void 0
                                })
                            }
                            if (o) {
                                const e = s * r.params.grid.rows;
                                s = r.slides.find(t => 1 * t.getAttribute("data-swiper-slide-index") === e).column
                            } else s = r.getSlideIndexByData(s)
                        } return requestAnimationFrame(() => {
                        r.slideTo(s, t, i, n)
                    }), r
                },
                slideNext: function (e, t, i) {
                    void 0 === t && (t = !0);
                    const n = this,
                        {
                            enabled: r,
                            params: o,
                            animating: s
                        } = n;
                    if (!r || n.destroyed) return n;
                    void 0 === e && (e = n.params.speed);
                    let a = o.slidesPerGroup;
                    "auto" === o.slidesPerView && 1 === o.slidesPerGroup && o.slidesPerGroupAuto && (a = Math.max(n.slidesPerViewDynamic("current", !0), 1));
                    const l = n.activeIndex < o.slidesPerGroupSkip ? 1 : a,
                        c = n.virtual && o.virtual.enabled;
                    if (o.loop) {
                        if (s && !c && o.loopPreventsSliding) return !1;
                        if (n.loopFix({
                                direction: "next"
                            }), n._clientLeft = n.wrapperEl.clientLeft, n.activeIndex === n.slides.length - 1 && o.cssMode) return requestAnimationFrame(() => {
                            n.slideTo(n.activeIndex + l, e, t, i)
                        }), !0
                    }
                    return o.rewind && n.isEnd ? n.slideTo(0, e, t, i) : n.slideTo(n.activeIndex + l, e, t, i)
                },
                slidePrev: function (e, t, i) {
                    void 0 === t && (t = !0);
                    const n = this,
                        {
                            params: r,
                            snapGrid: o,
                            slidesGrid: s,
                            rtlTranslate: a,
                            enabled: l,
                            animating: c
                        } = n;
                    if (!l || n.destroyed) return n;
                    void 0 === e && (e = n.params.speed);
                    const u = n.virtual && r.virtual.enabled;
                    if (r.loop) {
                        if (c && !u && r.loopPreventsSliding) return !1;
                        n.loopFix({
                            direction: "prev"
                        }), n._clientLeft = n.wrapperEl.clientLeft
                    }

                    function h(e) {
                        return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
                    }
                    const d = h(a ? n.translate : -n.translate),
                        p = o.map(e => h(e)),
                        f = r.freeMode && r.freeMode.enabled;
                    let m = o[p.indexOf(d) - 1];
                    if (void 0 === m && (r.cssMode || f)) {
                        let e;
                        o.forEach((t, i) => {
                            d >= t && (e = i)
                        }), void 0 !== e && (m = f ? o[e] : o[e > 0 ? e - 1 : e])
                    }
                    let g = 0;
                    if (void 0 !== m && (g = s.indexOf(m), g < 0 && (g = n.activeIndex - 1), "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (g = g - n.slidesPerViewDynamic("previous", !0) + 1, g = Math.max(g, 0))), r.rewind && n.isBeginning) {
                        const r = n.params.virtual && n.params.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1;
                        return n.slideTo(r, e, t, i)
                    }
                    return r.loop && 0 === n.activeIndex && r.cssMode ? (requestAnimationFrame(() => {
                        n.slideTo(g, e, t, i)
                    }), !0) : n.slideTo(g, e, t, i)
                },
                slideReset: function (e, t, i) {
                    void 0 === t && (t = !0);
                    const n = this;
                    if (!n.destroyed) return void 0 === e && (e = n.params.speed), n.slideTo(n.activeIndex, e, t, i)
                },
                slideToClosest: function (e, t, i, n) {
                    void 0 === t && (t = !0), void 0 === n && (n = .5);
                    const r = this;
                    if (r.destroyed) return;
                    void 0 === e && (e = r.params.speed);
                    let o = r.activeIndex;
                    const s = Math.min(r.params.slidesPerGroupSkip, o),
                        a = s + Math.floor((o - s) / r.params.slidesPerGroup),
                        l = r.rtlTranslate ? r.translate : -r.translate;
                    if (l >= r.snapGrid[a]) {
                        const e = r.snapGrid[a];
                        l - e > (r.snapGrid[a + 1] - e) * n && (o += r.params.slidesPerGroup)
                    } else {
                        const e = r.snapGrid[a - 1];
                        l - e <= (r.snapGrid[a] - e) * n && (o -= r.params.slidesPerGroup)
                    }
                    return o = Math.max(o, 0), o = Math.min(o, r.slidesGrid.length - 1), r.slideTo(o, e, t, i)
                },
                slideToClickedSlide: function () {
                    const e = this;
                    if (e.destroyed) return;
                    const {
                        params: t,
                        slidesEl: i
                    } = e, n = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
                    let r, o = e.clickedIndex;
                    const s = e.isElement ? "swiper-slide" : "." + t.slideClass;
                    if (t.loop) {
                        if (e.animating) return;
                        r = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? o < e.loopedSlides - n / 2 || o > e.slides.length - e.loopedSlides + n / 2 ? (e.loopFix(), o = e.getSlideIndex(m(i, `${s}[data-swiper-slide-index="${r}"]`)[0]), a(() => {
                            e.slideTo(o)
                        })) : e.slideTo(o) : o > e.slides.length - n ? (e.loopFix(), o = e.getSlideIndex(m(i, `${s}[data-swiper-slide-index="${r}"]`)[0]), a(() => {
                            e.slideTo(o)
                        })) : e.slideTo(o)
                    } else e.slideTo(o)
                }
            },
            loop: {
                loopCreate: function (e) {
                    const t = this,
                        {
                            params: i,
                            slidesEl: n
                        } = t;
                    if (!i.loop || t.virtual && t.params.virtual.enabled) return;
                    const r = () => {
                            m(n, `.${i.slideClass}, swiper-slide`).forEach((e, t) => {
                                e.setAttribute("data-swiper-slide-index", t)
                            })
                        },
                        o = t.grid && i.grid && i.grid.rows > 1,
                        s = i.slidesPerGroup * (o ? i.grid.rows : 1),
                        a = t.slides.length % s != 0,
                        l = o && t.slides.length % i.grid.rows != 0,
                        c = e => {
                            for (let n = 0; n < e; n += 1) {
                                const e = t.isElement ? v("swiper-slide", [i.slideBlankClass]) : v("div", [i.slideClass, i.slideBlankClass]);
                                t.slidesEl.append(e)
                            }
                        };
                    a ? (i.loopAddBlankSlides ? (c(s - t.slides.length % s), t.recalcSlides(), t.updateSlides()) : g("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"), r()) : l ? (i.loopAddBlankSlides ? (c(i.grid.rows - t.slides.length % i.grid.rows), t.recalcSlides(), t.updateSlides()) : g("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"), r()) : r(), t.loopFix({
                        slideRealIndex: e,
                        direction: i.centeredSlides ? void 0 : "next"
                    })
                },
                loopFix: function (e) {
                    let {
                        slideRealIndex: t,
                        slideTo: i = !0,
                        direction: n,
                        setTranslate: r,
                        activeSlideIndex: o,
                        byController: s,
                        byMousewheel: a
                    } = void 0 === e ? {} : e;
                    const l = this;
                    if (!l.params.loop) return;
                    l.emit("beforeLoopFix");
                    const {
                        slides: c,
                        allowSlidePrev: u,
                        allowSlideNext: h,
                        slidesEl: d,
                        params: p
                    } = l, {
                        centeredSlides: f
                    } = p;
                    if (l.allowSlidePrev = !0, l.allowSlideNext = !0, l.virtual && p.virtual.enabled) return i && (p.centeredSlides || 0 !== l.snapIndex ? p.centeredSlides && l.snapIndex < p.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0) : l.slideTo(l.virtual.slides.length, 0, !1, !0)), l.allowSlidePrev = u, l.allowSlideNext = h, void l.emit("loopFix");
                    let m = p.slidesPerView;
                    "auto" === m ? m = l.slidesPerViewDynamic() : (m = Math.ceil(parseFloat(p.slidesPerView, 10)), f && m % 2 == 0 && (m += 1));
                    const v = p.slidesPerGroupAuto ? m : p.slidesPerGroup;
                    let y = v;
                    y % v != 0 && (y += v - y % v), y += p.loopAdditionalSlides, l.loopedSlides = y;
                    const b = l.grid && p.grid && p.grid.rows > 1;
                    c.length < m + y ? g("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : b && "row" === p.grid.fill && g("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
                    const x = [],
                        w = [];
                    let _ = l.activeIndex;
                    void 0 === o ? o = l.getSlideIndex(c.find(e => e.classList.contains(p.slideActiveClass))) : _ = o;
                    const E = "next" === n || !n,
                        M = "prev" === n || !n;
                    let S = 0,
                        T = 0;
                    const A = b ? Math.ceil(c.length / p.grid.rows) : c.length,
                        C = (b ? c[o].column : o) + (f && void 0 === r ? -m / 2 + .5 : 0);
                    if (C < y) {
                        S = Math.max(y - C, v);
                        for (let e = 0; e < y - C; e += 1) {
                            const t = e - Math.floor(e / A) * A;
                            if (b) {
                                const e = A - t - 1;
                                for (let t = c.length - 1; t >= 0; t -= 1) c[t].column === e && x.push(t)
                            } else x.push(A - t - 1)
                        }
                    } else if (C + m > A - y) {
                        T = Math.max(C - (A - 2 * y), v);
                        for (let e = 0; e < T; e += 1) {
                            const t = e - Math.floor(e / A) * A;
                            b ? c.forEach((e, i) => {
                                e.column === t && w.push(i)
                            }) : w.push(t)
                        }
                    }
                    if (l.__preventObserver__ = !0, requestAnimationFrame(() => {
                            l.__preventObserver__ = !1
                        }), M && x.forEach(e => {
                            c[e].swiperLoopMoveDOM = !0, d.prepend(c[e]), c[e].swiperLoopMoveDOM = !1
                        }), E && w.forEach(e => {
                            c[e].swiperLoopMoveDOM = !0, d.append(c[e]), c[e].swiperLoopMoveDOM = !1
                        }), l.recalcSlides(), "auto" === p.slidesPerView ? l.updateSlides() : b && (x.length > 0 && M || w.length > 0 && E) && l.slides.forEach((e, t) => {
                            l.grid.updateSlide(t, e, l.slides)
                        }), p.watchSlidesProgress && l.updateSlidesOffset(), i)
                        if (x.length > 0 && M) {
                            if (void 0 === t) {
                                const e = l.slidesGrid[_],
                                    t = l.slidesGrid[_ + S] - e;
                                a ? l.setTranslate(l.translate - t) : (l.slideTo(_ + Math.ceil(S), 0, !1, !0), r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
                            } else if (r) {
                                const e = b ? x.length / p.grid.rows : x.length;
                                l.slideTo(l.activeIndex + e, 0, !1, !0), l.touchEventsData.currentTranslate = l.translate
                            }
                        } else if (w.length > 0 && E)
                        if (void 0 === t) {
                            const e = l.slidesGrid[_],
                                t = l.slidesGrid[_ - T] - e;
                            a ? l.setTranslate(l.translate - t) : (l.slideTo(_ - T, 0, !1, !0), r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
                        } else {
                            const e = b ? w.length / p.grid.rows : w.length;
                            l.slideTo(l.activeIndex - e, 0, !1, !0)
                        } if (l.allowSlidePrev = u, l.allowSlideNext = h, l.controller && l.controller.control && !s) {
                        const e = {
                            slideRealIndex: t,
                            direction: n,
                            setTranslate: r,
                            activeSlideIndex: o,
                            byController: !0
                        };
                        Array.isArray(l.controller.control) ? l.controller.control.forEach(t => {
                            !t.destroyed && t.params.loop && t.loopFix({
                                ...e,
                                slideTo: t.params.slidesPerView === p.slidesPerView && i
                            })
                        }) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({
                            ...e,
                            slideTo: l.controller.control.params.slidesPerView === p.slidesPerView && i
                        })
                    }
                    l.emit("loopFix")
                },
                loopDestroy: function () {
                    const e = this,
                        {
                            params: t,
                            slidesEl: i
                        } = e;
                    if (!t.loop || e.virtual && e.params.virtual.enabled) return;
                    e.recalcSlides();
                    const n = [];
                    e.slides.forEach(e => {
                        const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex;
                        n[t] = e
                    }), e.slides.forEach(e => {
                        e.removeAttribute("data-swiper-slide-index")
                    }), n.forEach(e => {
                        i.append(e)
                    }), e.recalcSlides(), e.slideTo(e.realIndex, 0)
                }
            },
            grabCursor: {
                setGrabCursor: function (e) {
                    const t = this;
                    if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
                    const i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                    t.isElement && (t.__preventObserver__ = !0), i.style.cursor = "move", i.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame(() => {
                        t.__preventObserver__ = !1
                    })
                },
                unsetGrabCursor: function () {
                    const e = this;
                    e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame(() => {
                        e.__preventObserver__ = !1
                    }))
                }
            },
            events: {
                attachEvents: function () {
                    const e = this,
                        {
                            params: t
                        } = e;
                    e.onTouchStart = F.bind(e), e.onTouchMove = H.bind(e), e.onTouchEnd = U.bind(e), e.onDocumentTouchStart = q.bind(e), t.cssMode && (e.onScroll = V.bind(e)), e.onClick = G.bind(e), e.onLoad = W.bind(e), X(e, "on")
                },
                detachEvents: function () {
                    X(this, "off")
                }
            },
            breakpoints: {
                setBreakpoint: function () {
                    const e = this,
                        {
                            realIndex: t,
                            initialized: i,
                            params: r,
                            el: o
                        } = e,
                        s = r.breakpoints;
                    if (!s || s && 0 === Object.keys(s).length) return;
                    const a = n(),
                        l = "window" !== r.breakpointsBase && r.breakpointsBase ? "container" : r.breakpointsBase,
                        c = ["window", "container"].includes(r.breakpointsBase) || !r.breakpointsBase ? e.el : a.querySelector(r.breakpointsBase),
                        u = e.getBreakpoint(s, l, c);
                    if (!u || e.currentBreakpoint === u) return;
                    const d = (u in s ? s[u] : void 0) || e.originalParams,
                        p = Y(e, r),
                        f = Y(e, d),
                        m = e.params.grabCursor,
                        g = d.grabCursor,
                        v = r.enabled;
                    p && !f ? (o.classList.remove(r.containerModifierClass + "grid", r.containerModifierClass + "grid-column"), e.emitContainerClasses()) : !p && f && (o.classList.add(r.containerModifierClass + "grid"), (d.grid.fill && "column" === d.grid.fill || !d.grid.fill && "column" === r.grid.fill) && o.classList.add(r.containerModifierClass + "grid-column"), e.emitContainerClasses()), m && !g ? e.unsetGrabCursor() : !m && g && e.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(t => {
                        if (void 0 === d[t]) return;
                        const i = r[t] && r[t].enabled,
                            n = d[t] && d[t].enabled;
                        i && !n && e[t].disable(), !i && n && e[t].enable()
                    });
                    const y = d.direction && d.direction !== r.direction,
                        b = r.loop && (d.slidesPerView !== r.slidesPerView || y),
                        x = r.loop;
                    y && i && e.changeDirection(), h(e.params, d);
                    const w = e.params.enabled,
                        _ = e.params.loop;
                    Object.assign(e, {
                        allowTouchMove: e.params.allowTouchMove,
                        allowSlideNext: e.params.allowSlideNext,
                        allowSlidePrev: e.params.allowSlidePrev
                    }), v && !w ? e.disable() : !v && w && e.enable(), e.currentBreakpoint = u, e.emit("_beforeBreakpoint", d), i && (b ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !x && _ ? (e.loopCreate(t), e.updateSlides()) : x && !_ && e.loopDestroy()), e.emit("breakpoint", d)
                },
                getBreakpoint: function (e, t, i) {
                    if (void 0 === t && (t = "window"), !e || "container" === t && !i) return;
                    let n = !1;
                    const r = o(),
                        s = "window" === t ? r.innerHeight : i.clientHeight,
                        a = Object.keys(e).map(e => {
                            if ("string" == typeof e && 0 === e.indexOf("@")) {
                                const t = parseFloat(e.substr(1));
                                return {
                                    value: s * t,
                                    point: e
                                }
                            }
                            return {
                                value: e,
                                point: e
                            }
                        });
                    a.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10));
                    for (let e = 0; e < a.length; e += 1) {
                        const {
                            point: o,
                            value: s
                        } = a[e];
                        "window" === t ? r.matchMedia(`(min-width: ${s}px)`).matches && (n = o) : s <= i.clientWidth && (n = o)
                    }
                    return n || "max"
                }
            },
            checkOverflow: {
                checkOverflow: function () {
                    const e = this,
                        {
                            isLocked: t,
                            params: i
                        } = e,
                        {
                            slidesOffsetBefore: n
                        } = i;
                    if (n) {
                        const t = e.slides.length - 1,
                            i = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * n;
                        e.isLocked = e.size > i
                    } else e.isLocked = 1 === e.snapGrid.length;
                    !0 === i.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === i.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
                }
            },
            classes: {
                addClasses: function () {
                    const e = this,
                        {
                            classNames: t,
                            params: i,
                            rtl: n,
                            el: r,
                            device: o
                        } = e,
                        s = function (e, t) {
                            const i = [];
                            return e.forEach(e => {
                                "object" == typeof e ? Object.keys(e).forEach(n => {
                                    e[n] && i.push(t + n)
                                }) : "string" == typeof e && i.push(t + e)
                            }), i
                        }(["initialized", i.direction, {
                            "free-mode": e.params.freeMode && i.freeMode.enabled
                        }, {
                            autoheight: i.autoHeight
                        }, {
                            rtl: n
                        }, {
                            grid: i.grid && i.grid.rows > 1
                        }, {
                            "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill
                        }, {
                            android: o.android
                        }, {
                            ios: o.ios
                        }, {
                            "css-mode": i.cssMode
                        }, {
                            centered: i.cssMode && i.centeredSlides
                        }, {
                            "watch-progress": i.watchSlidesProgress
                        }], i.containerModifierClass);
                    t.push(...s), r.classList.add(...t), e.emitContainerClasses()
                },
                removeClasses: function () {
                    const {
                        el: e,
                        classNames: t
                    } = this;
                    e && "string" != typeof e && (e.classList.remove(...t), this.emitContainerClasses())
                }
            }
        },
        K = {};
    class $ {
        constructor() {
            let e, t;
            for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++) r[o] = arguments[o];
            1 === r.length && r[0].constructor && "Object" === Object.prototype.toString.call(r[0]).slice(8, -1) ? t = r[0] : [e, t] = r, t || (t = {}), t = h({}, t), e && !t.el && (t.el = e);
            const s = n();
            if (t.el && "string" == typeof t.el && s.querySelectorAll(t.el).length > 1) {
                const e = [];
                return s.querySelectorAll(t.el).forEach(i => {
                    const n = h({}, t, {
                        el: i
                    });
                    e.push(new $(n))
                }), e
            }
            const a = this;
            a.__swiper__ = !0, a.support = L(), a.device = P({
                userAgent: t.userAgent
            }), a.browser = I(), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], t.modules && Array.isArray(t.modules) && a.modules.push(...t.modules);
            const l = {};
            a.modules.forEach(e => {
                e({
                    params: t,
                    swiper: a,
                    extendParams: Q(t, l),
                    on: a.on.bind(a),
                    once: a.once.bind(a),
                    off: a.off.bind(a),
                    emit: a.emit.bind(a)
                })
            });
            const c = h({}, Z, l);
            return a.params = h({}, c, K, t), a.originalParams = h({}, a.params), a.passedParams = h({}, t), a.params && a.params.on && Object.keys(a.params.on).forEach(e => {
                a.on(e, a.params.on[e])
            }), a.params && a.params.onAny && a.onAny(a.params.onAny), Object.assign(a, {
                enabled: a.params.enabled,
                el: e,
                classNames: [],
                slides: [],
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: () => "horizontal" === a.params.direction,
                isVertical: () => "vertical" === a.params.direction,
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                cssOverflowAdjustment() {
                    return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
                },
                allowSlideNext: a.params.allowSlideNext,
                allowSlidePrev: a.params.allowSlidePrev,
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    focusableElements: a.params.focusableElements,
                    lastClickTime: 0,
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    startMoving: void 0,
                    pointerId: null,
                    touchId: null
                },
                allowClick: !0,
                allowTouchMove: a.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            }), a.emit("_swiper"), a.params.init && a.init(), a
        }
        getDirectionLabel(e) {
            return this.isHorizontal() ? e : {
                width: "height",
                "margin-top": "margin-left",
                "margin-bottom ": "margin-right",
                "margin-left": "margin-top",
                "margin-right": "margin-bottom",
                "padding-left": "padding-top",
                "padding-right": "padding-bottom",
                marginRight: "marginBottom"
            } [e]
        }
        getSlideIndex(e) {
            const {
                slidesEl: t,
                params: i
            } = this, n = x(m(t, `.${i.slideClass}, swiper-slide`)[0]);
            return x(e) - n
        }
        getSlideIndexByData(e) {
            return this.getSlideIndex(this.slides.find(t => 1 * t.getAttribute("data-swiper-slide-index") === e))
        }
        recalcSlides() {
            const {
                slidesEl: e,
                params: t
            } = this;
            this.slides = m(e, `.${t.slideClass}, swiper-slide`)
        }
        enable() {
            const e = this;
            e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
        }
        disable() {
            const e = this;
            e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
        }
        setProgress(e, t) {
            const i = this;
            e = Math.min(Math.max(e, 0), 1);
            const n = i.minTranslate(),
                r = (i.maxTranslate() - n) * e + n;
            i.translateTo(r, void 0 === t ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses()
        }
        emitContainerClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = e.el.className.split(" ").filter(t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass));
            e.emit("_containerClasses", t.join(" "))
        }
        getSlideClasses(e) {
            const t = this;
            return t.destroyed ? "" : e.className.split(" ").filter(e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass)).join(" ")
        }
        emitSlidesClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = [];
            e.slides.forEach(i => {
                const n = e.getSlideClasses(i);
                t.push({
                    slideEl: i,
                    classNames: n
                }), e.emit("_slideClass", i, n)
            }), e.emit("_slideClasses", t)
        }
        slidesPerViewDynamic(e, t) {
            void 0 === e && (e = "current"), void 0 === t && (t = !1);
            const {
                params: i,
                slides: n,
                slidesGrid: r,
                slidesSizesGrid: o,
                size: s,
                activeIndex: a
            } = this;
            let l = 1;
            if ("number" == typeof i.slidesPerView) return i.slidesPerView;
            if (i.centeredSlides) {
                let e, t = n[a] ? Math.ceil(n[a].swiperSlideSize) : 0;
                for (let i = a + 1; i < n.length; i += 1) n[i] && !e && (t += Math.ceil(n[i].swiperSlideSize), l += 1, t > s && (e = !0));
                for (let i = a - 1; i >= 0; i -= 1) n[i] && !e && (t += n[i].swiperSlideSize, l += 1, t > s && (e = !0))
            } else if ("current" === e)
                for (let e = a + 1; e < n.length; e += 1)(t ? r[e] + o[e] - r[a] < s : r[e] - r[a] < s) && (l += 1);
            else
                for (let e = a - 1; e >= 0; e -= 1) r[a] - r[e] < s && (l += 1);
            return l
        }
        update() {
            const e = this;
            if (!e || e.destroyed) return;
            const {
                snapGrid: t,
                params: i
            } = e;

            function n() {
                const t = e.rtlTranslate ? -1 * e.translate : e.translate,
                    i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses()
            }
            let r;
            if (i.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(t => {
                    t.complete && D(e, t)
                }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), i.freeMode && i.freeMode.enabled && !i.cssMode) n(), i.autoHeight && e.updateAutoHeight();
            else {
                if (("auto" === i.slidesPerView || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) {
                    const t = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides;
                    r = e.slideTo(t.length - 1, 0, !1, !0)
                } else r = e.slideTo(e.activeIndex, 0, !1, !0);
                r || n()
            }
            i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
        }
        changeDirection(e, t) {
            void 0 === t && (t = !0);
            const i = this,
                n = i.params.direction;
            return e || (e = "horizontal" === n ? "vertical" : "horizontal"), e === n || "horizontal" !== e && "vertical" !== e || (i.el.classList.remove(`${i.params.containerModifierClass}${n}`), i.el.classList.add(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.forEach(t => {
                "vertical" === e ? t.style.width = "" : t.style.height = ""
            }), i.emit("changeDirection"), t && i.update()), i
        }
        changeLanguageDirection(e) {
            const t = this;
            t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(t.params.containerModifierClass + "rtl"), t.el.dir = "rtl") : (t.el.classList.remove(t.params.containerModifierClass + "rtl"), t.el.dir = "ltr"), t.update())
        }
        mount(e) {
            const t = this;
            if (t.mounted) return !0;
            let i = e || t.params.el;
            if ("string" == typeof i && (i = document.querySelector(i)), !i) return !1;
            i.swiper = t, i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
            const n = () => "." + (t.params.wrapperClass || "").trim().split(" ").join(".");
            let r = i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(n()) : m(i, n())[0];
            return !r && t.params.createElements && (r = v("div", t.params.wrapperClass), i.append(r), m(i, "." + t.params.slideClass).forEach(e => {
                r.append(e)
            })), Object.assign(t, {
                el: i,
                wrapperEl: r,
                slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : r,
                hostEl: t.isElement ? i.parentNode.host : i,
                mounted: !0,
                rtl: "rtl" === i.dir.toLowerCase() || "rtl" === b(i, "direction"),
                rtlTranslate: "horizontal" === t.params.direction && ("rtl" === i.dir.toLowerCase() || "rtl" === b(i, "direction")),
                wrongRTL: "-webkit-box" === b(r, "display")
            }), !0
        }
        init(e) {
            const t = this;
            if (t.initialized) return t;
            if (!1 === t.mount(e)) return t;
            t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents();
            const i = [...t.el.querySelectorAll('[loading="lazy"]')];
            return t.isElement && i.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), i.forEach(e => {
                e.complete ? D(t, e) : e.addEventListener("load", e => {
                    D(t, e.target)
                })
            }), z(t), t.initialized = !0, z(t), t.emit("init"), t.emit("afterInit"), t
        }
        destroy(e, t) {
            void 0 === e && (e = !0), void 0 === t && (t = !0);
            const i = this,
                {
                    params: n,
                    el: r,
                    wrapperEl: o,
                    slides: s
                } = i;
            return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), n.loop && i.loopDestroy(), t && (i.removeClasses(), r && "string" != typeof r && r.removeAttribute("style"), o && o.removeAttribute("style"), s && s.length && s.forEach(e => {
                e.classList.remove(n.slideVisibleClass, n.slideFullyVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index")
            })), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(e => {
                i.off(e)
            }), !1 !== e && (i.el && "string" != typeof i.el && (i.el.swiper = null), function (e) {
                const t = e;
                Object.keys(t).forEach(e => {
                    try {
                        t[e] = null
                    } catch (e) {}
                    try {
                        delete t[e]
                    } catch (e) {}
                })
            }(i)), i.destroyed = !0), null
        }
        static extendDefaults(e) {
            h(K, e)
        }
        static get extendedDefaults() {
            return K
        }
        static get defaults() {
            return Z
        }
        static installModule(e) {
            $.prototype.__modules__ || ($.prototype.__modules__ = []);
            const t = $.prototype.__modules__;
            "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
        }
        static use(e) {
            return Array.isArray(e) ? (e.forEach(e => $.installModule(e)), $) : ($.installModule(e), $)
        }
    }

    function ee(e, t, i, n) {
        return e.params.createElements && Object.keys(n).forEach(r => {
            if (!i[r] && !0 === i.auto) {
                let o = m(e.el, "." + n[r])[0];
                o || (o = v("div", n[r]), o.className = n[r], e.el.append(o)), i[r] = o, t[r] = o
            }
        }), i
    }

    function te(e) {
        return void 0 === e && (e = ""), "." + e.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")
    }

    function ie(e) {
        const t = this,
            {
                params: i,
                slidesEl: n
            } = t;
        i.loop && t.loopDestroy();
        const r = e => {
            if ("string" == typeof e) {
                const t = document.createElement("div");
                t.innerHTML = e, n.append(t.children[0]), t.innerHTML = ""
            } else n.append(e)
        };
        if ("object" == typeof e && "length" in e)
            for (let t = 0; t < e.length; t += 1) e[t] && r(e[t]);
        else r(e);
        t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update()
    }

    function ne(e) {
        const t = this,
            {
                params: i,
                activeIndex: n,
                slidesEl: r
            } = t;
        i.loop && t.loopDestroy();
        let o = n + 1;
        const s = e => {
            if ("string" == typeof e) {
                const t = document.createElement("div");
                t.innerHTML = e, r.prepend(t.children[0]), t.innerHTML = ""
            } else r.prepend(e)
        };
        if ("object" == typeof e && "length" in e) {
            for (let t = 0; t < e.length; t += 1) e[t] && s(e[t]);
            o = n + e.length
        } else s(e);
        t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update(), t.slideTo(o, 0, !1)
    }

    function re(e, t) {
        const i = this,
            {
                params: n,
                activeIndex: r,
                slidesEl: o
            } = i;
        let s = r;
        n.loop && (s -= i.loopedSlides, i.loopDestroy(), i.recalcSlides());
        const a = i.slides.length;
        if (e <= 0) return void i.prependSlide(t);
        if (e >= a) return void i.appendSlide(t);
        let l = s > e ? s + 1 : s;
        const c = [];
        for (let t = a - 1; t >= e; t -= 1) {
            const e = i.slides[t];
            e.remove(), c.unshift(e)
        }
        if ("object" == typeof t && "length" in t) {
            for (let e = 0; e < t.length; e += 1) t[e] && o.append(t[e]);
            l = s > e ? s + t.length : s
        } else o.append(t);
        for (let e = 0; e < c.length; e += 1) o.append(c[e]);
        i.recalcSlides(), n.loop && i.loopCreate(), n.observer && !i.isElement || i.update(), n.loop ? i.slideTo(l + i.loopedSlides, 0, !1) : i.slideTo(l, 0, !1)
    }

    function oe(e) {
        const t = this,
            {
                params: i,
                activeIndex: n
            } = t;
        let r = n;
        i.loop && (r -= t.loopedSlides, t.loopDestroy());
        let o, s = r;
        if ("object" == typeof e && "length" in e) {
            for (let i = 0; i < e.length; i += 1) o = e[i], t.slides[o] && t.slides[o].remove(), o < s && (s -= 1);
            s = Math.max(s, 0)
        } else o = e, t.slides[o] && t.slides[o].remove(), o < s && (s -= 1), s = Math.max(s, 0);
        t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update(), i.loop ? t.slideTo(s + t.loopedSlides, 0, !1) : t.slideTo(s, 0, !1)
    }

    function se() {
        const e = this,
            t = [];
        for (let i = 0; i < e.slides.length; i += 1) t.push(i);
        e.removeSlide(t)
    }

    function ae(e) {
        const {
            effect: t,
            swiper: i,
            on: n,
            setTranslate: r,
            setTransition: o,
            overwriteParams: s,
            perspective: a,
            recreateShadows: l,
            getEffectParams: c
        } = e;
        let u;
        n("beforeInit", () => {
            if (i.params.effect !== t) return;
            i.classNames.push(`${i.params.containerModifierClass}${t}`), a && a() && i.classNames.push(i.params.containerModifierClass + "3d");
            const e = s ? s() : {};
            Object.assign(i.params, e), Object.assign(i.originalParams, e)
        }), n("setTranslate", () => {
            i.params.effect === t && r()
        }), n("setTransition", (e, n) => {
            i.params.effect === t && o(n)
        }), n("transitionEnd", () => {
            if (i.params.effect === t && l) {
                if (!c || !c().slideShadows) return;
                i.slides.forEach(e => {
                    e.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(e => e.remove())
                }), l()
            }
        }), n("virtualUpdate", () => {
            i.params.effect === t && (i.slides.length || (u = !0), requestAnimationFrame(() => {
                u && i.slides && i.slides.length && (r(), u = !1)
            }))
        })
    }

    function le(e, t) {
        const i = f(t);
        return i !== t && (i.style.backfaceVisibility = "hidden", i.style["-webkit-backface-visibility"] = "hidden"), i
    }

    function ce(e) {
        let {
            swiper: t,
            duration: i,
            transformElements: n,
            allSlides: r
        } = e;
        const {
            activeIndex: o
        } = t;
        if (t.params.virtualTranslate && 0 !== i) {
            let e, i = !1;
            e = r ? n : n.filter(e => {
                const i = e.classList.contains("swiper-slide-transform") ? (e => e.parentElement ? e.parentElement : t.slides.find(t => t.shadowRoot && t.shadowRoot === e.parentNode))(e) : e;
                return t.getSlideIndex(i) === o
            }), e.forEach(e => {
                _(e, () => {
                    if (i) return;
                    if (!t || t.destroyed) return;
                    i = !0, t.animating = !1;
                    const e = new window.CustomEvent("transitionend", {
                        bubbles: !0,
                        cancelable: !0
                    });
                    t.wrapperEl.dispatchEvent(e)
                })
            })
        }
    }

    function ue(e, t, i) {
        const n = `swiper-slide-shadow${i?"-"+i:""}${e?" swiper-slide-shadow-"+e:""}`,
            r = f(t);
        let o = r.querySelector("." + n.split(" ").join("."));
        return o || (o = v("div", n.split(" ")), r.append(o)), o
    }
    Object.keys(J).forEach(e => {
        Object.keys(J[e]).forEach(t => {
            $.prototype[t] = J[e][t]
        })
    }), $.use([function (e) {
        let {
            swiper: t,
            on: i,
            emit: n
        } = e;
        const r = o();
        let s = null,
            a = null;
        const l = () => {
                t && !t.destroyed && t.initialized && (n("beforeResize"), n("resize"))
            },
            c = () => {
                t && !t.destroyed && t.initialized && n("orientationchange")
            };
        i("init", () => {
            t.params.resizeObserver && void 0 !== r.ResizeObserver ? t && !t.destroyed && t.initialized && (s = new ResizeObserver(e => {
                a = r.requestAnimationFrame(() => {
                    const {
                        width: i,
                        height: n
                    } = t;
                    let r = i,
                        o = n;
                    e.forEach(e => {
                        let {
                            contentBoxSize: i,
                            contentRect: n,
                            target: s
                        } = e;
                        s && s !== t.el || (r = n ? n.width : (i[0] || i).inlineSize, o = n ? n.height : (i[0] || i).blockSize)
                    }), r === i && o === n || l()
                })
            }), s.observe(t.el)) : (r.addEventListener("resize", l), r.addEventListener("orientationchange", c))
        }), i("destroy", () => {
            a && r.cancelAnimationFrame(a), s && s.unobserve && t.el && (s.unobserve(t.el), s = null), r.removeEventListener("resize", l), r.removeEventListener("orientationchange", c)
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n,
            emit: r
        } = e;
        const s = [],
            a = o(),
            l = function (e, i) {
                void 0 === i && (i = {});
                const n = new(a.MutationObserver || a.WebkitMutationObserver)(e => {
                    if (t.__preventObserver__) return;
                    if (1 === e.length) return void r("observerUpdate", e[0]);
                    const i = function () {
                        r("observerUpdate", e[0])
                    };
                    a.requestAnimationFrame ? a.requestAnimationFrame(i) : a.setTimeout(i, 0)
                });
                n.observe(e, {
                    attributes: void 0 === i.attributes || i.attributes,
                    childList: t.isElement || (void 0 === i.childList || i).childList,
                    characterData: void 0 === i.characterData || i.characterData
                }), s.push(n)
            };
        i({
            observer: !1,
            observeParents: !1,
            observeSlideChildren: !1
        }), n("init", () => {
            if (t.params.observer) {
                if (t.params.observeParents) {
                    const e = w(t.hostEl);
                    for (let t = 0; t < e.length; t += 1) l(e[t])
                }
                l(t.hostEl, {
                    childList: t.params.observeSlideChildren
                }), l(t.wrapperEl, {
                    attributes: !1
                })
            }
        }), n("destroy", () => {
            s.forEach(e => {
                e.disconnect()
            }), s.splice(0, s.length)
        })
    }]);
    const he = [function (e) {
        let t, {
            swiper: i,
            extendParams: r,
            on: o,
            emit: s
        } = e;
        r({
            virtual: {
                enabled: !1,
                slides: [],
                cache: !0,
                renderSlide: null,
                renderExternal: null,
                renderExternalUpdate: !0,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        });
        const a = n();
        i.virtual = {
            cache: {},
            from: void 0,
            to: void 0,
            slides: [],
            offset: 0,
            slidesGrid: []
        };
        const l = a.createElement("div");

        function c(e, t) {
            const n = i.params.virtual;
            if (n.cache && i.virtual.cache[t]) return i.virtual.cache[t];
            let r;
            return n.renderSlide ? (r = n.renderSlide.call(i, e, t), "string" == typeof r && (l.innerHTML = r, r = l.children[0])) : r = i.isElement ? v("swiper-slide") : v("div", i.params.slideClass), r.setAttribute("data-swiper-slide-index", t), n.renderSlide || (r.innerHTML = e), n.cache && (i.virtual.cache[t] = r), r
        }

        function u(e, t, n) {
            const {
                slidesPerView: r,
                slidesPerGroup: o,
                centeredSlides: a,
                loop: l,
                initialSlide: u
            } = i.params;
            if (t && !l && u > 0) return;
            const {
                addSlidesBefore: h,
                addSlidesAfter: d
            } = i.params.virtual, {
                from: p,
                to: f,
                slides: g,
                slidesGrid: v,
                offset: y
            } = i.virtual;
            i.params.cssMode || i.updateActiveIndex();
            const b = void 0 === n ? i.activeIndex || 0 : n;
            let x, w, _;
            x = i.rtlTranslate ? "right" : i.isHorizontal() ? "left" : "top", a ? (w = Math.floor(r / 2) + o + d, _ = Math.floor(r / 2) + o + h) : (w = r + (o - 1) + d, _ = (l ? r : o) + h);
            let E = b - _,
                M = b + w;
            l || (E = Math.max(E, 0), M = Math.min(M, g.length - 1));
            let S = (i.slidesGrid[E] || 0) - (i.slidesGrid[0] || 0);

            function T() {
                i.updateSlides(), i.updateProgress(), i.updateSlidesClasses(), s("virtualUpdate")
            }
            if (l && b >= _ ? (E -= _, a || (S += i.slidesGrid[0])) : l && b < _ && (E = -_, a && (S += i.slidesGrid[0])), Object.assign(i.virtual, {
                    from: E,
                    to: M,
                    offset: S,
                    slidesGrid: i.slidesGrid,
                    slidesBefore: _,
                    slidesAfter: w
                }), p === E && f === M && !e) return i.slidesGrid !== v && S !== y && i.slides.forEach(e => {
                e.style[x] = S - Math.abs(i.cssOverflowAdjustment()) + "px"
            }), i.updateProgress(), void s("virtualUpdate");
            if (i.params.virtual.renderExternal) return i.params.virtual.renderExternal.call(i, {
                offset: S,
                from: E,
                to: M,
                slides: function () {
                    const e = [];
                    for (let t = E; t <= M; t += 1) e.push(g[t]);
                    return e
                }()
            }), void(i.params.virtual.renderExternalUpdate ? T() : s("virtualUpdate"));
            const A = [],
                C = [],
                L = e => {
                    let t = e;
                    return e < 0 ? t = g.length + e : t >= g.length && (t -= g.length), t
                };
            if (e) i.slides.filter(e => e.matches(`.${i.params.slideClass}, swiper-slide`)).forEach(e => {
                e.remove()
            });
            else
                for (let e = p; e <= f; e += 1)
                    if (e < E || e > M) {
                        const t = L(e);
                        i.slides.filter(e => e.matches(`.${i.params.slideClass}[data-swiper-slide-index="${t}"], swiper-slide[data-swiper-slide-index="${t}"]`)).forEach(e => {
                            e.remove()
                        })
                    } const P = l ? -g.length : 0,
                I = l ? 2 * g.length : g.length;
            for (let t = P; t < I; t += 1)
                if (t >= E && t <= M) {
                    const i = L(t);
                    void 0 === f || e ? C.push(i) : (t > f && C.push(i), t < p && A.push(i))
                } if (C.forEach(e => {
                    i.slidesEl.append(c(g[e], e))
                }), l)
                for (let e = A.length - 1; e >= 0; e -= 1) {
                    const t = A[e];
                    i.slidesEl.prepend(c(g[t], t))
                } else A.sort((e, t) => t - e), A.forEach(e => {
                    i.slidesEl.prepend(c(g[e], e))
                });
            m(i.slidesEl, ".swiper-slide, swiper-slide").forEach(e => {
                e.style[x] = S - Math.abs(i.cssOverflowAdjustment()) + "px"
            }), T()
        }
        o("beforeInit", () => {
            if (!i.params.virtual.enabled) return;
            let e;
            if (void 0 === i.passedParams.virtual.slides) {
                const t = [...i.slidesEl.children].filter(e => e.matches(`.${i.params.slideClass}, swiper-slide`));
                t && t.length && (i.virtual.slides = [...t], e = !0, t.forEach((e, t) => {
                    e.setAttribute("data-swiper-slide-index", t), i.virtual.cache[t] = e, e.remove()
                }))
            }
            e || (i.virtual.slides = i.params.virtual.slides), i.classNames.push(i.params.containerModifierClass + "virtual"), i.params.watchSlidesProgress = !0, i.originalParams.watchSlidesProgress = !0, u(!1, !0)
        }), o("setTranslate", () => {
            i.params.virtual.enabled && (i.params.cssMode && !i._immediateVirtual ? (clearTimeout(t), t = setTimeout(() => {
                u()
            }, 100)) : u())
        }), o("init update resize", () => {
            i.params.virtual.enabled && i.params.cssMode && d(i.wrapperEl, "--swiper-virtual-size", i.virtualSize + "px")
        }), Object.assign(i.virtual, {
            appendSlide: function (e) {
                if ("object" == typeof e && "length" in e)
                    for (let t = 0; t < e.length; t += 1) e[t] && i.virtual.slides.push(e[t]);
                else i.virtual.slides.push(e);
                u(!0)
            },
            prependSlide: function (e) {
                const t = i.activeIndex;
                let n = t + 1,
                    r = 1;
                if (Array.isArray(e)) {
                    for (let t = 0; t < e.length; t += 1) e[t] && i.virtual.slides.unshift(e[t]);
                    n = t + e.length, r = e.length
                } else i.virtual.slides.unshift(e);
                if (i.params.virtual.cache) {
                    const e = i.virtual.cache,
                        t = {};
                    Object.keys(e).forEach(i => {
                        const n = e[i],
                            o = n.getAttribute("data-swiper-slide-index");
                        o && n.setAttribute("data-swiper-slide-index", parseInt(o, 10) + r), t[parseInt(i, 10) + r] = n
                    }), i.virtual.cache = t
                }
                u(!0), i.slideTo(n, 0)
            },
            removeSlide: function (e) {
                if (null == e) return;
                let t = i.activeIndex;
                if (Array.isArray(e))
                    for (let n = e.length - 1; n >= 0; n -= 1) i.params.virtual.cache && (delete i.virtual.cache[e[n]], Object.keys(i.virtual.cache).forEach(t => {
                        t > e && (i.virtual.cache[t - 1] = i.virtual.cache[t], i.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete i.virtual.cache[t])
                    })), i.virtual.slides.splice(e[n], 1), e[n] < t && (t -= 1), t = Math.max(t, 0);
                else i.params.virtual.cache && (delete i.virtual.cache[e], Object.keys(i.virtual.cache).forEach(t => {
                    t > e && (i.virtual.cache[t - 1] = i.virtual.cache[t], i.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete i.virtual.cache[t])
                })), i.virtual.slides.splice(e, 1), e < t && (t -= 1), t = Math.max(t, 0);
                u(!0), i.slideTo(t, 0)
            },
            removeAllSlides: function () {
                i.virtual.slides = [], i.params.virtual.cache && (i.virtual.cache = {}), u(!0), i.slideTo(0, 0)
            },
            update: u
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: r,
            emit: s
        } = e;
        const a = n(),
            l = o();

        function c(e) {
            if (!t.enabled) return;
            const {
                rtlTranslate: i
            } = t;
            let n = e;
            n.originalEvent && (n = n.originalEvent);
            const r = n.keyCode || n.charCode,
                o = t.params.keyboard.pageUpDown,
                c = o && 33 === r,
                u = o && 34 === r,
                h = 37 === r,
                d = 39 === r,
                p = 38 === r,
                f = 40 === r;
            if (!t.allowSlideNext && (t.isHorizontal() && d || t.isVertical() && f || u)) return !1;
            if (!t.allowSlidePrev && (t.isHorizontal() && h || t.isVertical() && p || c)) return !1;
            if (!(n.shiftKey || n.altKey || n.ctrlKey || n.metaKey || a.activeElement && a.activeElement.nodeName && ("input" === a.activeElement.nodeName.toLowerCase() || "textarea" === a.activeElement.nodeName.toLowerCase()))) {
                if (t.params.keyboard.onlyInViewport && (c || u || h || d || p || f)) {
                    let e = !1;
                    if (w(t.el, `.${t.params.slideClass}, swiper-slide`).length > 0 && 0 === w(t.el, "." + t.params.slideActiveClass).length) return;
                    const n = t.el,
                        r = n.clientWidth,
                        o = n.clientHeight,
                        s = l.innerWidth,
                        a = l.innerHeight,
                        c = y(n);
                    i && (c.left -= n.scrollLeft);
                    const u = [
                        [c.left, c.top],
                        [c.left + r, c.top],
                        [c.left, c.top + o],
                        [c.left + r, c.top + o]
                    ];
                    for (let t = 0; t < u.length; t += 1) {
                        const i = u[t];
                        if (i[0] >= 0 && i[0] <= s && i[1] >= 0 && i[1] <= a) {
                            if (0 === i[0] && 0 === i[1]) continue;
                            e = !0
                        }
                    }
                    if (!e) return
                }
                t.isHorizontal() ? ((c || u || h || d) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), ((u || d) && !i || (c || h) && i) && t.slideNext(), ((c || h) && !i || (u || d) && i) && t.slidePrev()) : ((c || u || p || f) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), (u || f) && t.slideNext(), (c || p) && t.slidePrev()), s("keyPress", r)
            }
        }

        function u() {
            t.keyboard.enabled || (a.addEventListener("keydown", c), t.keyboard.enabled = !0)
        }

        function h() {
            t.keyboard.enabled && (a.removeEventListener("keydown", c), t.keyboard.enabled = !1)
        }
        t.keyboard = {
            enabled: !1
        }, i({
            keyboard: {
                enabled: !1,
                onlyInViewport: !0,
                pageUpDown: !0
            }
        }), r("init", () => {
            t.params.keyboard.enabled && u()
        }), r("destroy", () => {
            t.keyboard.enabled && h()
        }), Object.assign(t.keyboard, {
            enable: u,
            disable: h
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n,
            emit: r
        } = e;
        const s = o();
        let c;
        i({
            mousewheel: {
                enabled: !1,
                releaseOnEdges: !1,
                invert: !1,
                forceToAxis: !1,
                sensitivity: 1,
                eventsTarget: "container",
                thresholdDelta: null,
                thresholdTime: null,
                noMousewheelClass: "swiper-no-mousewheel"
            }
        }), t.mousewheel = {
            enabled: !1
        };
        let u, h = l();
        const d = [];

        function p() {
            t.enabled && (t.mouseEntered = !0)
        }

        function f() {
            t.enabled && (t.mouseEntered = !1)
        }

        function m(e) {
            return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta || t.params.mousewheel.thresholdTime && l() - h < t.params.mousewheel.thresholdTime || !(e.delta >= 6 && l() - h < 60) && (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), r("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), r("scroll", e.raw)), h = (new s.Date).getTime(), 1))
        }

        function g(e) {
            let i = e,
                n = !0;
            if (!t.enabled) return;
            if (e.target.closest("." + t.params.mousewheel.noMousewheelClass)) return;
            const o = t.params.mousewheel;
            t.params.cssMode && i.preventDefault();
            let s = t.el;
            "container" !== t.params.mousewheel.eventsTarget && (s = document.querySelector(t.params.mousewheel.eventsTarget));
            const h = s && s.contains(i.target);
            if (!t.mouseEntered && !h && !o.releaseOnEdges) return !0;
            i.originalEvent && (i = i.originalEvent);
            let p = 0;
            const f = t.rtlTranslate ? -1 : 1,
                g = function (e) {
                    let t = 0,
                        i = 0,
                        n = 0,
                        r = 0;
                    return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = i, i = 0), n = 10 * t, r = 10 * i, "deltaY" in e && (r = e.deltaY), "deltaX" in e && (n = e.deltaX), e.shiftKey && !n && (n = r, r = 0), (n || r) && e.deltaMode && (1 === e.deltaMode ? (n *= 40, r *= 40) : (n *= 800, r *= 800)), n && !t && (t = n < 1 ? -1 : 1), r && !i && (i = r < 1 ? -1 : 1), {
                        spinX: t,
                        spinY: i,
                        pixelX: n,
                        pixelY: r
                    }
                }(i);
            if (o.forceToAxis)
                if (t.isHorizontal()) {
                    if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0;
                    p = -g.pixelX * f
                } else {
                    if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0;
                    p = -g.pixelY
                }
            else p = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * f : -g.pixelY;
            if (0 === p) return !0;
            o.invert && (p = -p);
            let v = t.getTranslate() + p * o.sensitivity;
            if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), n = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), n && t.params.nested && i.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) {
                const e = {
                        time: l(),
                        delta: Math.abs(p),
                        direction: Math.sign(p)
                    },
                    n = u && e.time < u.time + 500 && e.delta <= u.delta && e.direction === u.direction;
                if (!n) {
                    u = void 0;
                    let s = t.getTranslate() + p * o.sensitivity;
                    const l = t.isBeginning,
                        h = t.isEnd;
                    if (s >= t.minTranslate() && (s = t.minTranslate()), s <= t.maxTranslate() && (s = t.maxTranslate()), t.setTransition(0), t.setTranslate(s), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!l && t.isBeginning || !h && t.isEnd) && t.updateSlidesClasses(), t.params.loop && t.loopFix({
                            direction: e.direction < 0 ? "next" : "prev",
                            byMousewheel: !0
                        }), t.params.freeMode.sticky) {
                        clearTimeout(c), c = void 0, d.length >= 15 && d.shift();
                        const i = d.length ? d[d.length - 1] : void 0,
                            n = d[0];
                        if (d.push(e), i && (e.delta > i.delta || e.direction !== i.direction)) d.splice(0);
                        else if (d.length >= 15 && e.time - n.time < 500 && n.delta - e.delta >= 1 && e.delta <= 6) {
                            const i = p > 0 ? .8 : .2;
                            u = e, d.splice(0), c = a(() => {
                                !t.destroyed && t.params && t.slideToClosest(t.params.speed, !0, void 0, i)
                            }, 0)
                        }
                        c || (c = a(() => {
                            !t.destroyed && t.params && (u = e, d.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5))
                        }, 500))
                    }
                    if (n || r("scroll", i), t.params.autoplay && t.params.autoplay.disableOnInteraction && t.autoplay.stop(), o.releaseOnEdges && (s === t.minTranslate() || s === t.maxTranslate())) return !0
                }
            } else {
                const i = {
                    time: l(),
                    delta: Math.abs(p),
                    direction: Math.sign(p),
                    raw: e
                };
                d.length >= 2 && d.shift();
                const n = d.length ? d[d.length - 1] : void 0;
                if (d.push(i), n ? (i.direction !== n.direction || i.delta > n.delta || i.time > n.time + 150) && m(i) : m(i), function (e) {
                        const i = t.params.mousewheel;
                        if (e.direction < 0) {
                            if (t.isEnd && !t.params.loop && i.releaseOnEdges) return !0
                        } else if (t.isBeginning && !t.params.loop && i.releaseOnEdges) return !0;
                        return !1
                    }(i)) return !0
            }
            return i.preventDefault ? i.preventDefault() : i.returnValue = !1, !1
        }

        function v(e) {
            let i = t.el;
            "container" !== t.params.mousewheel.eventsTarget && (i = document.querySelector(t.params.mousewheel.eventsTarget)), i[e]("mouseenter", p), i[e]("mouseleave", f), i[e]("wheel", g)
        }

        function y() {
            return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", g), !0) : !t.mousewheel.enabled && (v("addEventListener"), t.mousewheel.enabled = !0, !0)
        }

        function b() {
            return t.params.cssMode ? (t.wrapperEl.addEventListener(event, g), !0) : !!t.mousewheel.enabled && (v("removeEventListener"), t.mousewheel.enabled = !1, !0)
        }
        n("init", () => {
            !t.params.mousewheel.enabled && t.params.cssMode && b(), t.params.mousewheel.enabled && y()
        }), n("destroy", () => {
            t.params.cssMode && y(), t.mousewheel.enabled && b()
        }), Object.assign(t.mousewheel, {
            enable: y,
            disable: b
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n,
            emit: r
        } = e;

        function o(e) {
            let i;
            return e && "string" == typeof e && t.isElement && (i = t.el.querySelector(e) || t.hostEl.querySelector(e), i) ? i : (e && ("string" == typeof e && (i = [...document.querySelectorAll(e)]), t.params.uniqueNavElements && "string" == typeof e && i && i.length > 1 && 1 === t.el.querySelectorAll(e).length ? i = t.el.querySelector(e) : i && 1 === i.length && (i = i[0])), e && !i ? e : i)
        }

        function s(e, i) {
            const n = t.params.navigation;
            (e = M(e)).forEach(e => {
                e && (e.classList[i ? "add" : "remove"](...n.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = i), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](n.lockClass))
            })
        }

        function a() {
            const {
                nextEl: e,
                prevEl: i
            } = t.navigation;
            if (t.params.loop) return s(i, !1), void s(e, !1);
            s(i, t.isBeginning && !t.params.rewind), s(e, t.isEnd && !t.params.rewind)
        }

        function l(e) {
            e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), r("navigationPrev"))
        }

        function c(e) {
            e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), r("navigationNext"))
        }

        function u() {
            const e = t.params.navigation;
            if (t.params.navigation = ee(t, t.originalParams.navigation, t.params.navigation, {
                    nextEl: "swiper-button-next",
                    prevEl: "swiper-button-prev"
                }), !e.nextEl && !e.prevEl) return;
            let i = o(e.nextEl),
                n = o(e.prevEl);
            Object.assign(t.navigation, {
                nextEl: i,
                prevEl: n
            }), i = M(i), n = M(n);
            const r = (i, n) => {
                i && i.addEventListener("click", "next" === n ? c : l), !t.enabled && i && i.classList.add(...e.lockClass.split(" "))
            };
            i.forEach(e => r(e, "next")), n.forEach(e => r(e, "prev"))
        }

        function h() {
            let {
                nextEl: e,
                prevEl: i
            } = t.navigation;
            e = M(e), i = M(i);
            const n = (e, i) => {
                e.removeEventListener("click", "next" === i ? c : l), e.classList.remove(...t.params.navigation.disabledClass.split(" "))
            };
            e.forEach(e => n(e, "next")), i.forEach(e => n(e, "prev"))
        }
        i({
            navigation: {
                nextEl: null,
                prevEl: null,
                hideOnClick: !1,
                disabledClass: "swiper-button-disabled",
                hiddenClass: "swiper-button-hidden",
                lockClass: "swiper-button-lock",
                navigationDisabledClass: "swiper-navigation-disabled"
            }
        }), t.navigation = {
            nextEl: null,
            prevEl: null
        }, n("init", () => {
            !1 === t.params.navigation.enabled ? d() : (u(), a())
        }), n("toEdge fromEdge lock unlock", () => {
            a()
        }), n("destroy", () => {
            h()
        }), n("enable disable", () => {
            let {
                nextEl: e,
                prevEl: i
            } = t.navigation;
            e = M(e), i = M(i), t.enabled ? a() : [...e, ...i].filter(e => !!e).forEach(e => e.classList.add(t.params.navigation.lockClass))
        }), n("click", (e, i) => {
            let {
                nextEl: n,
                prevEl: o
            } = t.navigation;
            n = M(n), o = M(o);
            const s = i.target;
            let a = o.includes(s) || n.includes(s);
            if (t.isElement && !a) {
                const e = i.path || i.composedPath && i.composedPath();
                e && (a = e.find(e => n.includes(e) || o.includes(e)))
            }
            if (t.params.navigation.hideOnClick && !a) {
                if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === s || t.pagination.el.contains(s))) return;
                let e;
                n.length ? e = n[0].classList.contains(t.params.navigation.hiddenClass) : o.length && (e = o[0].classList.contains(t.params.navigation.hiddenClass)), r(!0 === e ? "navigationShow" : "navigationHide"), [...n, ...o].filter(e => !!e).forEach(e => e.classList.toggle(t.params.navigation.hiddenClass))
            }
        });
        const d = () => {
            t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), h()
        };
        Object.assign(t.navigation, {
            enable: () => {
                t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), u(), a()
            },
            disable: d,
            update: a,
            init: u,
            destroy: h
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n,
            emit: r
        } = e;
        const o = "swiper-pagination";
        let s;
        i({
            pagination: {
                el: null,
                bulletElement: "span",
                clickable: !1,
                hideOnClick: !1,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: !1,
                type: "bullets",
                dynamicBullets: !1,
                dynamicMainBullets: 1,
                formatFractionCurrent: e => e,
                formatFractionTotal: e => e,
                bulletClass: o + "-bullet",
                bulletActiveClass: o + "-bullet-active",
                modifierClass: o + "-",
                currentClass: o + "-current",
                totalClass: o + "-total",
                hiddenClass: o + "-hidden",
                progressbarFillClass: o + "-progressbar-fill",
                progressbarOppositeClass: o + "-progressbar-opposite",
                clickableClass: o + "-clickable",
                lockClass: o + "-lock",
                horizontalClass: o + "-horizontal",
                verticalClass: o + "-vertical",
                paginationDisabledClass: o + "-disabled"
            }
        }), t.pagination = {
            el: null,
            bullets: []
        };
        let a = 0;

        function l() {
            return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length
        }

        function c(e, i) {
            const {
                bulletActiveClass: n
            } = t.params.pagination;
            e && (e = e[("prev" === i ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${n}-${i}`), (e = e[("prev" === i ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${n}-${i}-${i}`))
        }

        function u(e) {
            const i = e.target.closest(te(t.params.pagination.bulletClass));
            if (!i) return;
            e.preventDefault();
            const n = x(i) * t.params.slidesPerGroup;
            if (t.params.loop) {
                if (t.realIndex === n) return;
                const e = (r = t.realIndex, o = n, (o %= s = t.slides.length) == 1 + (r %= s) ? "next" : o === r - 1 ? "previous" : void 0);
                "next" === e ? t.slideNext() : "previous" === e ? t.slidePrev() : t.slideToLoop(n)
            } else t.slideTo(n);
            var r, o, s
        }

        function h() {
            const e = t.rtl,
                i = t.params.pagination;
            if (l()) return;
            let n, o, u = t.pagination.el;
            u = M(u);
            const h = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                d = t.params.loop ? Math.ceil(h / t.params.slidesPerGroup) : t.snapGrid.length;
            if (t.params.loop ? (o = t.previousRealIndex || 0, n = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (n = t.snapIndex, o = t.previousSnapIndex) : (o = t.previousIndex || 0, n = t.activeIndex || 0), "bullets" === i.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
                const r = t.pagination.bullets;
                let l, h, d;
                if (i.dynamicBullets && (s = E(r[0], t.isHorizontal() ? "width" : "height", !0), u.forEach(e => {
                        e.style[t.isHorizontal() ? "width" : "height"] = s * (i.dynamicMainBullets + 4) + "px"
                    }), i.dynamicMainBullets > 1 && void 0 !== o && (a += n - (o || 0), a > i.dynamicMainBullets - 1 ? a = i.dynamicMainBullets - 1 : a < 0 && (a = 0)), l = Math.max(n - a, 0), h = l + (Math.min(r.length, i.dynamicMainBullets) - 1), d = (h + l) / 2), r.forEach(e => {
                        const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(e => `${i.bulletActiveClass}${e}`)].map(e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e).flat();
                        e.classList.remove(...t)
                    }), u.length > 1) r.forEach(e => {
                    const r = x(e);
                    r === n ? e.classList.add(...i.bulletActiveClass.split(" ")) : t.isElement && e.setAttribute("part", "bullet"), i.dynamicBullets && (r >= l && r <= h && e.classList.add(...(i.bulletActiveClass + "-main").split(" ")), r === l && c(e, "prev"), r === h && c(e, "next"))
                });
                else {
                    const e = r[n];
                    if (e && e.classList.add(...i.bulletActiveClass.split(" ")), t.isElement && r.forEach((e, t) => {
                            e.setAttribute("part", t === n ? "bullet-active" : "bullet")
                        }), i.dynamicBullets) {
                        const e = r[l],
                            t = r[h];
                        for (let e = l; e <= h; e += 1) r[e] && r[e].classList.add(...(i.bulletActiveClass + "-main").split(" "));
                        c(e, "prev"), c(t, "next")
                    }
                }
                if (i.dynamicBullets) {
                    const n = Math.min(r.length, i.dynamicMainBullets + 4),
                        o = (s * n - s) / 2 - d * s,
                        a = e ? "right" : "left";
                    r.forEach(e => {
                        e.style[t.isHorizontal() ? a : "top"] = o + "px"
                    })
                }
            }
            u.forEach((e, o) => {
                if ("fraction" === i.type && (e.querySelectorAll(te(i.currentClass)).forEach(e => {
                        e.textContent = i.formatFractionCurrent(n + 1)
                    }), e.querySelectorAll(te(i.totalClass)).forEach(e => {
                        e.textContent = i.formatFractionTotal(d)
                    })), "progressbar" === i.type) {
                    let r;
                    r = i.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
                    const o = (n + 1) / d;
                    let s = 1,
                        a = 1;
                    "horizontal" === r ? s = o : a = o, e.querySelectorAll(te(i.progressbarFillClass)).forEach(e => {
                        e.style.transform = `translate3d(0,0,0) scaleX(${s}) scaleY(${a})`, e.style.transitionDuration = t.params.speed + "ms"
                    })
                }
                "custom" === i.type && i.renderCustom ? (e.innerHTML = i.renderCustom(t, n + 1, d), 0 === o && r("paginationRender", e)) : (0 === o && r("paginationRender", e), r("paginationUpdate", e)), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](i.lockClass)
            })
        }

        function d() {
            const e = t.params.pagination;
            if (l()) return;
            const i = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.grid && t.params.grid.rows > 1 ? t.slides.length / Math.ceil(t.params.grid.rows) : t.slides.length;
            let n = t.pagination.el;
            n = M(n);
            let o = "";
            if ("bullets" === e.type) {
                let n = t.params.loop ? Math.ceil(i / t.params.slidesPerGroup) : t.snapGrid.length;
                t.params.freeMode && t.params.freeMode.enabled && n > i && (n = i);
                for (let i = 0; i < n; i += 1) e.renderBullet ? o += e.renderBullet.call(t, i, e.bulletClass) : o += `<${e.bulletElement} ${t.isElement?'part="bullet"':""} class="${e.bulletClass}"></${e.bulletElement}>`
            }
            "fraction" === e.type && (o = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`), "progressbar" === e.type && (o = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`), t.pagination.bullets = [], n.forEach(i => {
                "custom" !== e.type && (i.innerHTML = o || ""), "bullets" === e.type && t.pagination.bullets.push(...i.querySelectorAll(te(e.bulletClass)))
            }), "custom" !== e.type && r("paginationRender", n[0])
        }

        function p() {
            t.params.pagination = ee(t, t.originalParams.pagination, t.params.pagination, {
                el: "swiper-pagination"
            });
            const e = t.params.pagination;
            if (!e.el) return;
            let i;
            "string" == typeof e.el && t.isElement && (i = t.el.querySelector(e.el)), i || "string" != typeof e.el || (i = [...document.querySelectorAll(e.el)]), i || (i = e.el), i && 0 !== i.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(i) && i.length > 1 && (i = [...t.el.querySelectorAll(e.el)], i.length > 1 && (i = i.find(e => w(e, ".swiper")[0] === t.el))), Array.isArray(i) && 1 === i.length && (i = i[0]), Object.assign(t.pagination, {
                el: i
            }), i = M(i), i.forEach(i => {
                "bullets" === e.type && e.clickable && i.classList.add(...(e.clickableClass || "").split(" ")), i.classList.add(e.modifierClass + e.type), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (i.classList.add(`${e.modifierClass}${e.type}-dynamic`), a = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && i.classList.add(e.progressbarOppositeClass), e.clickable && i.addEventListener("click", u), t.enabled || i.classList.add(e.lockClass)
            }))
        }

        function f() {
            const e = t.params.pagination;
            if (l()) return;
            let i = t.pagination.el;
            i && (i = M(i), i.forEach(i => {
                i.classList.remove(e.hiddenClass), i.classList.remove(e.modifierClass + e.type), i.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && (i.classList.remove(...(e.clickableClass || "").split(" ")), i.removeEventListener("click", u))
            })), t.pagination.bullets && t.pagination.bullets.forEach(t => t.classList.remove(...e.bulletActiveClass.split(" ")))
        }
        n("changeDirection", () => {
            if (!t.pagination || !t.pagination.el) return;
            const e = t.params.pagination;
            let {
                el: i
            } = t.pagination;
            i = M(i), i.forEach(i => {
                i.classList.remove(e.horizontalClass, e.verticalClass), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass)
            })
        }), n("init", () => {
            !1 === t.params.pagination.enabled ? m() : (p(), d(), h())
        }), n("activeIndexChange", () => {
            void 0 === t.snapIndex && h()
        }), n("snapIndexChange", () => {
            h()
        }), n("snapGridLengthChange", () => {
            d(), h()
        }), n("destroy", () => {
            f()
        }), n("enable disable", () => {
            let {
                el: e
            } = t.pagination;
            e && (e = M(e), e.forEach(e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass)))
        }), n("lock unlock", () => {
            h()
        }), n("click", (e, i) => {
            const n = i.target,
                o = M(t.pagination.el);
            if (t.params.pagination.el && t.params.pagination.hideOnClick && o && o.length > 0 && !n.classList.contains(t.params.pagination.bulletClass)) {
                if (t.navigation && (t.navigation.nextEl && n === t.navigation.nextEl || t.navigation.prevEl && n === t.navigation.prevEl)) return;
                const e = o[0].classList.contains(t.params.pagination.hiddenClass);
                r(!0 === e ? "paginationShow" : "paginationHide"), o.forEach(e => e.classList.toggle(t.params.pagination.hiddenClass))
            }
        });
        const m = () => {
            t.el.classList.add(t.params.pagination.paginationDisabledClass);
            let {
                el: e
            } = t.pagination;
            e && (e = M(e), e.forEach(e => e.classList.add(t.params.pagination.paginationDisabledClass))), f()
        };
        Object.assign(t.pagination, {
            enable: () => {
                t.el.classList.remove(t.params.pagination.paginationDisabledClass);
                let {
                    el: e
                } = t.pagination;
                e && (e = M(e), e.forEach(e => e.classList.remove(t.params.pagination.paginationDisabledClass))), p(), d(), h()
            },
            disable: m,
            render: d,
            update: h,
            init: p,
            destroy: f
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: r,
            emit: o
        } = e;
        const l = n();
        let c, u, h, d, p = !1,
            f = null,
            m = null;

        function g() {
            if (!t.params.scrollbar.el || !t.scrollbar.el) return;
            const {
                scrollbar: e,
                rtlTranslate: i
            } = t, {
                dragEl: n,
                el: r
            } = e, o = t.params.scrollbar, s = t.params.loop ? t.progressLoop : t.progress;
            let a = u,
                l = (h - u) * s;
            i ? (l = -l, l > 0 ? (a = u - l, l = 0) : -l + u > h && (a = h + l)) : l < 0 ? (a = u + l, l = 0) : l + u > h && (a = h - l), t.isHorizontal() ? (n.style.transform = `translate3d(${l}px, 0, 0)`, n.style.width = a + "px") : (n.style.transform = `translate3d(0px, ${l}px, 0)`, n.style.height = a + "px"), o.hide && (clearTimeout(f), r.style.opacity = 1, f = setTimeout(() => {
                r.style.opacity = 0, r.style.transitionDuration = "400ms"
            }, 1e3))
        }

        function b() {
            if (!t.params.scrollbar.el || !t.scrollbar.el) return;
            const {
                scrollbar: e
            } = t, {
                dragEl: i,
                el: n
            } = e;
            i.style.width = "", i.style.height = "", h = t.isHorizontal() ? n.offsetWidth : n.offsetHeight, d = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), u = "auto" === t.params.scrollbar.dragSize ? h * d : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? i.style.width = u + "px" : i.style.height = u + "px", n.style.display = d >= 1 ? "none" : "", t.params.scrollbar.hide && (n.style.opacity = 0), t.params.watchOverflow && t.enabled && e.el.classList[t.isLocked ? "add" : "remove"](t.params.scrollbar.lockClass)
        }

        function x(e) {
            return t.isHorizontal() ? e.clientX : e.clientY
        }

        function w(e) {
            const {
                scrollbar: i,
                rtlTranslate: n
            } = t, {
                el: r
            } = i;
            let o;
            o = (x(e) - y(r)[t.isHorizontal() ? "left" : "top"] - (null !== c ? c : u / 2)) / (h - u), o = Math.max(Math.min(o, 1), 0), n && (o = 1 - o);
            const s = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * o;
            t.updateProgress(s), t.setTranslate(s), t.updateActiveIndex(), t.updateSlidesClasses()
        }

        function _(e) {
            const i = t.params.scrollbar,
                {
                    scrollbar: n,
                    wrapperEl: r
                } = t,
                {
                    el: s,
                    dragEl: a
                } = n;
            p = !0, c = e.target === a ? x(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), r.style.transitionDuration = "100ms", a.style.transitionDuration = "100ms", w(e), clearTimeout(m), s.style.transitionDuration = "0ms", i.hide && (s.style.opacity = 1), t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "none"), o("scrollbarDragStart", e)
        }

        function E(e) {
            const {
                scrollbar: i,
                wrapperEl: n
            } = t, {
                el: r,
                dragEl: s
            } = i;
            p && (e.preventDefault && e.cancelable ? e.preventDefault() : e.returnValue = !1, w(e), n.style.transitionDuration = "0ms", r.style.transitionDuration = "0ms", s.style.transitionDuration = "0ms", o("scrollbarDragMove", e))
        }

        function S(e) {
            const i = t.params.scrollbar,
                {
                    scrollbar: n,
                    wrapperEl: r
                } = t,
                {
                    el: s
                } = n;
            p && (p = !1, t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "", r.style.transitionDuration = ""), i.hide && (clearTimeout(m), m = a(() => {
                s.style.opacity = 0, s.style.transitionDuration = "400ms"
            }, 1e3)), o("scrollbarDragEnd", e), i.snapOnRelease && t.slideToClosest())
        }

        function T(e) {
            const {
                scrollbar: i,
                params: n
            } = t, r = i.el;
            if (!r) return;
            const o = r,
                s = !!n.passiveListeners && {
                    passive: !1,
                    capture: !1
                },
                a = !!n.passiveListeners && {
                    passive: !0,
                    capture: !1
                };
            if (!o) return;
            const c = "on" === e ? "addEventListener" : "removeEventListener";
            o[c]("pointerdown", _, s), l[c]("pointermove", E, s), l[c]("pointerup", S, a)
        }

        function A() {
            const {
                scrollbar: e,
                el: i
            } = t;
            t.params.scrollbar = ee(t, t.originalParams.scrollbar, t.params.scrollbar, {
                el: "swiper-scrollbar"
            });
            const n = t.params.scrollbar;
            if (!n.el) return;
            let r, o;
            if ("string" == typeof n.el && t.isElement && (r = t.el.querySelector(n.el)), r || "string" != typeof n.el) r || (r = n.el);
            else if (r = l.querySelectorAll(n.el), !r.length) return;
            t.params.uniqueNavElements && "string" == typeof n.el && r.length > 1 && 1 === i.querySelectorAll(n.el).length && (r = i.querySelector(n.el)), r.length > 0 && (r = r[0]), r.classList.add(t.isHorizontal() ? n.horizontalClass : n.verticalClass), r && (o = r.querySelector(te(t.params.scrollbar.dragClass)), o || (o = v("div", t.params.scrollbar.dragClass), r.append(o))), Object.assign(e, {
                el: r,
                dragEl: o
            }), n.draggable && t.params.scrollbar.el && t.scrollbar.el && T("on"), r && r.classList[t.enabled ? "remove" : "add"](...s(t.params.scrollbar.lockClass))
        }

        function C() {
            const e = t.params.scrollbar,
                i = t.scrollbar.el;
            i && i.classList.remove(...s(t.isHorizontal() ? e.horizontalClass : e.verticalClass)), t.params.scrollbar.el && t.scrollbar.el && T("off")
        }
        i({
            scrollbar: {
                el: null,
                dragSize: "auto",
                hide: !1,
                draggable: !1,
                snapOnRelease: !0,
                lockClass: "swiper-scrollbar-lock",
                dragClass: "swiper-scrollbar-drag",
                scrollbarDisabledClass: "swiper-scrollbar-disabled",
                horizontalClass: "swiper-scrollbar-horizontal",
                verticalClass: "swiper-scrollbar-vertical"
            }
        }), t.scrollbar = {
            el: null,
            dragEl: null
        }, r("changeDirection", () => {
            if (!t.scrollbar || !t.scrollbar.el) return;
            const e = t.params.scrollbar;
            let {
                el: i
            } = t.scrollbar;
            i = M(i), i.forEach(i => {
                i.classList.remove(e.horizontalClass, e.verticalClass), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass)
            })
        }), r("init", () => {
            !1 === t.params.scrollbar.enabled ? L() : (A(), b(), g())
        }), r("update resize observerUpdate lock unlock changeDirection", () => {
            b()
        }), r("setTranslate", () => {
            g()
        }), r("setTransition", (e, i) => {
            ! function (e) {
                t.params.scrollbar.el && t.scrollbar.el && (t.scrollbar.dragEl.style.transitionDuration = e + "ms")
            }(i)
        }), r("enable disable", () => {
            const {
                el: e
            } = t.scrollbar;
            e && e.classList[t.enabled ? "remove" : "add"](...s(t.params.scrollbar.lockClass))
        }), r("destroy", () => {
            C()
        });
        const L = () => {
            t.el.classList.add(...s(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.add(...s(t.params.scrollbar.scrollbarDisabledClass)), C()
        };
        Object.assign(t.scrollbar, {
            enable: () => {
                t.el.classList.remove(...s(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.remove(...s(t.params.scrollbar.scrollbarDisabledClass)), A(), b(), g()
            },
            disable: L,
            updateSize: b,
            setTranslate: g,
            init: A,
            destroy: C
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            parallax: {
                enabled: !1
            }
        });
        const r = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]",
            o = (e, i) => {
                const {
                    rtl: n
                } = t, r = n ? -1 : 1, o = e.getAttribute("data-swiper-parallax") || "0";
                let s = e.getAttribute("data-swiper-parallax-x"),
                    a = e.getAttribute("data-swiper-parallax-y");
                const l = e.getAttribute("data-swiper-parallax-scale"),
                    c = e.getAttribute("data-swiper-parallax-opacity"),
                    u = e.getAttribute("data-swiper-parallax-rotate");
                if (s || a ? (s = s || "0", a = a || "0") : t.isHorizontal() ? (s = o, a = "0") : (a = o, s = "0"), s = s.indexOf("%") >= 0 ? parseInt(s, 10) * i * r + "%" : s * i * r + "px", a = a.indexOf("%") >= 0 ? parseInt(a, 10) * i + "%" : a * i + "px", null != c) {
                    const t = c - (c - 1) * (1 - Math.abs(i));
                    e.style.opacity = t
                }
                let h = `translate3d(${s}, ${a}, 0px)`;
                null != l && (h += ` scale(${l-(l-1)*(1-Math.abs(i))})`), u && null != u && (h += ` rotate(${u*i*-1}deg)`), e.style.transform = h
            },
            s = () => {
                const {
                    el: e,
                    slides: i,
                    progress: n,
                    snapGrid: s,
                    isElement: a
                } = t, l = m(e, r);
                t.isElement && l.push(...m(t.hostEl, r)), l.forEach(e => {
                    o(e, n)
                }), i.forEach((e, i) => {
                    let a = e.progress;
                    t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (a += Math.ceil(i / 2) - n * (s.length - 1)), a = Math.min(Math.max(a, -1), 1), e.querySelectorAll(r + ", [data-swiper-parallax-rotate]").forEach(e => {
                        o(e, a)
                    })
                })
            };
        n("beforeInit", () => {
            t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0)
        }), n("init", () => {
            t.params.parallax.enabled && s()
        }), n("setTranslate", () => {
            t.params.parallax.enabled && s()
        }), n("setTransition", (e, i) => {
            t.params.parallax.enabled && function (e) {
                void 0 === e && (e = t.params.speed);
                const {
                    el: i,
                    hostEl: n
                } = t, o = [...i.querySelectorAll(r)];
                t.isElement && o.push(...n.querySelectorAll(r)), o.forEach(t => {
                    let i = parseInt(t.getAttribute("data-swiper-parallax-duration"), 10) || e;
                    0 === e && (i = 0), t.style.transitionDuration = i + "ms"
                })
            }(i)
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n,
            emit: r
        } = e;
        const s = o();
        i({
            zoom: {
                enabled: !1,
                limitToOriginalSize: !1,
                maxRatio: 3,
                minRatio: 1,
                panOnMouseMove: !1,
                toggle: !0,
                containerClass: "swiper-zoom-container",
                zoomedSlideClass: "swiper-slide-zoomed"
            }
        }), t.zoom = {
            enabled: !1
        };
        let a = 1,
            l = !1,
            u = !1,
            h = {
                x: 0,
                y: 0
            };
        let d, p;
        const f = [],
            g = {
                originX: 0,
                originY: 0,
                slideEl: void 0,
                slideWidth: void 0,
                slideHeight: void 0,
                imageEl: void 0,
                imageWrapEl: void 0,
                maxRatio: 3
            },
            v = {
                isTouched: void 0,
                isMoved: void 0,
                currentX: void 0,
                currentY: void 0,
                minX: void 0,
                minY: void 0,
                maxX: void 0,
                maxY: void 0,
                width: void 0,
                height: void 0,
                startX: void 0,
                startY: void 0,
                touchesStart: {},
                touchesCurrent: {}
            },
            b = {
                x: void 0,
                y: void 0,
                prevPositionX: void 0,
                prevPositionY: void 0,
                prevTime: void 0
            };
        let x, _ = 1;

        function E() {
            if (f.length < 2) return 1;
            const e = f[0].pageX,
                t = f[0].pageY,
                i = f[1].pageX,
                n = f[1].pageY;
            return Math.sqrt((i - e) ** 2 + (n - t) ** 2)
        }

        function M() {
            const e = t.params.zoom,
                i = g.imageWrapEl.getAttribute("data-swiper-zoom") || e.maxRatio;
            if (e.limitToOriginalSize && g.imageEl && g.imageEl.naturalWidth) {
                const e = g.imageEl.naturalWidth / g.imageEl.offsetWidth;
                return Math.min(e, i)
            }
            return i
        }

        function S(e) {
            const i = t.isElement ? "swiper-slide" : "." + t.params.slideClass;
            return !!e.target.matches(i) || t.slides.filter(t => t.contains(e.target)).length > 0
        }

        function T(e) {
            const i = "." + t.params.zoom.containerClass;
            return !!e.target.matches(i) || [...t.hostEl.querySelectorAll(i)].filter(t => t.contains(e.target)).length > 0
        }

        function A(e) {
            if ("mouse" === e.pointerType && f.splice(0, f.length), !S(e)) return;
            const i = t.params.zoom;
            if (d = !1, p = !1, f.push(e), !(f.length < 2)) {
                if (d = !0, g.scaleStart = E(), !g.slideEl) {
                    g.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`), g.slideEl || (g.slideEl = t.slides[t.activeIndex]);
                    let n = g.slideEl.querySelector("." + i.containerClass);
                    if (n && (n = n.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = n, g.imageWrapEl = n ? w(g.imageEl, "." + i.containerClass)[0] : void 0, !g.imageWrapEl) return void(g.imageEl = void 0);
                    g.maxRatio = M()
                }
                if (g.imageEl) {
                    const [e, t] = function () {
                        if (f.length < 2) return {
                            x: null,
                            y: null
                        };
                        const e = g.imageEl.getBoundingClientRect();
                        return [(f[0].pageX + (f[1].pageX - f[0].pageX) / 2 - e.x - s.scrollX) / a, (f[0].pageY + (f[1].pageY - f[0].pageY) / 2 - e.y - s.scrollY) / a]
                    }();
                    g.originX = e, g.originY = t, g.imageEl.style.transitionDuration = "0ms"
                }
                l = !0
            }
        }

        function C(e) {
            if (!S(e)) return;
            const i = t.params.zoom,
                n = t.zoom,
                r = f.findIndex(t => t.pointerId === e.pointerId);
            r >= 0 && (f[r] = e), f.length < 2 || (p = !0, g.scaleMove = E(), g.imageEl && (n.scale = g.scaleMove / g.scaleStart * a, n.scale > g.maxRatio && (n.scale = g.maxRatio - 1 + (n.scale - g.maxRatio + 1) ** .5), n.scale < i.minRatio && (n.scale = i.minRatio + 1 - (i.minRatio - n.scale + 1) ** .5), g.imageEl.style.transform = `translate3d(0,0,0) scale(${n.scale})`))
        }

        function L(e) {
            if (!S(e)) return;
            if ("mouse" === e.pointerType && "pointerout" === e.type) return;
            const i = t.params.zoom,
                n = t.zoom,
                r = f.findIndex(t => t.pointerId === e.pointerId);
            r >= 0 && f.splice(r, 1), d && p && (d = !1, p = !1, g.imageEl && (n.scale = Math.max(Math.min(n.scale, g.maxRatio), i.minRatio), g.imageEl.style.transitionDuration = t.params.speed + "ms", g.imageEl.style.transform = `translate3d(0,0,0) scale(${n.scale})`, a = n.scale, l = !1, n.scale > 1 && g.slideEl ? g.slideEl.classList.add("" + i.zoomedSlideClass) : n.scale <= 1 && g.slideEl && g.slideEl.classList.remove("" + i.zoomedSlideClass), 1 === n.scale && (g.originX = 0, g.originY = 0, g.slideEl = void 0)))
        }

        function P() {
            t.touchEventsData.preventTouchMoveFromPointerMove = !1
        }

        function I(e) {
            const i = "mouse" === e.pointerType && t.params.zoom.panOnMouseMove;
            if (!S(e) || !T(e)) return;
            const n = t.zoom;
            if (!g.imageEl) return;
            if (!v.isTouched || !g.slideEl) return void(i && R(e));
            if (i) return void R(e);
            v.isMoved || (v.width = g.imageEl.offsetWidth || g.imageEl.clientWidth, v.height = g.imageEl.offsetHeight || g.imageEl.clientHeight, v.startX = c(g.imageWrapEl, "x") || 0, v.startY = c(g.imageWrapEl, "y") || 0, g.slideWidth = g.slideEl.offsetWidth, g.slideHeight = g.slideEl.offsetHeight, g.imageWrapEl.style.transitionDuration = "0ms");
            const r = v.width * n.scale,
                o = v.height * n.scale;
            if (v.minX = Math.min(g.slideWidth / 2 - r / 2, 0), v.maxX = -v.minX, v.minY = Math.min(g.slideHeight / 2 - o / 2, 0), v.maxY = -v.minY, v.touchesCurrent.x = f.length > 0 ? f[0].pageX : e.pageX, v.touchesCurrent.y = f.length > 0 ? f[0].pageY : e.pageY, Math.max(Math.abs(v.touchesCurrent.x - v.touchesStart.x), Math.abs(v.touchesCurrent.y - v.touchesStart.y)) > 5 && (t.allowClick = !1), !v.isMoved && !l) {
                if (t.isHorizontal() && (Math.floor(v.minX) === Math.floor(v.startX) && v.touchesCurrent.x < v.touchesStart.x || Math.floor(v.maxX) === Math.floor(v.startX) && v.touchesCurrent.x > v.touchesStart.x)) return v.isTouched = !1, void P();
                if (!t.isHorizontal() && (Math.floor(v.minY) === Math.floor(v.startY) && v.touchesCurrent.y < v.touchesStart.y || Math.floor(v.maxY) === Math.floor(v.startY) && v.touchesCurrent.y > v.touchesStart.y)) return v.isTouched = !1, void P()
            }
            e.cancelable && e.preventDefault(), e.stopPropagation(), clearTimeout(x), t.touchEventsData.preventTouchMoveFromPointerMove = !0, x = setTimeout(() => {
                t.destroyed || P()
            }), v.isMoved = !0;
            const s = (n.scale - a) / (g.maxRatio - t.params.zoom.minRatio),
                {
                    originX: u,
                    originY: h
                } = g;
            v.currentX = v.touchesCurrent.x - v.touchesStart.x + v.startX + s * (v.width - 2 * u), v.currentY = v.touchesCurrent.y - v.touchesStart.y + v.startY + s * (v.height - 2 * h), v.currentX < v.minX && (v.currentX = v.minX + 1 - (v.minX - v.currentX + 1) ** .8), v.currentX > v.maxX && (v.currentX = v.maxX - 1 + (v.currentX - v.maxX + 1) ** .8), v.currentY < v.minY && (v.currentY = v.minY + 1 - (v.minY - v.currentY + 1) ** .8), v.currentY > v.maxY && (v.currentY = v.maxY - 1 + (v.currentY - v.maxY + 1) ** .8), b.prevPositionX || (b.prevPositionX = v.touchesCurrent.x), b.prevPositionY || (b.prevPositionY = v.touchesCurrent.y), b.prevTime || (b.prevTime = Date.now()), b.x = (v.touchesCurrent.x - b.prevPositionX) / (Date.now() - b.prevTime) / 2, b.y = (v.touchesCurrent.y - b.prevPositionY) / (Date.now() - b.prevTime) / 2, Math.abs(v.touchesCurrent.x - b.prevPositionX) < 2 && (b.x = 0), Math.abs(v.touchesCurrent.y - b.prevPositionY) < 2 && (b.y = 0), b.prevPositionX = v.touchesCurrent.x, b.prevPositionY = v.touchesCurrent.y, b.prevTime = Date.now(), g.imageWrapEl.style.transform = `translate3d(${v.currentX}px, ${v.currentY}px,0)`
        }

        function O() {
            const e = t.zoom;
            g.slideEl && t.activeIndex !== t.slides.indexOf(g.slideEl) && (g.imageEl && (g.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), g.imageWrapEl && (g.imageWrapEl.style.transform = "translate3d(0,0,0)"), g.slideEl.classList.remove("" + t.params.zoom.zoomedSlideClass), e.scale = 1, a = 1, g.slideEl = void 0, g.imageEl = void 0, g.imageWrapEl = void 0, g.originX = 0, g.originY = 0)
        }

        function R(e) {
            if (a <= 1 || !g.imageWrapEl) return;
            if (!S(e) || !T(e)) return;
            const t = s.getComputedStyle(g.imageWrapEl).transform,
                i = new s.DOMMatrix(t);
            if (!u) return u = !0, h.x = e.clientX, h.y = e.clientY, v.startX = i.e, v.startY = i.f, v.width = g.imageEl.offsetWidth || g.imageEl.clientWidth, v.height = g.imageEl.offsetHeight || g.imageEl.clientHeight, g.slideWidth = g.slideEl.offsetWidth, void(g.slideHeight = g.slideEl.offsetHeight);
            const n = -3 * (e.clientX - h.x),
                r = -3 * (e.clientY - h.y),
                o = v.width * a,
                l = v.height * a,
                c = g.slideWidth,
                d = g.slideHeight,
                p = Math.min(c / 2 - o / 2, 0),
                f = -p,
                m = Math.min(d / 2 - l / 2, 0),
                y = -m,
                b = Math.max(Math.min(v.startX + n, f), p),
                x = Math.max(Math.min(v.startY + r, y), m);
            g.imageWrapEl.style.transitionDuration = "0ms", g.imageWrapEl.style.transform = `translate3d(${b}px, ${x}px, 0)`, h.x = e.clientX, h.y = e.clientY, v.startX = b, v.startY = x
        }

        function D(e) {
            const i = t.zoom,
                n = t.params.zoom;
            if (!g.slideEl) {
                e && e.target && (g.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`)), g.slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? g.slideEl = m(t.slidesEl, "." + t.params.slideActiveClass)[0] : g.slideEl = t.slides[t.activeIndex]);
                let i = g.slideEl.querySelector("." + n.containerClass);
                i && (i = i.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = i, g.imageWrapEl = i ? w(g.imageEl, "." + n.containerClass)[0] : void 0
            }
            if (!g.imageEl || !g.imageWrapEl) return;
            let r, o, l, c, u, h, d, p, f, b, x, _, E, S, T, A, C, L;
            t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), g.slideEl.classList.add("" + n.zoomedSlideClass), void 0 === v.touchesStart.x && e ? (r = e.pageX, o = e.pageY) : (r = v.touchesStart.x, o = v.touchesStart.y);
            const P = "number" == typeof e ? e : null;
            1 === a && P && (r = void 0, o = void 0, v.touchesStart.x = void 0, v.touchesStart.y = void 0);
            const I = M();
            i.scale = P || I, a = P || I, !e || 1 === a && P ? (d = 0, p = 0) : (C = g.slideEl.offsetWidth, L = g.slideEl.offsetHeight, l = y(g.slideEl).left + s.scrollX, c = y(g.slideEl).top + s.scrollY, u = l + C / 2 - r, h = c + L / 2 - o, f = g.imageEl.offsetWidth || g.imageEl.clientWidth, b = g.imageEl.offsetHeight || g.imageEl.clientHeight, x = f * i.scale, _ = b * i.scale, E = Math.min(C / 2 - x / 2, 0), S = Math.min(L / 2 - _ / 2, 0), T = -E, A = -S, d = u * i.scale, p = h * i.scale, d < E && (d = E), d > T && (d = T), p < S && (p = S), p > A && (p = A)), P && 1 === i.scale && (g.originX = 0, g.originY = 0), g.imageWrapEl.style.transitionDuration = "300ms", g.imageWrapEl.style.transform = `translate3d(${d}px, ${p}px,0)`, g.imageEl.style.transitionDuration = "300ms", g.imageEl.style.transform = `translate3d(0,0,0) scale(${i.scale})`
        }

        function k() {
            const e = t.zoom,
                i = t.params.zoom;
            if (!g.slideEl) {
                t.params.virtual && t.params.virtual.enabled && t.virtual ? g.slideEl = m(t.slidesEl, "." + t.params.slideActiveClass)[0] : g.slideEl = t.slides[t.activeIndex];
                let e = g.slideEl.querySelector("." + i.containerClass);
                e && (e = e.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = e, g.imageWrapEl = e ? w(g.imageEl, "." + i.containerClass)[0] : void 0
            }
            g.imageEl && g.imageWrapEl && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, a = 1, v.touchesStart.x = void 0, v.touchesStart.y = void 0, g.imageWrapEl.style.transitionDuration = "300ms", g.imageWrapEl.style.transform = "translate3d(0,0,0)", g.imageEl.style.transitionDuration = "300ms", g.imageEl.style.transform = "translate3d(0,0,0) scale(1)", g.slideEl.classList.remove("" + i.zoomedSlideClass), g.slideEl = void 0, g.originX = 0, g.originY = 0, t.params.zoom.panOnMouseMove && (h = {
                x: 0,
                y: 0
            }, u && (u = !1, v.startX = 0, v.startY = 0)))
        }

        function z(e) {
            const i = t.zoom;
            i.scale && 1 !== i.scale ? k() : D(e)
        }

        function B() {
            return {
                passiveListener: !!t.params.passiveListeners && {
                    passive: !0,
                    capture: !1
                },
                activeListenerWithCapture: !t.params.passiveListeners || {
                    passive: !1,
                    capture: !0
                }
            }
        }

        function N() {
            const e = t.zoom;
            if (e.enabled) return;
            e.enabled = !0;
            const {
                passiveListener: i,
                activeListenerWithCapture: n
            } = B();
            t.wrapperEl.addEventListener("pointerdown", A, i), t.wrapperEl.addEventListener("pointermove", C, n), ["pointerup", "pointercancel", "pointerout"].forEach(e => {
                t.wrapperEl.addEventListener(e, L, i)
            }), t.wrapperEl.addEventListener("pointermove", I, n)
        }

        function F() {
            const e = t.zoom;
            if (!e.enabled) return;
            e.enabled = !1;
            const {
                passiveListener: i,
                activeListenerWithCapture: n
            } = B();
            t.wrapperEl.removeEventListener("pointerdown", A, i), t.wrapperEl.removeEventListener("pointermove", C, n), ["pointerup", "pointercancel", "pointerout"].forEach(e => {
                t.wrapperEl.removeEventListener(e, L, i)
            }), t.wrapperEl.removeEventListener("pointermove", I, n)
        }
        Object.defineProperty(t.zoom, "scale", {
            get: () => _,
            set(e) {
                if (_ !== e) {
                    const t = g.imageEl,
                        i = g.slideEl;
                    r("zoomChange", e, t, i)
                }
                _ = e
            }
        }), n("init", () => {
            t.params.zoom.enabled && N()
        }), n("destroy", () => {
            F()
        }), n("touchStart", (e, i) => {
            t.zoom.enabled && function (e) {
                const i = t.device;
                if (!g.imageEl) return;
                if (v.isTouched) return;
                i.android && e.cancelable && e.preventDefault(), v.isTouched = !0;
                const n = f.length > 0 ? f[0] : e;
                v.touchesStart.x = n.pageX, v.touchesStart.y = n.pageY
            }(i)
        }), n("touchEnd", (e, i) => {
            t.zoom.enabled && function () {
                const e = t.zoom;
                if (f.length = 0, !g.imageEl) return;
                if (!v.isTouched || !v.isMoved) return v.isTouched = !1, void(v.isMoved = !1);
                v.isTouched = !1, v.isMoved = !1;
                let i = 300,
                    n = 300;
                const r = b.x * i,
                    o = v.currentX + r,
                    s = b.y * n,
                    a = v.currentY + s;
                0 !== b.x && (i = Math.abs((o - v.currentX) / b.x)), 0 !== b.y && (n = Math.abs((a - v.currentY) / b.y));
                const l = Math.max(i, n);
                v.currentX = o, v.currentY = a;
                const c = v.width * e.scale,
                    u = v.height * e.scale;
                v.minX = Math.min(g.slideWidth / 2 - c / 2, 0), v.maxX = -v.minX, v.minY = Math.min(g.slideHeight / 2 - u / 2, 0), v.maxY = -v.minY, v.currentX = Math.max(Math.min(v.currentX, v.maxX), v.minX), v.currentY = Math.max(Math.min(v.currentY, v.maxY), v.minY), g.imageWrapEl.style.transitionDuration = l + "ms", g.imageWrapEl.style.transform = `translate3d(${v.currentX}px, ${v.currentY}px,0)`
            }()
        }), n("doubleTap", (e, i) => {
            !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && z(i)
        }), n("transitionEnd", () => {
            t.zoom.enabled && t.params.zoom.enabled && O()
        }), n("slideChange", () => {
            t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && O()
        }), Object.assign(t.zoom, {
            enable: N,
            disable: F,
            in: D,
            out: k,
            toggle: z
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;

        function r(e, t) {
            const i = function () {
                let e, t, i;
                return (n, r) => {
                    for (t = -1, e = n.length; e - t > 1;) i = e + t >> 1, n[i] <= r ? t = i : e = i;
                    return e
                }
            }();
            let n, r;
            return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) {
                return e ? (r = i(this.x, e), n = r - 1, (e - this.x[n]) * (this.y[r] - this.y[n]) / (this.x[r] - this.x[n]) + this.y[n]) : 0
            }, this
        }

        function o() {
            t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline)
        }
        i({
            controller: {
                control: void 0,
                inverse: !1,
                by: "slide"
            }
        }), t.controller = {
            control: void 0
        }, n("beforeInit", () => {
            "undefined" != typeof window && ("string" == typeof t.params.controller.control || t.params.controller.control instanceof HTMLElement) ? ("string" == typeof t.params.controller.control ? [...document.querySelectorAll(t.params.controller.control)] : [t.params.controller.control]).forEach(e => {
                if (t.controller.control || (t.controller.control = []), e && e.swiper) t.controller.control.push(e.swiper);
                else if (e) {
                    const i = t.params.eventsPrefix + "init",
                        n = r => {
                            t.controller.control.push(r.detail[0]), t.update(), e.removeEventListener(i, n)
                        };
                    e.addEventListener(i, n)
                }
            }) : t.controller.control = t.params.controller.control
        }), n("update", () => {
            o()
        }), n("resize", () => {
            o()
        }), n("observerUpdate", () => {
            o()
        }), n("setTranslate", (e, i, n) => {
            t.controller.control && !t.controller.control.destroyed && t.controller.setTranslate(i, n)
        }), n("setTransition", (e, i, n) => {
            t.controller.control && !t.controller.control.destroyed && t.controller.setTransition(i, n)
        }), Object.assign(t.controller, {
            setTranslate: function (e, i) {
                const n = t.controller.control;
                let o, s;
                const a = t.constructor;

                function l(e) {
                    if (e.destroyed) return;
                    const i = t.rtlTranslate ? -t.translate : t.translate;
                    "slide" === t.params.controller.by && (function (e) {
                        t.controller.spline = t.params.loop ? new r(t.slidesGrid, e.slidesGrid) : new r(t.snapGrid, e.snapGrid)
                    }(e), s = -t.controller.spline.interpolate(-i)), s && "container" !== t.params.controller.by || (o = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), !Number.isNaN(o) && Number.isFinite(o) || (o = 1), s = (i - t.minTranslate()) * o + e.minTranslate()), t.params.controller.inverse && (s = e.maxTranslate() - s), e.updateProgress(s), e.setTranslate(s, t), e.updateActiveIndex(), e.updateSlidesClasses()
                }
                if (Array.isArray(n))
                    for (let e = 0; e < n.length; e += 1) n[e] !== i && n[e] instanceof a && l(n[e]);
                else n instanceof a && i !== n && l(n)
            },
            setTransition: function (e, i) {
                const n = t.constructor,
                    r = t.controller.control;
                let o;

                function s(i) {
                    i.destroyed || (i.setTransition(e, t), 0 !== e && (i.transitionStart(), i.params.autoHeight && a(() => {
                        i.updateAutoHeight()
                    }), _(i.wrapperEl, () => {
                        r && i.transitionEnd()
                    })))
                }
                if (Array.isArray(r))
                    for (o = 0; o < r.length; o += 1) r[o] !== i && r[o] instanceof n && s(r[o]);
                else r instanceof n && i !== r && s(r)
            }
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: r
        } = e;
        i({
            a11y: {
                enabled: !0,
                notificationClass: "swiper-notification",
                prevSlideMessage: "Previous slide",
                nextSlideMessage: "Next slide",
                firstSlideMessage: "This is the first slide",
                lastSlideMessage: "This is the last slide",
                paginationBulletMessage: "Go to slide {{index}}",
                slideLabelMessage: "{{index}} / {{slidesLength}}",
                containerMessage: null,
                containerRoleDescriptionMessage: null,
                containerRole: null,
                itemRoleDescriptionMessage: null,
                slideRole: "group",
                id: null,
                scrollOnFocus: !0
            }
        }), t.a11y = {
            clicked: !1
        };
        let o, s, a = null,
            l = (new Date).getTime();

        function c(e) {
            const t = a;
            0 !== t.length && (t.innerHTML = "", t.innerHTML = e)
        }

        function u(e) {
            (e = M(e)).forEach(e => {
                e.setAttribute("tabIndex", "0")
            })
        }

        function h(e) {
            (e = M(e)).forEach(e => {
                e.setAttribute("tabIndex", "-1")
            })
        }

        function d(e, t) {
            (e = M(e)).forEach(e => {
                e.setAttribute("role", t)
            })
        }

        function p(e, t) {
            (e = M(e)).forEach(e => {
                e.setAttribute("aria-roledescription", t)
            })
        }

        function f(e, t) {
            (e = M(e)).forEach(e => {
                e.setAttribute("aria-label", t)
            })
        }

        function m(e) {
            (e = M(e)).forEach(e => {
                e.setAttribute("aria-disabled", !0)
            })
        }

        function g(e) {
            (e = M(e)).forEach(e => {
                e.setAttribute("aria-disabled", !1)
            })
        }

        function y(e) {
            if (13 !== e.keyCode && 32 !== e.keyCode) return;
            const i = t.params.a11y,
                n = e.target;
            if (!t.pagination || !t.pagination.el || n !== t.pagination.el && !t.pagination.el.contains(e.target) || e.target.matches(te(t.params.pagination.bulletClass))) {
                if (t.navigation && t.navigation.prevEl && t.navigation.nextEl) {
                    const e = M(t.navigation.prevEl);
                    M(t.navigation.nextEl).includes(n) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? c(i.lastSlideMessage) : c(i.nextSlideMessage)), e.includes(n) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? c(i.firstSlideMessage) : c(i.prevSlideMessage))
                }
                t.pagination && n.matches(te(t.params.pagination.bulletClass)) && n.click()
            }
        }

        function b() {
            return t.pagination && t.pagination.bullets && t.pagination.bullets.length
        }

        function w() {
            return b() && t.params.pagination.clickable
        }
        const _ = (e, t, i) => {
                u(e), "BUTTON" !== e.tagName && (d(e, "button"), e.addEventListener("keydown", y)), f(e, i),
                    function (e, t) {
                        (e = M(e)).forEach(e => {
                            e.setAttribute("aria-controls", t)
                        })
                    }(e, t)
            },
            E = e => {
                s && s !== e.target && !s.contains(e.target) && (o = !0), t.a11y.clicked = !0
            },
            S = () => {
                o = !1, requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        t.destroyed || (t.a11y.clicked = !1)
                    })
                })
            },
            T = e => {
                l = (new Date).getTime()
            },
            A = e => {
                if (t.a11y.clicked || !t.params.a11y.scrollOnFocus) return;
                if ((new Date).getTime() - l < 100) return;
                const i = e.target.closest(`.${t.params.slideClass}, swiper-slide`);
                if (!i || !t.slides.includes(i)) return;
                s = i;
                const n = t.slides.indexOf(i) === t.activeIndex,
                    r = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(i);
                n || r || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, requestAnimationFrame(() => {
                    o || (t.params.loop ? t.slideToLoop(parseInt(i.getAttribute("data-swiper-slide-index")), 0) : t.slideTo(t.slides.indexOf(i), 0), o = !1)
                }))
            },
            C = () => {
                const e = t.params.a11y;
                e.itemRoleDescriptionMessage && p(t.slides, e.itemRoleDescriptionMessage), e.slideRole && d(t.slides, e.slideRole);
                const i = t.slides.length;
                e.slideLabelMessage && t.slides.forEach((n, r) => {
                    const o = t.params.loop ? parseInt(n.getAttribute("data-swiper-slide-index"), 10) : r;
                    f(n, e.slideLabelMessage.replace(/\{\{index\}\}/, o + 1).replace(/\{\{slidesLength\}\}/, i))
                })
            };
        r("beforeInit", () => {
            a = v("span", t.params.a11y.notificationClass), a.setAttribute("aria-live", "assertive"), a.setAttribute("aria-atomic", "true")
        }), r("afterInit", () => {
            t.params.a11y.enabled && (() => {
                const e = t.params.a11y;
                t.el.append(a);
                const i = t.el;
                e.containerRoleDescriptionMessage && p(i, e.containerRoleDescriptionMessage), e.containerMessage && f(i, e.containerMessage), e.containerRole && d(i, e.containerRole);
                const r = t.wrapperEl,
                    o = e.id || r.getAttribute("id") || "swiper-wrapper-" + (void 0 === (s = 16) && (s = 16), "x".repeat(s).replace(/x/g, () => Math.round(16 * Math.random()).toString(16)));
                var s;
                const l = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
                var c;
                c = o, M(r).forEach(e => {
                        e.setAttribute("id", c)
                    }),
                    function (e, t) {
                        (e = M(e)).forEach(e => {
                            e.setAttribute("aria-live", t)
                        })
                    }(r, l), C();
                let {
                    nextEl: u,
                    prevEl: h
                } = t.navigation ? t.navigation : {};
                u = M(u), h = M(h), u && u.forEach(t => _(t, o, e.nextSlideMessage)), h && h.forEach(t => _(t, o, e.prevSlideMessage)), w() && M(t.pagination.el).forEach(e => {
                    e.addEventListener("keydown", y)
                }), n().addEventListener("visibilitychange", T), t.el.addEventListener("focus", A, !0), t.el.addEventListener("focus", A, !0), t.el.addEventListener("pointerdown", E, !0), t.el.addEventListener("pointerup", S, !0)
            })()
        }), r("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
            t.params.a11y.enabled && C()
        }), r("fromEdge toEdge afterInit lock unlock", () => {
            t.params.a11y.enabled && function () {
                if (t.params.loop || t.params.rewind || !t.navigation) return;
                const {
                    nextEl: e,
                    prevEl: i
                } = t.navigation;
                i && (t.isBeginning ? (m(i), h(i)) : (g(i), u(i))), e && (t.isEnd ? (m(e), h(e)) : (g(e), u(e)))
            }()
        }), r("paginationUpdate", () => {
            t.params.a11y.enabled && function () {
                const e = t.params.a11y;
                b() && t.pagination.bullets.forEach(i => {
                    t.params.pagination.clickable && (u(i), t.params.pagination.renderBullet || (d(i, "button"), f(i, e.paginationBulletMessage.replace(/\{\{index\}\}/, x(i) + 1)))), i.matches(te(t.params.pagination.bulletActiveClass)) ? i.setAttribute("aria-current", "true") : i.removeAttribute("aria-current")
                })
            }()
        }), r("destroy", () => {
            t.params.a11y.enabled && function () {
                a && a.remove();
                let {
                    nextEl: e,
                    prevEl: i
                } = t.navigation ? t.navigation : {};
                e = M(e), i = M(i), e && e.forEach(e => e.removeEventListener("keydown", y)), i && i.forEach(e => e.removeEventListener("keydown", y)), w() && M(t.pagination.el).forEach(e => {
                    e.removeEventListener("keydown", y)
                }), n().removeEventListener("visibilitychange", T), t.el && "string" != typeof t.el && (t.el.removeEventListener("focus", A, !0), t.el.removeEventListener("pointerdown", E, !0), t.el.removeEventListener("pointerup", S, !0))
            }()
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            history: {
                enabled: !1,
                root: "",
                replaceState: !1,
                key: "slides",
                keepQuery: !1
            }
        });
        let r = !1,
            s = {};
        const a = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
            l = e => {
                const t = o();
                let i;
                i = e ? new URL(e) : t.location;
                const n = i.pathname.slice(1).split("/").filter(e => "" !== e),
                    r = n.length;
                return {
                    key: n[r - 2],
                    value: n[r - 1]
                }
            },
            c = (e, i) => {
                const n = o();
                if (!r || !t.params.history.enabled) return;
                let s;
                s = t.params.url ? new URL(t.params.url) : n.location;
                const l = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${i}"]`) : t.slides[i];
                let c = a(l.getAttribute("data-history"));
                if (t.params.history.root.length > 0) {
                    let i = t.params.history.root;
                    "/" === i[i.length - 1] && (i = i.slice(0, i.length - 1)), c = `${i}/${e?e+"/":""}${c}`
                } else s.pathname.includes(e) || (c = `${e?e+"/":""}${c}`);
                t.params.history.keepQuery && (c += s.search);
                const u = n.history.state;
                u && u.value === c || (t.params.history.replaceState ? n.history.replaceState({
                    value: c
                }, null, c) : n.history.pushState({
                    value: c
                }, null, c))
            },
            u = (e, i, n) => {
                if (i)
                    for (let r = 0, o = t.slides.length; r < o; r += 1) {
                        const o = t.slides[r];
                        if (a(o.getAttribute("data-history")) === i) {
                            const i = t.getSlideIndex(o);
                            t.slideTo(i, e, n)
                        }
                    } else t.slideTo(0, e, n)
            },
            h = () => {
                s = l(t.params.url), u(t.params.speed, s.value, !1)
            };
        n("init", () => {
            t.params.history.enabled && (() => {
                const e = o();
                if (t.params.history) {
                    if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void(t.params.hashNavigation.enabled = !0);
                    r = !0, s = l(t.params.url), s.key || s.value ? (u(0, s.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", h)) : t.params.history.replaceState || e.addEventListener("popstate", h)
                }
            })()
        }), n("destroy", () => {
            t.params.history.enabled && (() => {
                const e = o();
                t.params.history.replaceState || e.removeEventListener("popstate", h)
            })()
        }), n("transitionEnd _freeModeNoMomentumRelease", () => {
            r && c(t.params.history.key, t.activeIndex)
        }), n("slideChange", () => {
            r && t.params.cssMode && c(t.params.history.key, t.activeIndex)
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            emit: r,
            on: s
        } = e, a = !1;
        const l = n(),
            c = o();
        i({
            hashNavigation: {
                enabled: !1,
                replaceState: !1,
                watchState: !1,
                getSlideIndex(e, i) {
                    if (t.virtual && t.params.virtual.enabled) {
                        const e = t.slides.find(e => e.getAttribute("data-hash") === i);
                        return e ? parseInt(e.getAttribute("data-swiper-slide-index"), 10) : 0
                    }
                    return t.getSlideIndex(m(t.slidesEl, `.${t.params.slideClass}[data-hash="${i}"], swiper-slide[data-hash="${i}"]`)[0])
                }
            }
        });
        const u = () => {
                r("hashChange");
                const e = l.location.hash.replace("#", ""),
                    i = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex];
                if (e !== (i ? i.getAttribute("data-hash") : "")) {
                    const i = t.params.hashNavigation.getSlideIndex(t, e);
                    if (void 0 === i || Number.isNaN(i)) return;
                    t.slideTo(i)
                }
            },
            h = () => {
                if (!a || !t.params.hashNavigation.enabled) return;
                const e = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex],
                    i = e ? e.getAttribute("data-hash") || e.getAttribute("data-history") : "";
                t.params.hashNavigation.replaceState && c.history && c.history.replaceState ? (c.history.replaceState(null, null, "#" + i || ""), r("hashSet")) : (l.location.hash = i || "", r("hashSet"))
            };
        s("init", () => {
            t.params.hashNavigation.enabled && (() => {
                if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return;
                a = !0;
                const e = l.location.hash.replace("#", "");
                if (e) {
                    const i = 0,
                        n = t.params.hashNavigation.getSlideIndex(t, e);
                    t.slideTo(n || 0, i, t.params.runCallbacksOnInit, !0)
                }
                t.params.hashNavigation.watchState && c.addEventListener("hashchange", u)
            })()
        }), s("destroy", () => {
            t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && c.removeEventListener("hashchange", u)
        }), s("transitionEnd _freeModeNoMomentumRelease", () => {
            a && h()
        }), s("slideChange", () => {
            a && t.params.cssMode && h()
        })
    }, function (e) {
        let t, i, {
            swiper: r,
            extendParams: o,
            on: s,
            emit: a,
            params: l
        } = e;
        r.autoplay = {
            running: !1,
            paused: !1,
            timeLeft: 0
        }, o({
            autoplay: {
                enabled: !1,
                delay: 3e3,
                waitForTransition: !0,
                disableOnInteraction: !1,
                stopOnLastSlide: !1,
                reverseDirection: !1,
                pauseOnMouseEnter: !1
            }
        });
        let c, u, h, d, p, f, m, g, v = l && l.autoplay ? l.autoplay.delay : 3e3,
            y = l && l.autoplay ? l.autoplay.delay : 3e3,
            b = (new Date).getTime();

        function x(e) {
            r && !r.destroyed && r.wrapperEl && e.target === r.wrapperEl && (r.wrapperEl.removeEventListener("transitionend", x), g || e.detail && e.detail.bySwiperTouchMove || T())
        }
        const w = () => {
                if (r.destroyed || !r.autoplay.running) return;
                r.autoplay.paused ? u = !0 : u && (y = c, u = !1);
                const e = r.autoplay.paused ? c : b + y - (new Date).getTime();
                r.autoplay.timeLeft = e, a("autoplayTimeLeft", e, e / v), i = requestAnimationFrame(() => {
                    w()
                })
            },
            _ = e => {
                if (r.destroyed || !r.autoplay.running) return;
                cancelAnimationFrame(i), w();
                let n = void 0 === e ? r.params.autoplay.delay : e;
                v = r.params.autoplay.delay, y = r.params.autoplay.delay;
                const o = (() => {
                    let e;
                    if (e = r.virtual && r.params.virtual.enabled ? r.slides.find(e => e.classList.contains("swiper-slide-active")) : r.slides[r.activeIndex], e) return parseInt(e.getAttribute("data-swiper-autoplay"), 10)
                })();
                !Number.isNaN(o) && o > 0 && void 0 === e && (n = o, v = o, y = o), c = n;
                const s = r.params.speed,
                    l = () => {
                        r && !r.destroyed && (r.params.autoplay.reverseDirection ? !r.isBeginning || r.params.loop || r.params.rewind ? (r.slidePrev(s, !0, !0), a("autoplay")) : r.params.autoplay.stopOnLastSlide || (r.slideTo(r.slides.length - 1, s, !0, !0), a("autoplay")) : !r.isEnd || r.params.loop || r.params.rewind ? (r.slideNext(s, !0, !0), a("autoplay")) : r.params.autoplay.stopOnLastSlide || (r.slideTo(0, s, !0, !0), a("autoplay")), r.params.cssMode && (b = (new Date).getTime(), requestAnimationFrame(() => {
                            _()
                        })))
                    };
                return n > 0 ? (clearTimeout(t), t = setTimeout(() => {
                    l()
                }, n)) : requestAnimationFrame(() => {
                    l()
                }), n
            },
            E = () => {
                b = (new Date).getTime(), r.autoplay.running = !0, _(), a("autoplayStart")
            },
            M = () => {
                r.autoplay.running = !1, clearTimeout(t), cancelAnimationFrame(i), a("autoplayStop")
            },
            S = (e, i) => {
                if (r.destroyed || !r.autoplay.running) return;
                clearTimeout(t), e || (m = !0);
                const n = () => {
                    a("autoplayPause"), r.params.autoplay.waitForTransition ? r.wrapperEl.addEventListener("transitionend", x) : T()
                };
                if (r.autoplay.paused = !0, i) return f && (c = r.params.autoplay.delay), f = !1, void n();
                const o = c || r.params.autoplay.delay;
                c = o - ((new Date).getTime() - b), r.isEnd && c < 0 && !r.params.loop || (c < 0 && (c = 0), n())
            },
            T = () => {
                r.isEnd && c < 0 && !r.params.loop || r.destroyed || !r.autoplay.running || (b = (new Date).getTime(), m ? (m = !1, _(c)) : _(), r.autoplay.paused = !1, a("autoplayResume"))
            },
            A = () => {
                if (r.destroyed || !r.autoplay.running) return;
                const e = n();
                "hidden" === e.visibilityState && (m = !0, S(!0)), "visible" === e.visibilityState && T()
            },
            C = e => {
                "mouse" === e.pointerType && (m = !0, g = !0, r.animating || r.autoplay.paused || S(!0))
            },
            L = e => {
                "mouse" === e.pointerType && (g = !1, r.autoplay.paused && T())
            };
        s("init", () => {
            r.params.autoplay.enabled && (r.params.autoplay.pauseOnMouseEnter && (r.el.addEventListener("pointerenter", C), r.el.addEventListener("pointerleave", L)), n().addEventListener("visibilitychange", A), E())
        }), s("destroy", () => {
            r.el && "string" != typeof r.el && (r.el.removeEventListener("pointerenter", C), r.el.removeEventListener("pointerleave", L)), n().removeEventListener("visibilitychange", A), r.autoplay.running && M()
        }), s("_freeModeStaticRelease", () => {
            (d || m) && T()
        }), s("_freeModeNoMomentumRelease", () => {
            r.params.autoplay.disableOnInteraction ? M() : S(!0, !0)
        }), s("beforeTransitionStart", (e, t, i) => {
            !r.destroyed && r.autoplay.running && (i || !r.params.autoplay.disableOnInteraction ? S(!0, !0) : M())
        }), s("sliderFirstMove", () => {
            !r.destroyed && r.autoplay.running && (r.params.autoplay.disableOnInteraction ? M() : (h = !0, d = !1, m = !1, p = setTimeout(() => {
                m = !0, d = !0, S(!0)
            }, 200)))
        }), s("touchEnd", () => {
            if (!r.destroyed && r.autoplay.running && h) {
                if (clearTimeout(p), clearTimeout(t), r.params.autoplay.disableOnInteraction) return d = !1, void(h = !1);
                d && r.params.cssMode && T(), d = !1, h = !1
            }
        }), s("slideChange", () => {
            !r.destroyed && r.autoplay.running && (f = !0)
        }), Object.assign(r.autoplay, {
            start: E,
            stop: M,
            pause: S,
            resume: T
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: r
        } = e;
        i({
            thumbs: {
                swiper: null,
                multipleActiveThumbs: !0,
                autoScrollOffset: 0,
                slideThumbActiveClass: "swiper-slide-thumb-active",
                thumbsContainerClass: "swiper-thumbs"
            }
        });
        let o = !1,
            s = !1;

        function a() {
            const e = t.thumbs.swiper;
            if (!e || e.destroyed) return;
            const i = e.clickedIndex,
                n = e.clickedSlide;
            if (n && n.classList.contains(t.params.thumbs.slideThumbActiveClass)) return;
            if (null == i) return;
            let r;
            r = e.params.loop ? parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : i, t.params.loop ? t.slideToLoop(r) : t.slideTo(r)
        }

        function l() {
            const {
                thumbs: e
            } = t.params;
            if (o) return !1;
            o = !0;
            const i = t.constructor;
            if (e.swiper instanceof i) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }), Object.assign(t.thumbs.swiper.params, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }), t.thumbs.swiper.update();
            else if (u(e.swiper)) {
                const n = Object.assign({}, e.swiper);
                Object.assign(n, {
                    watchSlidesProgress: !0,
                    slideToClickedSlide: !1
                }), t.thumbs.swiper = new i(n), s = !0
            }
            return t.thumbs.swiper.el.classList.add(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", a), !0
        }

        function c(e) {
            const i = t.thumbs.swiper;
            if (!i || i.destroyed) return;
            const n = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView;
            let r = 1;
            const o = t.params.thumbs.slideThumbActiveClass;
            if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (r = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (r = 1), r = Math.floor(r), i.slides.forEach(e => e.classList.remove(o)), i.params.loop || i.params.virtual && i.params.virtual.enabled)
                for (let e = 0; e < r; e += 1) m(i.slidesEl, `[data-swiper-slide-index="${t.realIndex+e}"]`).forEach(e => {
                    e.classList.add(o)
                });
            else
                for (let e = 0; e < r; e += 1) i.slides[t.realIndex + e] && i.slides[t.realIndex + e].classList.add(o);
            const s = t.params.thumbs.autoScrollOffset,
                a = s && !i.params.loop;
            if (t.realIndex !== i.realIndex || a) {
                const r = i.activeIndex;
                let o, l;
                if (i.params.loop) {
                    const e = i.slides.find(e => e.getAttribute("data-swiper-slide-index") === "" + t.realIndex);
                    o = i.slides.indexOf(e), l = t.activeIndex > t.previousIndex ? "next" : "prev"
                } else o = t.realIndex, l = o > t.previousIndex ? "next" : "prev";
                a && (o += "next" === l ? s : -1 * s), i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(o) < 0 && (i.params.centeredSlides ? o = o > r ? o - Math.floor(n / 2) + 1 : o + Math.floor(n / 2) - 1 : o > r && i.params.slidesPerGroup, i.slideTo(o, e ? 0 : void 0))
            }
        }
        t.thumbs = {
            swiper: null
        }, r("beforeInit", () => {
            const {
                thumbs: e
            } = t.params;
            if (e && e.swiper)
                if ("string" == typeof e.swiper || e.swiper instanceof HTMLElement) {
                    const i = n(),
                        r = () => {
                            const n = "string" == typeof e.swiper ? i.querySelector(e.swiper) : e.swiper;
                            if (n && n.swiper) e.swiper = n.swiper, l(), c(!0);
                            else if (n) {
                                const i = t.params.eventsPrefix + "init",
                                    r = o => {
                                        e.swiper = o.detail[0], n.removeEventListener(i, r), l(), c(!0), e.swiper.update(), t.update()
                                    };
                                n.addEventListener(i, r)
                            }
                            return n
                        },
                        o = () => {
                            t.destroyed || r() || requestAnimationFrame(o)
                        };
                    requestAnimationFrame(o)
                } else l(), c(!0)
        }), r("slideChange update resize observerUpdate", () => {
            c()
        }), r("setTransition", (e, i) => {
            const n = t.thumbs.swiper;
            n && !n.destroyed && n.setTransition(i)
        }), r("beforeDestroy", () => {
            const e = t.thumbs.swiper;
            e && !e.destroyed && s && e.destroy()
        }), Object.assign(t.thumbs, {
            init: l,
            update: c
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            emit: n,
            once: r
        } = e;
        i({
            freeMode: {
                enabled: !1,
                momentum: !0,
                momentumRatio: 1,
                momentumBounce: !0,
                momentumBounceRatio: 1,
                momentumVelocityRatio: 1,
                sticky: !1,
                minimumVelocity: .02
            }
        }), Object.assign(t, {
            freeMode: {
                onTouchStart: function () {
                    if (t.params.cssMode) return;
                    const e = t.getTranslate();
                    t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({
                        currentPos: t.rtl ? t.translate : -t.translate
                    })
                },
                onTouchMove: function () {
                    if (t.params.cssMode) return;
                    const {
                        touchEventsData: e,
                        touches: i
                    } = t;
                    0 === e.velocities.length && e.velocities.push({
                        position: i[t.isHorizontal() ? "startX" : "startY"],
                        time: e.touchStartTime
                    }), e.velocities.push({
                        position: i[t.isHorizontal() ? "currentX" : "currentY"],
                        time: l()
                    })
                },
                onTouchEnd: function (e) {
                    let {
                        currentPos: i
                    } = e;
                    if (t.params.cssMode) return;
                    const {
                        params: o,
                        wrapperEl: s,
                        rtlTranslate: a,
                        snapGrid: c,
                        touchEventsData: u
                    } = t, h = l() - u.touchStartTime;
                    if (i < -t.minTranslate()) t.slideTo(t.activeIndex);
                    else if (i > -t.maxTranslate()) t.slides.length < c.length ? t.slideTo(c.length - 1) : t.slideTo(t.slides.length - 1);
                    else {
                        if (o.freeMode.momentum) {
                            if (u.velocities.length > 1) {
                                const e = u.velocities.pop(),
                                    i = u.velocities.pop(),
                                    n = e.position - i.position,
                                    r = e.time - i.time;
                                t.velocity = n / r, t.velocity /= 2, Math.abs(t.velocity) < o.freeMode.minimumVelocity && (t.velocity = 0), (r > 150 || l() - e.time > 300) && (t.velocity = 0)
                            } else t.velocity = 0;
                            t.velocity *= o.freeMode.momentumVelocityRatio, u.velocities.length = 0;
                            let e = 1e3 * o.freeMode.momentumRatio;
                            const i = t.velocity * e;
                            let h = t.translate + i;
                            a && (h = -h);
                            let d, p = !1;
                            const f = 20 * Math.abs(t.velocity) * o.freeMode.momentumBounceRatio;
                            let m;
                            if (h < t.maxTranslate()) o.freeMode.momentumBounce ? (h + t.maxTranslate() < -f && (h = t.maxTranslate() - f), d = t.maxTranslate(), p = !0, u.allowMomentumBounce = !0) : h = t.maxTranslate(), o.loop && o.centeredSlides && (m = !0);
                            else if (h > t.minTranslate()) o.freeMode.momentumBounce ? (h - t.minTranslate() > f && (h = t.minTranslate() + f), d = t.minTranslate(), p = !0, u.allowMomentumBounce = !0) : h = t.minTranslate(), o.loop && o.centeredSlides && (m = !0);
                            else if (o.freeMode.sticky) {
                                let e;
                                for (let t = 0; t < c.length; t += 1)
                                    if (c[t] > -h) {
                                        e = t;
                                        break
                                    } h = Math.abs(c[e] - h) < Math.abs(c[e - 1] - h) || "next" === t.swipeDirection ? c[e] : c[e - 1], h = -h
                            }
                            if (m && r("transitionEnd", () => {
                                    t.loopFix()
                                }), 0 !== t.velocity) {
                                if (e = a ? Math.abs((-h - t.translate) / t.velocity) : Math.abs((h - t.translate) / t.velocity), o.freeMode.sticky) {
                                    const i = Math.abs((a ? -h : h) - t.translate),
                                        n = t.slidesSizesGrid[t.activeIndex];
                                    e = i < n ? o.speed : i < 2 * n ? 1.5 * o.speed : 2.5 * o.speed
                                }
                            } else if (o.freeMode.sticky) return void t.slideToClosest();
                            o.freeMode.momentumBounce && p ? (t.updateProgress(d), t.setTransition(e), t.setTranslate(h), t.transitionStart(!0, t.swipeDirection), t.animating = !0, _(s, () => {
                                t && !t.destroyed && u.allowMomentumBounce && (n("momentumBounce"), t.setTransition(o.speed), setTimeout(() => {
                                    t.setTranslate(d), _(s, () => {
                                        t && !t.destroyed && t.transitionEnd()
                                    })
                                }, 0))
                            })) : t.velocity ? (n("_freeModeNoMomentumRelease"), t.updateProgress(h), t.setTransition(e), t.setTranslate(h), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, _(s, () => {
                                t && !t.destroyed && t.transitionEnd()
                            }))) : t.updateProgress(h), t.updateActiveIndex(), t.updateSlidesClasses()
                        } else {
                            if (o.freeMode.sticky) return void t.slideToClosest();
                            o.freeMode && n("_freeModeNoMomentumRelease")
                        }(!o.freeMode.momentum || h >= o.longSwipesMs) && (n("_freeModeStaticRelease"), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())
                    }
                }
            }
        })
    }, function (e) {
        let t, i, n, r, {
            swiper: o,
            extendParams: s,
            on: a
        } = e;
        s({
            grid: {
                rows: 1,
                fill: "column"
            }
        });
        const l = () => {
            let e = o.params.spaceBetween;
            return "string" == typeof e && e.indexOf("%") >= 0 ? e = parseFloat(e.replace("%", "")) / 100 * o.size : "string" == typeof e && (e = parseFloat(e)), e
        };
        a("init", () => {
            r = o.params.grid && o.params.grid.rows > 1
        }), a("update", () => {
            const {
                params: e,
                el: t
            } = o, i = e.grid && e.grid.rows > 1;
            r && !i ? (t.classList.remove(e.containerModifierClass + "grid", e.containerModifierClass + "grid-column"), n = 1, o.emitContainerClasses()) : !r && i && (t.classList.add(e.containerModifierClass + "grid"), "column" === e.grid.fill && t.classList.add(e.containerModifierClass + "grid-column"), o.emitContainerClasses()), r = i
        }), o.grid = {
            initSlides: e => {
                const {
                    slidesPerView: r
                } = o.params, {
                    rows: s,
                    fill: a
                } = o.params.grid, l = o.virtual && o.params.virtual.enabled ? o.virtual.slides.length : e.length;
                n = Math.floor(l / s), t = Math.floor(l / s) === l / s ? l : Math.ceil(l / s) * s, "auto" !== r && "row" === a && (t = Math.max(t, r * s)), i = t / s
            },
            unsetSlides: () => {
                o.slides && o.slides.forEach(e => {
                    e.swiperSlideGridSet && (e.style.height = "", e.style[o.getDirectionLabel("margin-top")] = "")
                })
            },
            updateSlide: (e, r, s) => {
                const {
                    slidesPerGroup: a
                } = o.params, c = l(), {
                    rows: u,
                    fill: h
                } = o.params.grid, d = o.virtual && o.params.virtual.enabled ? o.virtual.slides.length : s.length;
                let p, f, m;
                if ("row" === h && a > 1) {
                    const i = Math.floor(e / (a * u)),
                        n = e - u * a * i,
                        o = 0 === i ? a : Math.min(Math.ceil((d - i * u * a) / u), a);
                    m = Math.floor(n / o), f = n - m * o + i * a, p = f + m * t / u, r.style.order = p
                } else "column" === h ? (f = Math.floor(e / u), m = e - f * u, (f > n || f === n && m === u - 1) && (m += 1, m >= u && (m = 0, f += 1))) : (m = Math.floor(e / i), f = e - m * i);
                r.row = m, r.column = f, r.style.height = `calc((100% - ${(u-1)*c}px) / ${u})`, r.style[o.getDirectionLabel("margin-top")] = 0 !== m ? c && c + "px" : "", r.swiperSlideGridSet = !0
            },
            updateWrapperSize: (e, i) => {
                const {
                    centeredSlides: n,
                    roundLengths: r
                } = o.params, s = l(), {
                    rows: a
                } = o.params.grid;
                if (o.virtualSize = (e + s) * t, o.virtualSize = Math.ceil(o.virtualSize / a) - s, o.params.cssMode || (o.wrapperEl.style[o.getDirectionLabel("width")] = o.virtualSize + s + "px"), n) {
                    const e = [];
                    for (let t = 0; t < i.length; t += 1) {
                        let n = i[t];
                        r && (n = Math.floor(n)), i[t] < o.virtualSize + i[0] && e.push(n)
                    }
                    i.splice(0, i.length), i.push(...e)
                }
            }
        }
    }, function (e) {
        let {
            swiper: t
        } = e;
        Object.assign(t, {
            appendSlide: ie.bind(t),
            prependSlide: ne.bind(t),
            addSlide: re.bind(t),
            removeSlide: oe.bind(t),
            removeAllSlides: se.bind(t)
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            fadeEffect: {
                crossFade: !1
            }
        }), ae({
            effect: "fade",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    slides: e
                } = t;
                t.params.fadeEffect;
                for (let i = 0; i < e.length; i += 1) {
                    const e = t.slides[i];
                    let n = -e.swiperSlideOffset;
                    t.params.virtualTranslate || (n -= t.translate);
                    let r = 0;
                    t.isHorizontal() || (r = n, n = 0);
                    const o = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e.progress), 0) : 1 + Math.min(Math.max(e.progress, -1), 0),
                        s = le(0, e);
                    s.style.opacity = o, s.style.transform = `translate3d(${n}px, ${r}px, 0px)`
                }
            },
            setTransition: e => {
                const i = t.slides.map(e => f(e));
                i.forEach(t => {
                    t.style.transitionDuration = e + "ms"
                }), ce({
                    swiper: t,
                    duration: e,
                    transformElements: i,
                    allSlides: !0
                })
            },
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            cubeEffect: {
                slideShadows: !0,
                shadow: !0,
                shadowOffset: 20,
                shadowScale: .94
            }
        });
        const r = (e, t, i) => {
            let n = i ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"),
                r = i ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
            n || (n = v("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (i ? "left" : "top")).split(" ")), e.append(n)), r || (r = v("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (i ? "right" : "bottom")).split(" ")), e.append(r)), n && (n.style.opacity = Math.max(-t, 0)), r && (r.style.opacity = Math.max(t, 0))
        };
        ae({
            effect: "cube",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    el: e,
                    wrapperEl: i,
                    slides: n,
                    width: o,
                    height: s,
                    rtlTranslate: a,
                    size: l,
                    browser: c
                } = t, u = S(t), h = t.params.cubeEffect, d = t.isHorizontal(), p = t.virtual && t.params.virtual.enabled;
                let f, m = 0;
                h.shadow && (d ? (f = t.wrapperEl.querySelector(".swiper-cube-shadow"), f || (f = v("div", "swiper-cube-shadow"), t.wrapperEl.append(f)), f.style.height = o + "px") : (f = e.querySelector(".swiper-cube-shadow"), f || (f = v("div", "swiper-cube-shadow"), e.append(f))));
                for (let e = 0; e < n.length; e += 1) {
                    const t = n[e];
                    let i = e;
                    p && (i = parseInt(t.getAttribute("data-swiper-slide-index"), 10));
                    let o = 90 * i,
                        s = Math.floor(o / 360);
                    a && (o = -o, s = Math.floor(-o / 360));
                    const c = Math.max(Math.min(t.progress, 1), -1);
                    let f = 0,
                        g = 0,
                        v = 0;
                    i % 4 == 0 ? (f = 4 * -s * l, v = 0) : (i - 1) % 4 == 0 ? (f = 0, v = 4 * -s * l) : (i - 2) % 4 == 0 ? (f = l + 4 * s * l, v = l) : (i - 3) % 4 == 0 && (f = -l, v = 3 * l + 4 * l * s), a && (f = -f), d || (g = f, f = 0);
                    const y = `rotateX(${u(d?0:-o)}deg) rotateY(${u(d?o:0)}deg) translate3d(${f}px, ${g}px, ${v}px)`;
                    c <= 1 && c > -1 && (m = 90 * i + 90 * c, a && (m = 90 * -i - 90 * c)), t.style.transform = y, h.slideShadows && r(t, c, d)
                }
                if (i.style.transformOrigin = `50% 50% -${l/2}px`, i.style["-webkit-transform-origin"] = `50% 50% -${l/2}px`, h.shadow)
                    if (d) f.style.transform = `translate3d(0px, ${o/2+h.shadowOffset}px, ${-o/2}px) rotateX(89.99deg) rotateZ(0deg) scale(${h.shadowScale})`;
                    else {
                        const e = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90),
                            t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2),
                            i = h.shadowScale,
                            n = h.shadowScale / t,
                            r = h.shadowOffset;
                        f.style.transform = `scale3d(${i}, 1, ${n}) translate3d(0px, ${s/2+r}px, ${-s/2/n}px) rotateX(-89.99deg)`
                    } const g = (c.isSafari || c.isWebView) && c.needPerspectiveFix ? -l / 2 : 0;
                i.style.transform = `translate3d(0px,0,${g}px) rotateX(${u(t.isHorizontal()?0:m)}deg) rotateY(${u(t.isHorizontal()?-m:0)}deg)`, i.style.setProperty("--swiper-cube-translate-z", g + "px")
            },
            setTransition: e => {
                const {
                    el: i,
                    slides: n
                } = t;
                if (n.forEach(t => {
                        t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => {
                            t.style.transitionDuration = e + "ms"
                        })
                    }), t.params.cubeEffect.shadow && !t.isHorizontal()) {
                    const t = i.querySelector(".swiper-cube-shadow");
                    t && (t.style.transitionDuration = e + "ms")
                }
            },
            recreateShadows: () => {
                const e = t.isHorizontal();
                t.slides.forEach(t => {
                    const i = Math.max(Math.min(t.progress, 1), -1);
                    r(t, i, e)
                })
            },
            getEffectParams: () => t.params.cubeEffect,
            perspective: () => !0,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: !1,
                virtualTranslate: !0
            })
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            flipEffect: {
                slideShadows: !0,
                limitRotation: !0
            }
        });
        const r = (e, i) => {
            let n = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"),
                r = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
            n || (n = ue("flip", e, t.isHorizontal() ? "left" : "top")), r || (r = ue("flip", e, t.isHorizontal() ? "right" : "bottom")), n && (n.style.opacity = Math.max(-i, 0)), r && (r.style.opacity = Math.max(i, 0))
        };
        ae({
            effect: "flip",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    slides: e,
                    rtlTranslate: i
                } = t, n = t.params.flipEffect, o = S(t);
                for (let s = 0; s < e.length; s += 1) {
                    const a = e[s];
                    let l = a.progress;
                    t.params.flipEffect.limitRotation && (l = Math.max(Math.min(a.progress, 1), -1));
                    const c = a.swiperSlideOffset;
                    let u = -180 * l,
                        h = 0,
                        d = t.params.cssMode ? -c - t.translate : -c,
                        p = 0;
                    t.isHorizontal() ? i && (u = -u) : (p = d, d = 0, h = -u, u = 0), a.style.zIndex = -Math.abs(Math.round(l)) + e.length, n.slideShadows && r(a, l);
                    const f = `translate3d(${d}px, ${p}px, 0px) rotateX(${o(h)}deg) rotateY(${o(u)}deg)`;
                    le(0, a).style.transform = f
                }
            },
            setTransition: e => {
                const i = t.slides.map(e => f(e));
                i.forEach(t => {
                    t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => {
                        t.style.transitionDuration = e + "ms"
                    })
                }), ce({
                    swiper: t,
                    duration: e,
                    transformElements: i
                })
            },
            recreateShadows: () => {
                t.params.flipEffect, t.slides.forEach(e => {
                    let i = e.progress;
                    t.params.flipEffect.limitRotation && (i = Math.max(Math.min(e.progress, 1), -1)), r(e, i)
                })
            },
            getEffectParams: () => t.params.flipEffect,
            perspective: () => !0,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                scale: 1,
                modifier: 1,
                slideShadows: !0
            }
        }), ae({
            effect: "coverflow",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    width: e,
                    height: i,
                    slides: n,
                    slidesSizesGrid: r
                } = t, o = t.params.coverflowEffect, s = t.isHorizontal(), a = t.translate, l = s ? e / 2 - a : i / 2 - a, c = s ? o.rotate : -o.rotate, u = o.depth, h = S(t);
                for (let e = 0, t = n.length; e < t; e += 1) {
                    const t = n[e],
                        i = r[e],
                        a = (l - t.swiperSlideOffset - i / 2) / i,
                        d = "function" == typeof o.modifier ? o.modifier(a) : a * o.modifier;
                    let p = s ? c * d : 0,
                        f = s ? 0 : c * d,
                        m = -u * Math.abs(d),
                        g = o.stretch;
                    "string" == typeof g && -1 !== g.indexOf("%") && (g = parseFloat(o.stretch) / 100 * i);
                    let v = s ? 0 : g * d,
                        y = s ? g * d : 0,
                        b = 1 - (1 - o.scale) * Math.abs(d);
                    Math.abs(y) < .001 && (y = 0), Math.abs(v) < .001 && (v = 0), Math.abs(m) < .001 && (m = 0), Math.abs(p) < .001 && (p = 0), Math.abs(f) < .001 && (f = 0), Math.abs(b) < .001 && (b = 0);
                    const x = `translate3d(${y}px,${v}px,${m}px)  rotateX(${h(f)}deg) rotateY(${h(p)}deg) scale(${b})`;
                    if (le(0, t).style.transform = x, t.style.zIndex = 1 - Math.abs(Math.round(d)), o.slideShadows) {
                        let e = s ? t.querySelector(".swiper-slide-shadow-left") : t.querySelector(".swiper-slide-shadow-top"),
                            i = s ? t.querySelector(".swiper-slide-shadow-right") : t.querySelector(".swiper-slide-shadow-bottom");
                        e || (e = ue("coverflow", t, s ? "left" : "top")), i || (i = ue("coverflow", t, s ? "right" : "bottom")), e && (e.style.opacity = d > 0 ? d : 0), i && (i.style.opacity = -d > 0 ? -d : 0)
                    }
                }
            },
            setTransition: e => {
                t.slides.map(e => f(e)).forEach(t => {
                    t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => {
                        t.style.transitionDuration = e + "ms"
                    })
                })
            },
            perspective: () => !0,
            overwriteParams: () => ({
                watchSlidesProgress: !0
            })
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            creativeEffect: {
                limitProgress: 1,
                shadowPerProgress: !1,
                progressMultiplier: 1,
                perspective: !0,
                prev: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                },
                next: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                }
            }
        });
        const r = e => "string" == typeof e ? e : e + "px";
        ae({
            effect: "creative",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    slides: e,
                    wrapperEl: i,
                    slidesSizesGrid: n
                } = t, o = t.params.creativeEffect, {
                    progressMultiplier: s
                } = o, a = t.params.centeredSlides, l = S(t);
                if (a) {
                    const e = n[0] / 2 - t.params.slidesOffsetBefore || 0;
                    i.style.transform = `translateX(calc(50% - ${e}px))`
                }
                for (let i = 0; i < e.length; i += 1) {
                    const n = e[i],
                        c = n.progress,
                        u = Math.min(Math.max(n.progress, -o.limitProgress), o.limitProgress);
                    let h = u;
                    a || (h = Math.min(Math.max(n.originalProgress, -o.limitProgress), o.limitProgress));
                    const d = n.swiperSlideOffset,
                        p = [t.params.cssMode ? -d - t.translate : -d, 0, 0],
                        f = [0, 0, 0];
                    let m = !1;
                    t.isHorizontal() || (p[1] = p[0], p[0] = 0);
                    let g = {
                        translate: [0, 0, 0],
                        rotate: [0, 0, 0],
                        scale: 1,
                        opacity: 1
                    };
                    u < 0 ? (g = o.next, m = !0) : u > 0 && (g = o.prev, m = !0), p.forEach((e, t) => {
                        p[t] = `calc(${e}px + (${r(g.translate[t])} * ${Math.abs(u*s)}))`
                    }), f.forEach((e, t) => {
                        let i = g.rotate[t] * Math.abs(u * s);
                        f[t] = i
                    }), n.style.zIndex = -Math.abs(Math.round(c)) + e.length;
                    const v = p.join(", "),
                        y = `rotateX(${l(f[0])}deg) rotateY(${l(f[1])}deg) rotateZ(${l(f[2])}deg)`,
                        b = h < 0 ? `scale(${1+(1-g.scale)*h*s})` : `scale(${1-(1-g.scale)*h*s})`,
                        x = h < 0 ? 1 + (1 - g.opacity) * h * s : 1 - (1 - g.opacity) * h * s,
                        w = `translate3d(${v}) ${y} ${b}`;
                    if (m && g.shadow || !m) {
                        let e = n.querySelector(".swiper-slide-shadow");
                        if (!e && g.shadow && (e = ue("creative", n)), e) {
                            const t = o.shadowPerProgress ? u * (1 / o.limitProgress) : u;
                            e.style.opacity = Math.min(Math.max(Math.abs(t), 0), 1)
                        }
                    }
                    const _ = le(0, n);
                    _.style.transform = w, _.style.opacity = x, g.origin && (_.style.transformOrigin = g.origin)
                }
            },
            setTransition: e => {
                const i = t.slides.map(e => f(e));
                i.forEach(t => {
                    t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow").forEach(t => {
                        t.style.transitionDuration = e + "ms"
                    })
                }), ce({
                    swiper: t,
                    duration: e,
                    transformElements: i,
                    allSlides: !0
                })
            },
            perspective: () => t.params.creativeEffect.perspective,
            overwriteParams: () => ({
                watchSlidesProgress: !0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function (e) {
        let {
            swiper: t,
            extendParams: i,
            on: n
        } = e;
        i({
            cardsEffect: {
                slideShadows: !0,
                rotate: !0,
                perSlideRotate: 2,
                perSlideOffset: 8
            }
        }), ae({
            effect: "cards",
            swiper: t,
            on: n,
            setTranslate: () => {
                const {
                    slides: e,
                    activeIndex: i,
                    rtlTranslate: n
                } = t, r = t.params.cardsEffect, {
                    startTranslate: o,
                    isTouched: s
                } = t.touchEventsData, a = n ? -t.translate : t.translate;
                for (let l = 0; l < e.length; l += 1) {
                    const c = e[l],
                        u = c.progress,
                        h = Math.min(Math.max(u, -4), 4);
                    let d = c.swiperSlideOffset;
                    t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (d -= e[0].swiperSlideOffset);
                    let p = t.params.cssMode ? -d - t.translate : -d,
                        f = 0;
                    const m = -100 * Math.abs(h);
                    let g = 1,
                        v = -r.perSlideRotate * h,
                        y = r.perSlideOffset - .75 * Math.abs(h);
                    const b = t.virtual && t.params.virtual.enabled ? t.virtual.from + l : l,
                        x = (b === i || b === i - 1) && h > 0 && h < 1 && (s || t.params.cssMode) && a < o,
                        w = (b === i || b === i + 1) && h < 0 && h > -1 && (s || t.params.cssMode) && a > o;
                    if (x || w) {
                        const e = (1 - Math.abs((Math.abs(h) - .5) / .5)) ** .5;
                        v += -28 * h * e, g += -.5 * e, y += 96 * e, f = -25 * e * Math.abs(h) + "%"
                    }
                    if (p = h < 0 ? `calc(${p}px ${n?"-":"+"} (${y*Math.abs(h)}%))` : h > 0 ? `calc(${p}px ${n?"-":"+"} (-${y*Math.abs(h)}%))` : p + "px", !t.isHorizontal()) {
                        const e = f;
                        f = p, p = e
                    }
                    const _ = h < 0 ? "" + (1 + (1 - g) * h) : "" + (1 - (1 - g) * h),
                        E = `\n        translate3d(${p}, ${f}, ${m}px)\n        rotateZ(${r.rotate?n?-v:v:0}deg)\n        scale(${_})\n      `;
                    if (r.slideShadows) {
                        let e = c.querySelector(".swiper-slide-shadow");
                        e || (e = ue("cards", c)), e && (e.style.opacity = Math.min(Math.max((Math.abs(h) - .5) / .5, 0), 1))
                    }
                    c.style.zIndex = -Math.abs(Math.round(u)) + e.length, le(0, c).style.transform = E
                }
            },
            setTransition: e => {
                const i = t.slides.map(e => f(e));
                i.forEach(t => {
                    t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow").forEach(t => {
                        t.style.transitionDuration = e + "ms"
                    })
                }), ce({
                    swiper: t,
                    duration: e,
                    transformElements: i
                })
            },
            perspective: () => !0,
            overwriteParams: () => ({
                _loopSwapReset: !1,
                watchSlidesProgress: !0,
                loopAdditionalSlides: 3,
                centeredSlides: !0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }];
    return $.use(he), $
}();
! function (e) {
    "use strict";
    const t = function (e, t) {
            return t = null == t ? e.length - 1 : +t,
                function (i, n) {
                    for (var r = Math.max(arguments.length - t, 0), o = Array(r), s = 0; s < r; s++) o[s] = arguments[s + t];
                    switch (t) {
                        case 0:
                            return e.call(this, o);
                        case 1:
                            return e.call(this, i, o);
                        case 2:
                            return e.call(this, i, n, o)
                    }
                    var a = Array(t + 1);
                    for (s = 0; s < t; s++) a[s] = arguments[s];
                    return a[t] = o, e.apply(this, a)
                }
        },
        i = t((function (e, t, i) {
            return setTimeout((function () {
                return e.apply(null, i)
            }), t)
        }));
    window.tpDebounce = function (e, n, r) {
        var o, s, a = function (t, i) {
                o = null, i && (s = e.apply(t, i))
            },
            l = t((function (t) {
                if (o && clearTimeout(o), r) {
                    var l = !o;
                    o = setTimeout(a, n), l && (s = e.apply(this, t))
                } else o = i(a, n, this, t);
                return s
            }));
        return l.cancel = function () {
            clearTimeout(o), o = null
        }, l
    };
    const n = "tpThrowable";
    let r = {
        roundness: "sharp",
        scrollGravity: !1
    };
    class o {
        constructor(t, i) {
            this._defaults = r, this._name = n, this.options = {
                ...r,
                ...i
            }, this.DOM = {}, this.DOM.element = t, this.DOM.$element = e(t), this.DOM.throwables = this.DOM.element.querySelectorAll("[data-throwable-el]"), this.onWindowResize = tpDebounce(this.onWindowResize.bind(this), 100), this.bodies = [], this.init()
        }
        init() {
            this.createWorld(), this.createBoundries(), this.createBodies(), this.enableRunner(), this.makeItRain(), this.bindResize()
        }
        enableRunner() {
            this.runnerObserver = new IntersectionObserver(([e]) => {
                this.runner.enabled = e.isIntersecting
            }).observe(this.DOM.element)
        }
        makeItRain() {
            new IntersectionObserver(([e], t) => {
                e.isIntersecting && (this.DOM.throwables.forEach(e => {
                    gsap.to(e, {
                        opacity: 1,
                        duration: .35
                    })
                }), this.startRain(), t.disconnect())
            }).observe(this.DOM.element)
        }
        bindResize() {
            window.addEventListener("resize", this.onWindowResize)
        }
        createWorld() {
            this.height = this.DOM.element.offsetHeight, this.width = this.DOM.element.offsetWidth, this.engine = Matter.Engine.create(), this.runner = Matter.Runner.create(), this.mouse = Matter.Mouse.create(this.DOM.element), this.DOM.element.removeEventListener("mousewheel", this.mouse.mousewheel), this.DOM.element.addEventListener("mouseleave", this.mouse.mouseup), this.mouseConstraint = Matter.MouseConstraint.create(this.engine, {
                mouse: this.mouse,
                constraint: {
                    render: {
                        visible: !1
                    }
                }
            }), this.engine.gravity.y = .8, Matter.Composite.add(this.engine.world, [this.mouseConstraint]), Matter.Runner.start(this.runner, this.engine), Matter.Events.on(this.mouseConstraint, "mousedown", () => {
                this.DOM.element.style.pointerEvents = "auto"
            }), Matter.Events.on(this.mouseConstraint, "mouseup", () => {
                this.DOM.element.style.pointerEvents = ""
            }), this.runner.enabled = !1
        }
        createBoundries() {
            this.boundStart = Matter.Bodies.rectangle(-100, this.height / 2, 200, 4 * this.height, {
                isStatic: !0
            }), this.boundEnd = Matter.Bodies.rectangle(this.width + 100, this.height / 2, 200, 4 * this.height, {
                isStatic: !0
            }), this.boundBottom = Matter.Bodies.rectangle(0, this.height + 100, 2 * this.width, 200, {
                isStatic: !0
            }), Matter.Composite.add(this.engine.world, [this.boundBottom, this.boundStart, this.boundEnd])
        }
        createBodies() {
            this.DOM.throwables.forEach((e, t) => {
                const i = e.querySelector("span"),
                    n = e.getBoundingClientRect(),
                    r = gsap.quickSetter(e, "x", "px"),
                    o = gsap.quickSetter(e, "y", "px"),
                    s = gsap.utils.random(.2 * -Math.PI, .2 * Math.PI),
                    a = gsap.utils.random(n.width / 2, this.width - n.width / 2),
                    l = -n.width - (t * n.height + 10),
                    c = "sharp" === this.options.roundness ? 0 : n.height / 2,
                    u = Matter.Bodies.rectangle(a, l, n.width, n.height, {
                        chamfer: {
                            radius: c
                        },
                        angle: s,
                        isStatic: !0,
                        restitution: .3
                    });
                this.bodies.push(u), Matter.Composite.add(this.engine.world, [u]), Matter.Events.on(this.runner, "tick", () => {
                    this.runner.enabled && (i.style.transform = "translate(-50%, -50%) rotate(" + u.angle.toFixed(2) + "rad)", o(u.position.y.toFixed(1)), r(u.position.x.toFixed(1)))
                })
            })
        }
        createTopBound() {
            this.boundTop = Matter.Bodies.rectangle(0, 0, 2 * this.width, 200, {
                isStatic: !0
            }), Matter.Composite.add(this.engine.world, [this.boundTop])
        }
        makeScrollGravity() {
            let e = 0;
            Matter.Events.on(this.runner, "tick", () => {
                const t = document.documentElement.scrollTop - document.documentElement.clientTop,
                    i = t - e;
                this.engine.gravity.y = .7 - gsap.utils.clamp(-2, 4, .1 * i), e = t
            })
        }
        updateBoundries() {
            this.boundTop && Matter.Body.setVertices(this.boundTop, Matter.Bodies.rectangle(0, -100, 2 * this.width, 200, {
                isStatic: !0
            }).vertices), this.boundStart && (Matter.Body.setPosition(this.boundStart, {
                x: -100,
                y: this.height / 2
            }), Matter.Body.setVertices(this.boundStart, Matter.Bodies.rectangle(-100, this.height / 2, 200, 4 * this.height, {
                isStatic: !0
            }).vertices)), this.boundEnd && (Matter.Body.setPosition(this.boundEnd, {
                x: this.width + 100,
                y: this.height / 2
            }), Matter.Body.setVertices(this.boundEnd, Matter.Bodies.rectangle(this.width + 100, this.height / 2, 200, 4 * this.height, {
                isStatic: !0
            }).vertices)), this.boundBottom && (Matter.Body.setPosition(this.boundBottom, {
                x: 0,
                y: this.height + 100
            }), Matter.Body.setVertices(this.boundBottom, Matter.Bodies.rectangle(0, this.height + 100, 2 * this.width, 200, {
                isStatic: !0
            }).vertices))
        }
        updateBodies() {
            this.DOM.throwables.forEach((e, t) => {
                const i = this.bodies[t],
                    n = e.getBoundingClientRect(),
                    r = "sharp" === this.options.roundness ? 0 : n.height / 2,
                    o = Matter.Bodies.rectangle(i.position.x, i.position.y, n.width, n.height, {
                        chamfer: {
                            radius: r
                        },
                        angle: i.angle
                    });
                if (Matter.Body.setVertices(i, o.vertices), i.position.y > this.height && Matter.Body.setPosition(i, {
                        y: this.height / 2,
                        x: i.position.x
                    }), i.position.x > this.width) {
                    var s = gsap.utils.random(n.width / 2, this.width - n.width / 2);
                    Matter.Body.setPosition(i, {
                        y: i.position.y,
                        x: s
                    })
                }
            })
        }
        startRain() {
            this.bodies.forEach((e, t) => {
                const i = setTimeout(() => {
                    Matter.Body.setStatic(e, !1), clearTimeout(i)
                }, 80 * t)
            });
            let e = !1;
            Matter.Events.on(this.runner, "tick", () => {
                !e && this.bodies[this.bodies.length - 1].position.y > this.DOM.element.offsetHeight / 2 && (this.createTopBound(), this.options.scrollGravity && this.makeScrollGravity(), e = !0)
            })
        }
        refresh() {
            if (this.height === this.DOM.element.offsetHeight && this.width === this.DOM.element.offsetWidth) return !1;
            this.height = this.DOM.element.offsetHeight, this.width = this.DOM.element.offsetWidth;
            const e = setTimeout(() => {
                this.updateBoundries(), this.updateBodies(), clearTimeout(e)
            })
        }
        onWindowResize() {
            this.refresh()
        }
        destroy() {
            this.runner.enabled = !1, Matter.Runner.stop(this.runner), window.removeEventListener("resize", this.onWindowResize)
        }
    }
    e.fn[n] = function (t) {
        return this.each((function () {
            const i = {
                ...e(this).data("throwable-options"),
                ...t
            };
            e.data(this, "plugin_" + n) || e.data(this, "plugin_" + n, new o(this, i))
        }))
    }
}(jQuery), jQuery(document).ready((function (e) {
        e("[data-throwable-scene]").tpThrowable()
    })),
    /*! WOW - v1.1.2 - 2015-04-07
     * Copyright (c) 2015 Matthieu Aussaguel; Licensed MIT */
    function () {
        var e, t, i, n, r, o = function (e, t) {
                return function () {
                    return e.apply(t, arguments)
                }
            },
            s = [].indexOf || function (e) {
                for (var t = 0, i = this.length; i > t; t++)
                    if (t in this && this[t] === e) return t;
                return -1
            };
        t = function () {
            function e() {}
            return e.prototype.extend = function (e, t) {
                var i, n;
                for (i in t) n = t[i], null == e[i] && (e[i] = n);
                return e
            }, e.prototype.isMobile = function (e) {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(e)
            }, e.prototype.createEvent = function (e, t, i, n) {
                var r;
                return null == t && (t = !1), null == i && (i = !1), null == n && (n = null), null != document.createEvent ? (r = document.createEvent("CustomEvent")).initCustomEvent(e, t, i, n) : null != document.createEventObject ? (r = document.createEventObject()).eventType = e : r.eventName = e, r
            }, e.prototype.emitEvent = function (e, t) {
                return null != e.dispatchEvent ? e.dispatchEvent(t) : t in (null != e) ? e[t]() : "on" + t in (null != e) ? e["on" + t]() : void 0
            }, e.prototype.addEvent = function (e, t, i) {
                return null != e.addEventListener ? e.addEventListener(t, i, !1) : null != e.attachEvent ? e.attachEvent("on" + t, i) : e[t] = i
            }, e.prototype.removeEvent = function (e, t, i) {
                return null != e.removeEventListener ? e.removeEventListener(t, i, !1) : null != e.detachEvent ? e.detachEvent("on" + t, i) : delete e[t]
            }, e.prototype.innerHeight = function () {
                return "innerHeight" in window ? window.innerHeight : document.documentElement.clientHeight
            }, e
        }(), i = this.WeakMap || this.MozWeakMap || (i = function () {
            function e() {
                this.keys = [], this.values = []
            }
            return e.prototype.get = function (e) {
                var t, i, n, r;
                for (t = i = 0, n = (r = this.keys).length; n > i; t = ++i)
                    if (r[t] === e) return this.values[t]
            }, e.prototype.set = function (e, t) {
                var i, n, r, o;
                for (i = n = 0, r = (o = this.keys).length; r > n; i = ++n)
                    if (o[i] === e) return void(this.values[i] = t);
                return this.keys.push(e), this.values.push(t)
            }, e
        }()), e = this.MutationObserver || this.WebkitMutationObserver || this.MozMutationObserver || (e = function () {
            function e() {
                "undefined" != typeof console && null !== console && console.warn("MutationObserver is not supported by your browser."), "undefined" != typeof console && null !== console && console.warn("WOW.js cannot detect dom mutations, please call .sync() after loading new content.")
            }
            return e.notSupported = !0, e.prototype.observe = function () {}, e
        }()), n = this.getComputedStyle || function (e) {
            return this.getPropertyValue = function (t) {
                var i;
                return "float" === t && (t = "styleFloat"), r.test(t) && t.replace(r, (function (e, t) {
                    return t.toUpperCase()
                })), (null != (i = e.currentStyle) ? i[t] : void 0) || null
            }, this
        }, r = /(\-([a-z]){1})/g, this.WOW = function () {
            function r(e) {
                null == e && (e = {}), this.scrollCallback = o(this.scrollCallback, this), this.scrollHandler = o(this.scrollHandler, this), this.resetAnimation = o(this.resetAnimation, this), this.start = o(this.start, this), this.scrolled = !0, this.config = this.util().extend(e, this.defaults), this.animationNameCache = new i, this.wowEvent = this.util().createEvent(this.config.boxClass)
            }
            return r.prototype.defaults = {
                boxClass: "wow",
                animateClass: "animated",
                offset: 0,
                mobile: !0,
                live: !0,
                callback: null
            }, r.prototype.init = function () {
                var e;
                return this.element = window.document.documentElement, "interactive" === (e = document.readyState) || "complete" === e ? this.start() : this.util().addEvent(document, "DOMContentLoaded", this.start), this.finished = []
            }, r.prototype.start = function () {
                var t, i, n, r;
                if (this.stopped = !1, this.boxes = function () {
                        var e, i, n, r;
                        for (r = [], e = 0, i = (n = this.element.querySelectorAll("." + this.config.boxClass)).length; i > e; e++) t = n[e], r.push(t);
                        return r
                    }.call(this), this.all = function () {
                        var e, i, n, r;
                        for (r = [], e = 0, i = (n = this.boxes).length; i > e; e++) t = n[e], r.push(t);
                        return r
                    }.call(this), this.boxes.length)
                    if (this.disabled()) this.resetStyle();
                    else
                        for (i = 0, n = (r = this.boxes).length; n > i; i++) t = r[i], this.applyStyle(t, !0);
                return this.disabled() || (this.util().addEvent(window, "scroll", this.scrollHandler), this.util().addEvent(window, "resize", this.scrollHandler), this.interval = setInterval(this.scrollCallback, 50)), this.config.live ? new e(function (e) {
                    return function (t) {
                        var i, n, r, o, s;
                        for (s = [], i = 0, n = t.length; n > i; i++) o = t[i], s.push(function () {
                            var e, t, i, n;
                            for (n = [], e = 0, t = (i = o.addedNodes || []).length; t > e; e++) r = i[e], n.push(this.doSync(r));
                            return n
                        }.call(e));
                        return s
                    }
                }(this)).observe(document.body, {
                    childList: !0,
                    subtree: !0
                }) : void 0
            }, r.prototype.stop = function () {
                return this.stopped = !0, this.util().removeEvent(window, "scroll", this.scrollHandler), this.util().removeEvent(window, "resize", this.scrollHandler), null != this.interval ? clearInterval(this.interval) : void 0
            }, r.prototype.sync = function () {
                return e.notSupported ? this.doSync(this.element) : void 0
            }, r.prototype.doSync = function (e) {
                var t, i, n, r, o;
                if (null == e && (e = this.element), 1 === e.nodeType) {
                    for (o = [], i = 0, n = (r = (e = e.parentNode || e).querySelectorAll("." + this.config.boxClass)).length; n > i; i++) t = r[i], s.call(this.all, t) < 0 ? (this.boxes.push(t), this.all.push(t), this.stopped || this.disabled() ? this.resetStyle() : this.applyStyle(t, !0), o.push(this.scrolled = !0)) : o.push(void 0);
                    return o
                }
            }, r.prototype.show = function (e) {
                return this.applyStyle(e), e.className = e.className + " " + this.config.animateClass, null != this.config.callback && this.config.callback(e), this.util().emitEvent(e, this.wowEvent), this.util().addEvent(e, "animationend", this.resetAnimation), this.util().addEvent(e, "oanimationend", this.resetAnimation), this.util().addEvent(e, "webkitAnimationEnd", this.resetAnimation), this.util().addEvent(e, "MSAnimationEnd", this.resetAnimation), e
            }, r.prototype.applyStyle = function (e, t) {
                var i, n, r;
                return n = e.getAttribute("data-wow-duration"), i = e.getAttribute("data-wow-delay"), r = e.getAttribute("data-wow-iteration"), this.animate(function (o) {
                    return function () {
                        return o.customStyle(e, t, n, i, r)
                    }
                }(this))
            }, r.prototype.animate = "requestAnimationFrame" in window ? function (e) {
                return window.requestAnimationFrame(e)
            } : function (e) {
                return e()
            }, r.prototype.resetStyle = function () {
                var e, t, i, n, r;
                for (r = [], t = 0, i = (n = this.boxes).length; i > t; t++) e = n[t], r.push(e.style.visibility = "visible");
                return r
            }, r.prototype.resetAnimation = function (e) {
                var t;
                return e.type.toLowerCase().indexOf("animationend") >= 0 ? (t = e.target || e.srcElement).className = t.className.replace(this.config.animateClass, "").trim() : void 0
            }, r.prototype.customStyle = function (e, t, i, n, r) {
                return t && this.cacheAnimationName(e), e.style.visibility = t ? "hidden" : "visible", i && this.vendorSet(e.style, {
                    animationDuration: i
                }), n && this.vendorSet(e.style, {
                    animationDelay: n
                }), r && this.vendorSet(e.style, {
                    animationIterationCount: r
                }), this.vendorSet(e.style, {
                    animationName: t ? "none" : this.cachedAnimationName(e)
                }), e
            }, r.prototype.vendors = ["moz", "webkit"], r.prototype.vendorSet = function (e, t) {
                var i, n, r, o;
                for (i in n = [], t) r = t[i], e["" + i] = r, n.push(function () {
                    var t, n, s, a;
                    for (a = [], t = 0, n = (s = this.vendors).length; n > t; t++) o = s[t], a.push(e["" + o + i.charAt(0).toUpperCase() + i.substr(1)] = r);
                    return a
                }.call(this));
                return n
            }, r.prototype.vendorCSS = function (e, t) {
                var i, r, o, s, a, l;
                for (s = (a = n(e)).getPropertyCSSValue(t), i = 0, r = (o = this.vendors).length; r > i; i++) l = o[i], s = s || a.getPropertyCSSValue("-" + l + "-" + t);
                return s
            }, r.prototype.animationName = function (e) {
                var t;
                try {
                    t = this.vendorCSS(e, "animation-name").cssText
                } catch (i) {
                    t = n(e).getPropertyValue("animation-name")
                }
                return "none" === t ? "" : t
            }, r.prototype.cacheAnimationName = function (e) {
                return this.animationNameCache.set(e, this.animationName(e))
            }, r.prototype.cachedAnimationName = function (e) {
                return this.animationNameCache.get(e)
            }, r.prototype.scrollHandler = function () {
                return this.scrolled = !0
            }, r.prototype.scrollCallback = function () {
                var e;
                return !this.scrolled || (this.scrolled = !1, this.boxes = function () {
                    var t, i, n, r;
                    for (r = [], t = 0, i = (n = this.boxes).length; i > t; t++)(e = n[t]) && (this.isVisible(e) ? this.show(e) : r.push(e));
                    return r
                }.call(this), this.boxes.length || this.config.live) ? void 0 : this.stop()
            }, r.prototype.offsetTop = function (e) {
                for (var t; void 0 === e.offsetTop;) e = e.parentNode;
                for (t = e.offsetTop; e = e.offsetParent;) t += e.offsetTop;
                return t
            }, r.prototype.isVisible = function (e) {
                var t, i, n, r, o;
                return i = e.getAttribute("data-wow-offset") || this.config.offset, r = (o = window.pageYOffset) + Math.min(this.element.clientHeight, this.util().innerHeight()) - i, t = (n = this.offsetTop(e)) + e.clientHeight, r >= n && t >= o
            }, r.prototype.util = function () {
                return null != this._util ? this._util : this._util = new t
            }, r.prototype.disabled = function () {
                return !this.config.mobile && this.util().isMobile(navigator.userAgent)
            }, r
        }()
    }.call(this);